{"files":[{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","auth.rs"],"content":"use crate::AuthError;\n\nuse cookie::CookieJar;\nuse futures_util::{\n\tfuture,\n\tfuture::{FutureExt, TryFutureExt}\n};\nuse gotham::{\n\tanyhow,\n\thandler::HandlerFuture,\n\thyper::header::{HeaderMap, HeaderName, AUTHORIZATION},\n\tmiddleware::{cookie::CookieParser, Middleware, NewMiddleware},\n\tprelude::*,\n\tstate::State\n};\nuse jsonwebtoken::DecodingKey;\nuse serde::de::DeserializeOwned;\nuse std::{marker::PhantomData, panic::RefUnwindSafe, pin::Pin};\n\npub type AuthValidation = jsonwebtoken::Validation;\n\n/// The authentication status returned by the auth middleware for each request.\n#[derive(Debug, StateData)]\npub enum AuthStatus<T: Send + 'static> {\n\t/// The auth status is unknown. This is likely because no secret was provided\n\t/// that could be used to verify the token of the client.\n\tUnknown,\n\n\t/// The request has been performed without any kind of authentication.\n\tUnauthenticated,\n\n\t/// The request has been performed with an invalid authentication. This\n\t/// includes expired tokens. Further details can be obtained from the\n\t/// included error.\n\tInvalid(jsonwebtoken::errors::Error),\n\n\t/// The request has been performed with a valid authentication. The claims\n\t/// that were decoded from the token are attached.\n\tAuthenticated(T)\n}\n\nimpl<T> Clone for AuthStatus<T>\nwhere\n\tT: Clone + Send + 'static\n{\n\tfn clone(&self) -> Self {\n\t\t// TODO why is this manually implemented?\n\t\tmatch self {\n\t\t\tSelf::Unknown => Self::Unknown,\n\t\t\tSelf::Unauthenticated => Self::Unauthenticated,\n\t\t\tSelf::Invalid(err) => Self::Invalid(err.clone()),\n\t\t\tSelf::Authenticated(data) => Self::Authenticated(data.clone())\n\t\t}\n\t}\n}\n\nimpl<T: Send + 'static> AuthStatus<T> {\n\tpub fn ok(self) -> Result<T, AuthError> {\n\t\tmatch self {\n\t\t\tSelf::Unknown => Err(AuthError::new(\"The authentication could not be determined\")),\n\t\t\tSelf::Unauthenticated => Err(AuthError::new(\"Missing token\")),\n\t\t\tSelf::Invalid(err) => Err(AuthError::new(format!(\"Invalid token: {err}\"))),\n\t\t\tSelf::Authenticated(data) => Ok(data)\n\t\t}\n\t}\n}\n\n/// The source of the authentication token in the request.\n#[derive(Clone, Debug, StateData)]\npub enum AuthSource {\n\t/// Take the token from a cookie with the given name.\n\tCookie(String),\n\t/// Take the token from a header with the given name.\n\tHeader(HeaderName),\n\t/// Take the token from the HTTP Authorization header. This is different from `Header(\"Authorization\")`\n\t/// as it will follow the `scheme param` format from the HTTP specification. The `scheme` will\n\t/// be discarded, so its value doesn't matter.\n\tAuthorizationHeader\n}\n\n/**\nThis trait will help the auth middleware to determine the validity of an authentication token.\n\nA very basic implementation could look like this:\n\n```\n# use gotham_restful::{AuthHandler, gotham::state::State};\n#\nconst SECRET : &'static [u8; 32] = b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\";\n\nstruct CustomAuthHandler;\nimpl<T> AuthHandler<T> for CustomAuthHandler {\n\tfn jwt_secret<F : FnOnce() -> Option<T>>(&self, _state : &mut State, _decode_data : F) -> Option<Vec<u8>> {\n\t\tSome(SECRET.to_vec())\n\t}\n}\n```\n*/\npub trait AuthHandler<Data> {\n\t/// Return the SHA256-HMAC secret used to verify the JWT token.\n\tfn jwt_secret<F: FnOnce() -> Option<Data>>(\n\t\t&self,\n\t\tstate: &mut State,\n\t\tdecode_data: F\n\t) -> Option<Vec<u8>>;\n}\n\n/// An [AuthHandler] returning always the same secret. See [AuthMiddleware] for a usage example.\n#[derive(Clone, Debug)]\npub struct StaticAuthHandler {\n\tsecret: Vec<u8>\n}\n\nimpl StaticAuthHandler {\n\tpub fn from_vec(secret: Vec<u8>) -> Self {\n\t\tSelf { secret }\n\t}\n\n\tpub fn from_array(secret: &[u8]) -> Self {\n\t\tSelf::from_vec(secret.to_vec())\n\t}\n}\n\nimpl<T> AuthHandler<T> for StaticAuthHandler {\n\tfn jwt_secret<F: FnOnce() -> Option<T>>(\n\t\t&self,\n\t\t_state: &mut State,\n\t\t_decode_data: F\n\t) -> Option<Vec<u8>> {\n\t\tSome(self.secret.clone())\n\t}\n}\n\n/**\nThis is the auth middleware. To use it, first make sure you have the `auth` feature enabled. Then\nsimply add it to your pipeline and request it inside your handler:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::{router::builder::*, pipeline::*, state::State};\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n#\n#[derive(Resource)]\n#[resource(read_all)]\nstruct AuthResource;\n\n#[derive(Debug, Deserialize, Clone)]\nstruct AuthData {\n\tsub: String,\n\texp: u64\n}\n\n#[read_all]\nfn read_all(auth : &AuthStatus<AuthData>) -> Success<String> {\n\tformat!(\"{auth:?}\").into()\n}\n\nfn main() {\n\tlet auth: AuthMiddleware<AuthData, _> = AuthMiddleware::new(\n\t\tAuthSource::AuthorizationHeader,\n\t\tAuthValidation::default(),\n\t\tStaticAuthHandler::from_array(b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\")\n\t);\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(auth).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\troute.resource::<AuthResource>(\"auth\");\n\t}));\n}\n```\n*/\n#[derive(Debug)]\npub struct AuthMiddleware<Data, Handler> {\n\tsource: AuthSource,\n\tvalidation: AuthValidation,\n\thandler: Handler,\n\t_data: PhantomData<Data>\n}\n\nimpl<Data, Handler> Clone for AuthMiddleware<Data, Handler>\nwhere\n\tHandler: Clone\n{\n\tfn clone(&self) -> Self {\n\t\tSelf {\n\t\t\tsource: self.source.clone(),\n\t\t\tvalidation: self.validation.clone(),\n\t\t\thandler: self.handler.clone(),\n\t\t\t_data: self._data\n\t\t}\n\t}\n}\n\nimpl<Data, Handler> AuthMiddleware<Data, Handler>\nwhere\n\tData: DeserializeOwned + Send,\n\tHandler: AuthHandler<Data> + Default\n{\n\tpub fn from_source(source: AuthSource) -> Self {\n\t\tSelf {\n\t\t\tsource,\n\t\t\tvalidation: Default::default(),\n\t\t\thandler: Default::default(),\n\t\t\t_data: Default::default()\n\t\t}\n\t}\n}\n\nimpl<Data, Handler> AuthMiddleware<Data, Handler>\nwhere\n\tData: DeserializeOwned + Send,\n\tHandler: AuthHandler<Data>\n{\n\tpub fn new(source: AuthSource, validation: AuthValidation, handler: Handler) -> Self {\n\t\tSelf {\n\t\t\tsource,\n\t\t\tvalidation,\n\t\t\thandler,\n\t\t\t_data: Default::default()\n\t\t}\n\t}\n\n\tfn auth_status(&self, state: &mut State) -> AuthStatus<Data> {\n\t\t// extract the provided token, if any\n\t\tlet token = match &self.source {\n\t\t\tAuthSource::Cookie(name) => CookieJar::try_borrow_from(&state)\n\t\t\t\t.map(|jar| jar.get(&name).map(|cookie| cookie.value().to_owned()))\n\t\t\t\t.unwrap_or_else(|| {\n\t\t\t\t\tCookieParser::from_state(&state)\n\t\t\t\t\t\t.get(&name)\n\t\t\t\t\t\t.map(|cookie| cookie.value().to_owned())\n\t\t\t\t}),\n\t\t\tAuthSource::Header(name) => HeaderMap::try_borrow_from(&state)\n\t\t\t\t.and_then(|map| map.get(name))\n\t\t\t\t.and_then(|header| header.to_str().ok())\n\t\t\t\t.map(|value| value.to_owned()),\n\t\t\tAuthSource::AuthorizationHeader => HeaderMap::try_borrow_from(&state)\n\t\t\t\t.and_then(|map| map.get(AUTHORIZATION))\n\t\t\t\t.and_then(|header| header.to_str().ok())\n\t\t\t\t.and_then(|value| value.split_whitespace().nth(1))\n\t\t\t\t.map(|value| value.to_owned())\n\t\t};\n\n\t\t// unauthed if no token\n\t\tlet token = match token {\n\t\t\tSome(token) => token,\n\t\t\tNone => return AuthStatus::Unauthenticated\n\t\t};\n\n\t\t// get the secret from the handler, possibly decoding claims ourselves\n\t\tlet secret = self.handler.jwt_secret(state, || {\n\t\t\tlet b64 = token.split('.').nth(1)?;\n\t\t\tlet raw = base64::decode_config(b64, base64::URL_SAFE_NO_PAD).ok()?;\n\t\t\tserde_json::from_slice(&raw).ok()?\n\t\t});\n\n\t\t// unknown if no secret\n\t\tlet secret = match secret {\n\t\t\tSome(secret) => secret,\n\t\t\tNone => return AuthStatus::Unknown\n\t\t};\n\n\t\t// validate the token\n\t\tlet data: Data = match jsonwebtoken::decode(\n\t\t\t&token,\n\t\t\t&DecodingKey::from_secret(&secret),\n\t\t\t&self.validation\n\t\t) {\n\t\t\tOk(data) => data.claims,\n\t\t\tErr(e) => return AuthStatus::Invalid(e)\n\t\t};\n\n\t\t// we found a valid token\n\t\tAuthStatus::Authenticated(data)\n\t}\n}\n\nimpl<Data, Handler> Middleware for AuthMiddleware<Data, Handler>\nwhere\n\tData: DeserializeOwned + Send + 'static,\n\tHandler: AuthHandler<Data>\n{\n\tfn call<Chain>(self, mut state: State, chain: Chain) -> Pin<Box<HandlerFuture>>\n\twhere\n\t\tChain: FnOnce(State) -> Pin<Box<HandlerFuture>>\n\t{\n\t\t// put the source in our state, required for e.g. openapi\n\t\tstate.put(self.source.clone());\n\n\t\t// put the status in our state\n\t\tlet status = self.auth_status(&mut state);\n\t\tstate.put(status);\n\n\t\t// call the rest of the chain\n\t\tchain(state)\n\t\t\t.and_then(|(state, res)| future::ok((state, res)))\n\t\t\t.boxed()\n\t}\n}\n\nimpl<Data, Handler> NewMiddleware for AuthMiddleware<Data, Handler>\nwhere\n\tSelf: Clone + Middleware + Sync + RefUnwindSafe\n{\n\ttype Instance = Self;\n\n\tfn new_middleware(&self) -> anyhow::Result<Self> {\n\t\tlet c: Self = self.clone();\n\t\tOk(c)\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse cookie::Cookie;\n\tuse gotham::hyper::header::COOKIE;\n\tuse jsonwebtoken::errors::ErrorKind;\n\tuse std::fmt::Debug;\n\n\t// 256-bit random string\n\tconst JWT_SECRET: &'static [u8; 32] = b\"Lyzsfnta0cdxyF0T9y6VGxp3jpgoMUuW\";\n\n\t// some known tokens\n\tconst VALID_TOKEN: &'static str = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJtc3JkMCIsInN1YiI6ImdvdGhhbS1yZXN0ZnVsIiwiaWF0IjoxNTc3ODM2ODAwLCJleHAiOjQxMDI0NDQ4MDB9.8h8Ax-nnykqEQ62t7CxmM3ja6NzUQ4L0MLOOzddjLKk\";\n\tconst EXPIRED_TOKEN: &'static str = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJtc3JkMCIsInN1YiI6ImdvdGhhbS1yZXN0ZnVsIiwiaWF0IjoxNTc3ODM2ODAwLCJleHAiOjE1Nzc4MzcxMDB9.eV1snaGLYrJ7qUoMk74OvBY3WUU9M0Je5HTU2xtX1v0\";\n\tconst INVALID_TOKEN: &'static str = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJtc3JkMCIsInN1YiI6ImdvdGhhbS1yZXN0ZnVsIiwiaWF0IjoxNTc3ODM2ODAwLCJleHAiOjQxMDI0NDQ4MDB9\";\n\n\t#[derive(Debug, Deserialize, PartialEq)]\n\tstruct TestData {\n\t\tiss: String,\n\t\tsub: String,\n\t\tiat: u64,\n\t\texp: u64\n\t}\n\n\timpl Default for TestData {\n\t\tfn default() -> Self {\n\t\t\tSelf {\n\t\t\t\tiss: \"msrd0\".to_owned(),\n\t\t\t\tsub: \"gotham-restful\".to_owned(),\n\t\t\t\tiat: 1577836800,\n\t\t\t\texp: 4102444800\n\t\t\t}\n\t\t}\n\t}\n\n\t#[derive(Default)]\n\tstruct NoneAuthHandler;\n\timpl<T> AuthHandler<T> for NoneAuthHandler {\n\t\tfn jwt_secret<F: FnOnce() -> Option<T>>(\n\t\t\t&self,\n\t\t\t_state: &mut State,\n\t\t\t_decode_data: F\n\t\t) -> Option<Vec<u8>> {\n\t\t\tNone\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_none_secret() {\n\t\tlet middleware = <AuthMiddleware<TestData, NoneAuthHandler>>::from_source(\n\t\t\tAuthSource::AuthorizationHeader\n\t\t);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(\n\t\t\t\tAUTHORIZATION,\n\t\t\t\tformat!(\"Bearer {VALID_TOKEN}\").parse().unwrap()\n\t\t\t);\n\t\t\tstate.put(headers);\n\t\t\tmiddleware.auth_status(&mut state);\n\t\t});\n\t}\n\n\t#[derive(Default)]\n\tstruct TestAssertingHandler;\n\timpl<T> AuthHandler<T> for TestAssertingHandler\n\twhere\n\t\tT: Debug + Default + PartialEq\n\t{\n\t\tfn jwt_secret<F: FnOnce() -> Option<T>>(\n\t\t\t&self,\n\t\t\t_state: &mut State,\n\t\t\tdecode_data: F\n\t\t) -> Option<Vec<u8>> {\n\t\t\tassert_eq!(decode_data(), Some(T::default()));\n\t\t\tSome(JWT_SECRET.to_vec())\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_decode_data() {\n\t\tlet middleware = <AuthMiddleware<TestData, TestAssertingHandler>>::from_source(\n\t\t\tAuthSource::AuthorizationHeader\n\t\t);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(\n\t\t\t\tAUTHORIZATION,\n\t\t\t\tformat!(\"Bearer {VALID_TOKEN}\").parse().unwrap()\n\t\t\t);\n\t\t\tstate.put(headers);\n\t\t\tmiddleware.auth_status(&mut state);\n\t\t});\n\t}\n\n\tfn new_middleware<T>(source: AuthSource) -> AuthMiddleware<T, StaticAuthHandler>\n\twhere\n\t\tT: DeserializeOwned + Send\n\t{\n\t\tAuthMiddleware::new(\n\t\t\tsource,\n\t\t\tDefault::default(),\n\t\t\tStaticAuthHandler::from_array(JWT_SECRET)\n\t\t)\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_no_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Unauthenticated => {},\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Unauthenticated, got {status:?}\")\n\t\t\t};\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_expired_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(\n\t\t\t\tAUTHORIZATION,\n\t\t\t\tformat!(\"Bearer {EXPIRED_TOKEN}\").parse().unwrap()\n\t\t\t);\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Invalid(err) if *err.kind() == ErrorKind::ExpiredSignature => {},\n\t\t\t\t_ => panic!(\n\t\t\t\t\t\"Expected AuthStatus::Invalid(..) with ErrorKind::ExpiredSignature, got {status:?}\"\n\t\t\t\t)\n\t\t\t};\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_invalid_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(\n\t\t\t\tAUTHORIZATION,\n\t\t\t\tformat!(\"Bearer {INVALID_TOKEN}\").parse().unwrap()\n\t\t\t);\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Invalid(err) if *err.kind() == ErrorKind::InvalidToken => {},\n\t\t\t\t_ => panic!(\n\t\t\t\t\t\"Expected AuthStatus::Invalid(..) with ErrorKind::InvalidToken, got {status:?}\"\n\t\t\t\t)\n\t\t\t};\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_auth_header_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(\n\t\t\t\tAUTHORIZATION,\n\t\t\t\tformat!(\"Bearer {VALID_TOKEN}\").parse().unwrap()\n\t\t\t);\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {status:?}\")\n\t\t\t};\n\t\t})\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_header_token() {\n\t\tlet header_name = \"x-znoiprwmvfexju\";\n\t\tlet middleware =\n\t\t\tnew_middleware::<TestData>(AuthSource::Header(HeaderName::from_static(header_name)));\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(header_name, VALID_TOKEN.parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {status:?}\")\n\t\t\t};\n\t\t})\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_cookie_token() {\n\t\tlet cookie_name = \"znoiprwmvfexju\";\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::Cookie(cookie_name.to_owned()));\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut jar = CookieJar::new();\n\t\t\tjar.add_original(Cookie::new(cookie_name, VALID_TOKEN));\n\t\t\tstate.put(jar);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {status:?}\")\n\t\t\t};\n\t\t})\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_cookie_no_jar() {\n\t\tlet cookie_name = \"znoiprwmvfexju\";\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::Cookie(cookie_name.to_owned()));\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(\n\t\t\t\tCOOKIE,\n\t\t\t\tformat!(\"{cookie_name}={VALID_TOKEN}\").parse().unwrap()\n\t\t\t);\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {status:?}\")\n\t\t\t};\n\t\t})\n\t}\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2077616],"length":1,"stats":{"Line":3},"fn_name":"from_vec"},{"line":119,"address":[2077680],"length":1,"stats":{"Line":3},"fn_name":"from_array"},{"line":120,"address":[2077703],"length":1,"stats":{"Line":3},"fn_name":null},{"line":125,"address":[2077744,2077840],"length":1,"stats":{"Line":2},"fn_name":"jwt_secret<gotham_restful::auth::test::TestData, gotham_restful::auth::{impl#6}::auth_status::{closure#9}>"},{"line":130,"address":[2077773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[2078095,2077872,2078112,2078335],"length":1,"stats":{"Line":2},"fn_name":"from_source<gotham_restful::auth::test::TestData, gotham_restful::auth::test::NoneAuthHandler>"},{"line":202,"address":[2078154,2077914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[2077930,2078170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[2077974,2078214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[2078630,2078352],"length":1,"stats":{"Line":3},"fn_name":"new<gotham_restful::auth::test::TestData, gotham_restful::auth::StaticAuthHandler>"},{"line":219,"address":[2078458],"length":1,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[2083419,2078656,2080212,2080256,2081856,2081812],"length":1,"stats":{"Line":5},"fn_name":"auth_status<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":225,"address":[2081903,2078703,2080303],"length":1,"stats":{"Line":5},"fn_name":null},{"line":226,"address":[2080360,2080692,2079145,2081960,2078760,2080745,2082345,2082292,2079092],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[2083822,2083456,2083568,2083597,2083982,2082276,2083709,2080676,2083680,2083872,2083792,2083952,2083485,2083902,2079076],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":228,"address":[2082313,2084448,2084032,2084240,2084413,2080713,2084621,2079113,2084205],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":229,"address":[2084601,2084486,2084535,2084185,2084119,2084393,2084070,2084327,2084278],"length":1,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[2084089,2084505,2084297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[2084736,2084686,2084656,2084766,2084816,2084846],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":233,"address":[2079005,2078806,2080406,2082006,2080605,2082205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[2084960,2078989,2084987,2080589,2085051,2085024,2082189,2084923,2084896],"length":1,"stats":{"Line":3},"fn_name":"{closure#2}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::NoneAuthHandler>"},{"line":235,"address":[2085257,2085097,2085248,2085168,2085177,2085088],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}<gotham_restful::auth::test::TestData, gotham_restful::auth::StaticAuthHandler>"},{"line":236,"address":[2085398,2085376,2085424,2085328,2085350,2085446],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}<gotham_restful::auth::test::TestData, gotham_restful::auth::StaticAuthHandler>"},{"line":237,"address":[2078844,2082044,2080444],"length":1,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[2085485,2085632,2085552,2085645,2085472,2085565],"length":1,"stats":{"Line":8},"fn_name":"{closure#5}<gotham_restful::auth::test::TestData, gotham_restful::auth::StaticAuthHandler>"},{"line":239,"address":[2085801,2085881,2085872,2085712,2085792,2085721],"length":1,"stats":{"Line":6},"fn_name":"{closure#6}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::NoneAuthHandler>"},{"line":240,"address":[2086112,2085952,2085972,2086032,2086052,2086132],"length":1,"stats":{"Line":6},"fn_name":"{closure#7}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":241,"address":[2086262,2086310,2086192,2086288,2086214,2086240],"length":1,"stats":{"Line":6},"fn_name":"{closure#8}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":245,"address":[2078951,2080787,2082387,2080551,2082151,2079187],"length":1,"stats":{"Line":4},"fn_name":null},{"line":246,"address":[2079217,2080817,2082417],"length":1,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[2079197,2080797,2082397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[2082481,2086336,2079281,2086924,2080881],"length":1,"stats":{"Line":4},"fn_name":"{closure#9}<gotham_restful::auth::test::TestData, gotham_restful::auth::test::TestAssertingHandler>"},{"line":252,"address":[2086374,2086607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[2086625,2086789,2086534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[2086877,2086756,2086939,2086816,2087015],"length":1,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[2079328,2082599,2079392,2080928,2080992,2082535],"length":1,"stats":{"Line":4},"fn_name":null},{"line":259,"address":[2081014,2079414,2082621],"length":1,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[2079402,2081002,2082609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[2079660,2081260,2079728,2081328,2082867,2082935],"length":1,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[2081086,2082693,2079486],"length":1,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[2081123,2079523,2082810,2079603,2081203,2082730],"length":1,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[2081240,2079640,2082847],"length":1,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[2079730,2082937,2081330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[2081453,2083060,2079853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[2081618,2083225,2080018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[2805184,2805594,2806042,2803802,2806080,2804736,2803840,2805632,2806490,2803392,2805146,2804250,2804698,2806528,2806976,2807410,2804288,2806938],"length":1,"stats":{"Line":1},"fn_name":"call<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler, gotham::router::route::dispatch::{impl#1}::dispatch::{closure#0}>"},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":58,"coverable":71},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","cors.rs"],"content":"use gotham::{\n\thandler::HandlerFuture,\n\thelpers::http::response::create_empty_response,\n\thyper::{\n\t\theader::{\n\t\t\tHeaderMap, HeaderName, HeaderValue, ACCESS_CONTROL_ALLOW_CREDENTIALS,\n\t\t\tACCESS_CONTROL_ALLOW_HEADERS, ACCESS_CONTROL_ALLOW_METHODS,\n\t\t\tACCESS_CONTROL_ALLOW_ORIGIN, ACCESS_CONTROL_MAX_AGE, ACCESS_CONTROL_REQUEST_HEADERS,\n\t\t\tACCESS_CONTROL_REQUEST_METHOD, ORIGIN, VARY\n\t\t},\n\t\tBody, Method, Response, StatusCode\n\t},\n\tmiddleware::Middleware,\n\tpipeline::PipelineHandleChain,\n\tprelude::*,\n\trouter::{builder::ExtendRouteMatcher, route::matcher::AccessControlRequestMethodMatcher},\n\tstate::State\n};\nuse std::{panic::RefUnwindSafe, pin::Pin};\n\n/**\nSpecify the allowed origins of the request. It is up to the browser to check the validity of the\norigin. This, when sent to the browser, will indicate whether or not the request's origin was\nallowed to make the request.\n*/\n#[derive(Clone, Debug)]\npub enum Origin {\n\t/// Do not send any `Access-Control-Allow-Origin` headers.\n\tNone,\n\t/// Send `Access-Control-Allow-Origin: *`. Note that browser will not send credentials.\n\tStar,\n\t/// Set the `Access-Control-Allow-Origin` header to a single origin.\n\tSingle(String),\n\t/// Copy the `Origin` header into the `Access-Control-Allow-Origin` header.\n\tCopy\n}\n\nimpl Default for Origin {\n\tfn default() -> Self {\n\t\tSelf::None\n\t}\n}\n\nimpl Origin {\n\t/// Get the header value for the `Access-Control-Allow-Origin` header.\n\tfn header_value(&self, state: &State) -> Option<HeaderValue> {\n\t\tmatch self {\n\t\t\tSelf::None => None,\n\t\t\tSelf::Star => Some(\"*\".parse().unwrap()),\n\t\t\tSelf::Single(origin) => Some(origin.parse().unwrap()),\n\t\t\tSelf::Copy => {\n\t\t\t\tlet headers = HeaderMap::borrow_from(state);\n\t\t\t\theaders.get(ORIGIN).map(Clone::clone)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Returns true if the `Vary` header has to include `Origin`.\n\tfn varies(&self) -> bool {\n\t\tmatches!(self, Self::Copy)\n\t}\n}\n\n/**\nSpecify the allowed headers of the request. It is up to the browser to check that only the allowed\nheaders are sent with the request.\n*/\n#[derive(Clone, Debug)]\npub enum Headers {\n\t/// Do not send any `Access-Control-Allow-Headers` headers.\n\tNone,\n\t/// Set the `Access-Control-Allow-Headers` header to the following header list. If empty, this\n\t/// is treated as if it was [None].\n\tList(Vec<HeaderName>),\n\t/// Copy the `Access-Control-Request-Headers` header into the `Access-Control-Allow-Header`\n\t/// header.\n\tCopy\n}\n\nimpl Default for Headers {\n\tfn default() -> Self {\n\t\tSelf::None\n\t}\n}\n\nimpl Headers {\n\t/// Get the header value for the `Access-Control-Allow-Headers` header.\n\tfn header_value(&self, state: &State) -> Option<HeaderValue> {\n\t\tmatch self {\n\t\t\tSelf::None => None,\n\t\t\tSelf::List(list) => Some(list.join(\",\").parse().unwrap()),\n\t\t\tSelf::Copy => {\n\t\t\t\tlet headers = HeaderMap::borrow_from(state);\n\t\t\t\theaders\n\t\t\t\t\t.get(ACCESS_CONTROL_REQUEST_HEADERS)\n\t\t\t\t\t.map(Clone::clone)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Returns true if the `Vary` header has to include `Origin`.\n\tfn varies(&self) -> bool {\n\t\tmatches!(self, Self::Copy)\n\t}\n}\n\n/**\nThis is the configuration that the CORS handler will follow. Its default configuration is basically\nnot to touch any responses, resulting in the browser's default behaviour.\n\nTo change settings, you need to put this type into gotham's [State]:\n\n```rust,no_run\n# use gotham::{router::builder::*, pipeline::*, state::State};\n# use gotham_restful::{*, cors::Origin};\n# #[cfg_attr(feature = \"cargo-clippy\", allow(clippy::needless_doctest_main))]\nfn main() {\n\tlet cors = CorsConfig {\n\t\torigin: Origin::Star,\n\t\t..Default::default()\n\t};\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(cors).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\t// your routing logic\n\t}));\n}\n```\n\nThis easy approach allows you to have one global cors configuration. If you prefer to have separate\nconfigurations for different scopes, you need to register the middleware inside your routing logic:\n\n```rust,no_run\n# use gotham::{router::builder::*, pipeline::*, state::State};\n# use gotham_restful::{*, cors::Origin};\nlet pipelines = new_pipeline_set();\n\n// The first cors configuration\nlet cors_a = CorsConfig {\n\torigin: Origin::Star,\n\t..Default::default()\n};\nlet (pipelines, chain_a) = pipelines.add(\n\tnew_pipeline().add(cors_a).build()\n);\n\n// The second cors configuration\nlet cors_b = CorsConfig {\n\torigin: Origin::Copy,\n\t..Default::default()\n};\nlet (pipelines, chain_b) = pipelines.add(\n\tnew_pipeline().add(cors_b).build()\n);\n\nlet pipeline_set = finalize_pipeline_set(pipelines);\ngotham::start(\"127.0.0.1:8080\", build_router((), pipeline_set, |route| {\n\t// routing without any cors config\n\troute.with_pipeline_chain((chain_a, ()), |route| {\n\t\t// routing with cors config a\n\t});\n\troute.with_pipeline_chain((chain_b, ()), |route| {\n\t\t// routing with cors config b\n\t});\n}));\n```\n*/\n#[derive(Clone, Debug, Default, NewMiddleware, StateData)]\npub struct CorsConfig {\n\t/// The allowed origins.\n\tpub origin: Origin,\n\t/// The allowed headers.\n\tpub headers: Headers,\n\t/// The amount of seconds that the preflight request can be cached.\n\tpub max_age: u64,\n\t/// Whether or not the request may be made with supplying credentials.\n\tpub credentials: bool\n}\n\nimpl Middleware for CorsConfig {\n\tfn call<Chain>(self, mut state: State, chain: Chain) -> Pin<Box<HandlerFuture>>\n\twhere\n\t\tChain: FnOnce(State) -> Pin<Box<HandlerFuture>>\n\t{\n\t\tstate.put(self);\n\t\tchain(state)\n\t}\n}\n\n/**\nHandle CORS for a non-preflight request. This means manipulating the `res` HTTP headers so that\nthe response is aligned with the `state`'s [CorsConfig].\n\nIf you are using the [Resource](crate::Resource) type (which is the recommended way), you'll never\nhave to call this method. However, if you are writing your own handler method, you might want to\ncall this after your request to add the required CORS headers.\n\nFor further information on CORS, read <https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>.\n*/\npub fn handle_cors(state: &State, res: &mut Response<Body>) {\n\tlet config = CorsConfig::try_borrow_from(state);\n\tif let Some(cfg) = config {\n\t\tlet headers = res.headers_mut();\n\n\t\t// non-preflight requests require the Access-Control-Allow-Origin header\n\t\tif let Some(header) = cfg.origin.header_value(state) {\n\t\t\theaders.insert(ACCESS_CONTROL_ALLOW_ORIGIN, header);\n\t\t}\n\n\t\t// if the origin is copied over, we should tell the browser by specifying the Vary header\n\t\tif cfg.origin.varies() {\n\t\t\tlet vary = headers\n\t\t\t\t.get(VARY)\n\t\t\t\t.map(|vary| format!(\"{},origin\", vary.to_str().unwrap()));\n\t\t\theaders.insert(VARY, vary.as_deref().unwrap_or(\"origin\").parse().unwrap());\n\t\t}\n\n\t\t// if we allow credentials, tell the browser\n\t\tif cfg.credentials {\n\t\t\theaders.insert(\n\t\t\t\tACCESS_CONTROL_ALLOW_CREDENTIALS,\n\t\t\t\tHeaderValue::from_static(\"true\")\n\t\t\t);\n\t\t}\n\t}\n}\n\n/// Add CORS routing for your path. This is required for handling preflight requests.\n///\n/// Example:\n///\n/// ```rust,no_run\n/// # use gotham::{hyper::{Body, Method, Response}, router::builder::*};\n/// # use gotham_restful::*;\n/// build_simple_router(|router| {\n/// \t// The handler that needs preflight handling\n/// \trouter.post(\"/foo\").to(|state| {\n/// \t\tlet mut res: Response<Body> = unimplemented!();\n/// \t\thandle_cors(&state, &mut res);\n/// \t\t(state, res)\n/// \t});\n/// \t// Add preflight handling\n/// \trouter.cors(\"/foo\", Method::POST);\n/// });\n/// ```\npub trait CorsRoute<C, P>\nwhere\n\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\tP: RefUnwindSafe + Send + Sync + 'static\n{\n\t/// Handle a preflight request on `path` for `method`. To configure the behaviour, use\n\t/// [CorsConfig].\n\tfn cors(&mut self, path: &str, method: Method);\n}\n\npub(crate) fn cors_preflight_handler(state: State) -> (State, Response<Body>) {\n\tlet config = CorsConfig::try_borrow_from(&state);\n\n\t// prepare the response\n\tlet mut res = create_empty_response(&state, StatusCode::NO_CONTENT);\n\tlet headers = res.headers_mut();\n\tlet mut vary: Vec<HeaderName> = Vec::new();\n\n\t// copy the request method over to the response\n\tlet method = HeaderMap::borrow_from(&state)\n\t\t.get(ACCESS_CONTROL_REQUEST_METHOD)\n\t\t.unwrap()\n\t\t.clone();\n\theaders.insert(ACCESS_CONTROL_ALLOW_METHODS, method);\n\tvary.push(ACCESS_CONTROL_REQUEST_METHOD);\n\n\tif let Some(cfg) = config {\n\t\t// if we allow any headers, copy them over\n\t\tif let Some(header) = cfg.headers.header_value(&state) {\n\t\t\theaders.insert(ACCESS_CONTROL_ALLOW_HEADERS, header);\n\t\t}\n\n\t\t// if the headers are copied over, we should tell the browser by specifying the Vary header\n\t\tif cfg.headers.varies() {\n\t\t\tvary.push(ACCESS_CONTROL_REQUEST_HEADERS);\n\t\t}\n\n\t\t// set the max age for the preflight cache\n\t\tif let Some(age) = config.map(|cfg| cfg.max_age) {\n\t\t\theaders.insert(ACCESS_CONTROL_MAX_AGE, age.into());\n\t\t}\n\t}\n\n\t// make sure the browser knows that this request was based on the method\n\theaders.insert(VARY, vary.join(\",\").parse().unwrap());\n\n\thandle_cors(&state, &mut res);\n\t(state, res)\n}\n\nimpl<D, C, P> CorsRoute<C, P> for D\nwhere\n\tD: DrawRoutes<C, P>,\n\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\tP: RefUnwindSafe + Send + Sync + 'static\n{\n\tfn cors(&mut self, path: &str, method: Method) {\n\t\tlet matcher = AccessControlRequestMethodMatcher::new(method);\n\t\tself.options(path)\n\t\t\t.extend_route_matcher(matcher)\n\t\t\t.to(cors_preflight_handler);\n\t}\n}\n","traces":[{"line":39,"address":[1880272],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":40,"address":[1880275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[1880288],"length":1,"stats":{"Line":2},"fn_name":"header_value"},{"line":47,"address":[1880331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[1880367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[1880617,1880376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[1880409,1880549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[1880443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[1880462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1880672],"length":1,"stats":{"Line":2},"fn_name":"varies"},{"line":60,"address":[1880681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[1880720],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":82,"address":[1880723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[1881153,1880736],"length":1,"stats":{"Line":2},"fn_name":"header_value"},{"line":89,"address":[1880779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[1880816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[1880827,1880967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[1880861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[1880880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[1881168],"length":1,"stats":{"Line":2},"fn_name":"varies"},{"line":103,"address":[1881177],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[1893728,1894000,1894032,1894336,1894304,1894608],"length":1,"stats":{"Line":4},"fn_name":"call<gotham::router::route::dispatch::{impl#1}::dispatch::{closure#0}>"},{"line":184,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":199,"address":[1881216,1882002],"length":1,"stats":{"Line":6},"fn_name":"handle_cors"},{"line":200,"address":[1881249],"length":1,"stats":{"Line":6},"fn_name":null},{"line":201,"address":[1881267],"length":1,"stats":{"Line":6},"fn_name":null},{"line":202,"address":[1881313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[1881352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[1881428,1881545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[1881612,1881584],"length":1,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[1881638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[1882128,1882166],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":214,"address":[1881705,1881826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[1881623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[1882042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[1882017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[1882352,1884301],"length":1,"stats":{"Line":2},"fn_name":"cors_preflight_handler"},{"line":256,"address":[1882394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[1882465,1882530],"length":1,"stats":{"Line":4},"fn_name":null},{"line":260,"address":[1882538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[1882583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[1882636,1882771],"length":1,"stats":{"Line":4},"fn_name":null},{"line":268,"address":[1882815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[1882962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[1883030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[1883132,1883085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[1883395,1883235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[1883464,1883502],"length":1,"stats":{"Line":4},"fn_name":null},{"line":279,"address":[1883533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[1883508,1884336,1884345,1883613],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":284,"address":[1883660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[1883796,1883112],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[1884092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[1884107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":55,"coverable":60},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","endpoint.rs"],"content":"use crate::{IntoResponse, RequestBody};\nuse futures_util::future::BoxFuture;\nuse gotham::{\n\textractor::{PathExtractor, QueryStringExtractor},\n\thyper::{Body, Method, Response},\n\trouter::response::StaticResponseExtender,\n\tstate::{State, StateData}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiType, Visitor};\nuse serde::{Deserialize, Deserializer};\nuse std::borrow::Cow;\n\n/// A no-op extractor that can be used as a default type for [Endpoint::Placeholders] and\n/// [Endpoint::Params].\n#[derive(Debug, Clone, Copy)]\npub struct NoopExtractor;\n\nimpl<'de> Deserialize<'de> for NoopExtractor {\n\tfn deserialize<D: Deserializer<'de>>(_: D) -> Result<Self, D::Error> {\n\t\tOk(Self)\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl OpenapiType for NoopExtractor {\n\tfn visit_type<V: Visitor>(visitor: &mut V) {\n\t\twarn!(\n\t\t\t\"You're asking for the OpenAPI Schema for gotham_restful::NoopExtractor. This is probably not what you want.\"\n\t\t);\n\t\tvisitor.visit_unit();\n\t}\n}\n\nimpl StateData for NoopExtractor {}\n\nimpl StaticResponseExtender for NoopExtractor {\n\ttype ResBody = Body;\n\tfn extend(_: &mut State, _: &mut Response<Body>) {}\n}\n\n// TODO: Specify default types once https://github.com/rust-lang/rust/issues/29661 lands.\n#[_private_openapi_trait(EndpointWithSchema)]\npub trait Endpoint {\n\t/// The HTTP Verb of this endpoint.\n\tfn http_method() -> Method;\n\t/// The URI that this endpoint listens on in gotham's format.\n\tfn uri() -> Cow<'static, str>;\n\n\t/// The verb used for generating an operation id if [Self::operation_id] returns [None].\n\t/// For example `read`, `read_all`, `create`, `update` etc.\n\t#[openapi_only]\n\tfn operation_verb() -> Option<&'static str>;\n\n\t/// The output type that provides the response.\n\t#[openapi_bound(\"Output: crate::ResponseSchema\")]\n\ttype Output: IntoResponse + Send;\n\n\t/// Returns `true` _iff_ the URI contains placeholders. `false` by default.\n\tfn has_placeholders() -> bool {\n\t\tfalse\n\t}\n\t/// The type that parses the URI placeholders. Use [NoopExtractor] if `has_placeholders()`\n\t/// returns `false`.\n\t#[openapi_bound(\"Placeholders: OpenapiType\")]\n\ttype Placeholders: PathExtractor<Body> + Clone + Sync;\n\n\t/// Returns `true` _iff_ the request parameters should be parsed. `false` by default.\n\tfn needs_params() -> bool {\n\t\tfalse\n\t}\n\t/// The type that parses the request parameters. Use [NoopExtractor] if `needs_params()`\n\t/// returns `false`.\n\t#[openapi_bound(\"Params: OpenapiType\")]\n\ttype Params: QueryStringExtractor<Body> + Clone + Sync;\n\n\t/// Returns `true` _iff_ the request body should be parsed. `false` by default.\n\tfn needs_body() -> bool {\n\t\tfalse\n\t}\n\t/// The type to parse the body into. Use `()` if `needs_body()` returns `false`.\n\ttype Body: RequestBody + Send;\n\n\t/// Returns `true` if the request wants to know the auth status of the client. `false` by default.\n\tfn wants_auth() -> bool {\n\t\tfalse\n\t}\n\n\t/// Replace the automatically generated operation id with a custom one. Only relevant for the\n\t/// OpenAPI Specification.\n\t#[openapi_only]\n\tfn operation_id() -> Option<String> {\n\t\tNone\n\t}\n\n\t/// Add a description to the openapi specification. Usually taken from the rustdoc comment\n\t/// when using the proc macro.\n\t#[openapi_only]\n\tfn description() -> Option<String> {\n\t\tNone\n\t}\n\n\t/// The handler for this endpoint.\n\tfn handle(\n\t\tstate: &mut State,\n\t\tplaceholders: Self::Placeholders,\n\t\tparams: Self::Params,\n\t\tbody: Option<Self::Body>\n\t) -> BoxFuture<'_, Self::Output>;\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<E: EndpointWithSchema> Endpoint for E {\n\tfn http_method() -> Method {\n\t\tE::http_method()\n\t}\n\tfn uri() -> Cow<'static, str> {\n\t\tE::uri()\n\t}\n\n\ttype Output = E::Output;\n\n\tfn has_placeholders() -> bool {\n\t\tE::has_placeholders()\n\t}\n\ttype Placeholders = E::Placeholders;\n\n\tfn needs_params() -> bool {\n\t\tE::needs_params()\n\t}\n\ttype Params = E::Params;\n\n\tfn needs_body() -> bool {\n\t\tE::needs_body()\n\t}\n\ttype Body = E::Body;\n\n\tfn wants_auth() -> bool {\n\t\tE::wants_auth()\n\t}\n\n\tfn handle<'a>(\n\t\tstate: &'a mut State,\n\t\tplaceholders: Self::Placeholders,\n\t\tparams: Self::Params,\n\t\tbody: Option<Self::Body>\n\t) -> BoxFuture<'a, Self::Output> {\n\t\tE::handle(state, placeholders, params, body)\n\t}\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":21,"address":[2690024,2690073],"length":1,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[3962336],"length":1,"stats":{"Line":0},"fn_name":"visit_type<openapi_type::visitor::openapi::OpenapiVisitor>"},{"line":28,"address":[3962483,3962429,3962350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[3962475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[3962573,3962560],"length":1,"stats":{"Line":0},"fn_name":"extend"},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":114,"address":[2322624,2322592,2322528,2322560,2322464,2322496,2322656],"length":1,"stats":{"Line":30},"fn_name":"http_method<openapi_specification::search_secret___gotham_restful_endpoint>"},{"line":115,"address":[2322472,2322568,2322600,2322632,2322664,2322536,2322504],"length":1,"stats":{"Line":30},"fn_name":null},{"line":117,"address":[2322848,2322880,2322752,2322816,2322784,2322688,2322720],"length":1,"stats":{"Line":30},"fn_name":"uri<openapi_specification::search_secret___gotham_restful_endpoint>"},{"line":118,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[2323488,2323392,2323136,2323552,2323312,2323216,2323616],"length":1,"stats":{"Line":21},"fn_name":"handle<openapi_specification::set_image___gotham_restful_endpoint>"},{"line":148,"address":[],"length":0,"stats":{"Line":21},"fn_name":null}],"covered":14,"coverable":32},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms, unreachable_pub)]\n#![forbid(unsafe_code)]\n// deny warnings in CI\n#![cfg_attr(gotham_restful_deny_warnings, deny(warnings))]\n// clippy doesn't like our code style\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n// intra-doc links only fully work when OpenAPI is enabled\n#![cfg_attr(feature = \"openapi\", deny(rustdoc::broken_intra_doc_links))]\n#![cfg_attr(not(feature = \"openapi\"), allow(rustdoc::broken_intra_doc_links))]\n\n//! This crate is an extension to the popular [gotham web framework][gotham] for Rust. It allows you to\n//! create resources with assigned endpoints that aim to be a more convenient way of creating handlers\n//! for requests.\n//!\n//! # Features\n//!\n//!  - Automatically parse **JSON** request and produce response bodies\n//!  - Allow using **raw** request and response bodies\n//!  - Convenient **macros** to create responses that can be registered with gotham's router\n//!  - Auto-Generate an **OpenAPI** specification for your API\n//!  - Manage **CORS** headers so you don't have to\n//!  - Manage **Authentication** with JWT\n//!  - Integrate diesel connection pools for easy **database** integration\n//!\n//! # Safety\n//!\n//! This crate is just as safe as you'd expect from anything written in safe Rust - and\n//! `#![forbid(unsafe_code)]` ensures that no unsafe was used.\n//!\n//! # Endpoints\n//!\n//! There are a set of pre-defined endpoints that should cover the majority of REST APIs. However,\n//! it is also possible to define your own endpoints.\n//!\n//! ## Pre-defined Endpoints\n//!\n//! Assuming you assign `/foobar` to your resource, the following pre-defined endpoints exist:\n//!\n//! | Endpoint Name | Required Arguments | HTTP Verb | HTTP Path      |\n//! | ------------- | ------------------ | --------- | -------------- |\n//! | read_all      |                    | GET       | /foobar        |\n//! | read          | id                 | GET       | /foobar/:id    |\n//! | search        | query              | GET       | /foobar/search |\n//! | create        | body               | POST      | /foobar        |\n//! | update_all    | body               | PUT       | /foobar        |\n//! | update        | id, body           | PUT       | /foobar/:id    |\n//! | delete_all    |                    | DELETE    | /foobar        |\n//! | delete        | id                 | DELETE    | /foobar/:id    |\n//!\n//! Each of those endpoints has a macro that creates the neccessary boilerplate for the Resource. A\n//! simple example looks like this:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # use gotham::router::builder::*;\n//! # use gotham_restful::*;\n//! # use serde::{Deserialize, Serialize};\n//! /// Our RESTful resource.\n//! #[derive(Resource)]\n//! #[resource(read)]\n//! struct FooResource;\n//!\n//! /// The return type of the foo read endpoint.\n//! #[derive(Serialize)]\n//! # #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n//! struct Foo {\n//! \tid: u64\n//! }\n//!\n//! /// The foo read endpoint.\n//! #[read]\n//! fn read(id: u64) -> Success<Foo> {\n//! \tFoo { id }.into()\n//! }\n//! # fn main() {\n//! # \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n//! # \t\troute.resource::<FooResource>(\"foo\");\n//! # \t})).expect(\"Failed to start gotham\");\n//! # }\n//! ```\n//!\n//! ## Custom Endpoints\n//!\n//! Defining custom endpoints is done with the `#[endpoint]` macro. The syntax is similar to that\n//! of the pre-defined endpoints, but you need to give it more context:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # use gotham::{router::build_simple_router, prelude::*};\n//! # use gotham_restful::*;\n//! # use serde::{Deserialize, Serialize};\n//! use gotham_restful::gotham::hyper::Method;\n//!\n//! #[derive(Resource)]\n//! #[resource(custom_endpoint)]\n//! struct CustomResource;\n//!\n//! /// This type is used to parse path parameters.\n//! #[derive(Clone, Deserialize, StateData, StaticResponseExtender)]\n//! # #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n//! struct CustomPath {\n//! \tname: String\n//! }\n//!\n//! #[endpoint(\n//! \turi = \"custom/:name/read\",\n//! \tmethod = \"Method::GET\",\n//! \tparams = false,\n//! \tbody = false\n//! )]\n//! fn custom_endpoint(path: CustomPath) -> Success<String> {\n//! \tpath.name.into()\n//! }\n//! # fn main() {\n//! # \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n//! # \t\troute.resource::<CustomResource>(\"custom\");\n//! # \t})).expect(\"Failed to start gotham\");\n//! # }\n//! ```\n//!\n//! # Arguments\n//!\n//! Some endpoints require arguments. Those should be\n//!  * **id** Should be a deserializable json-primitive like [`i64`] or [`String`].\n//!  * **body** Should be any deserializable object, or any type implementing [`RequestBody`].\n//!  * **query** Should be any deserializable object whose variables are json-primitives. It will\n//!    however not be parsed from json, but from HTTP GET parameters like in `search?id=1`. The\n//!    type needs to implement [`QueryStringExtractor`](gotham::extractor::QueryStringExtractor).\n//!\n//! Additionally, all handlers may take a reference to gotham's [`State`]. Please note that for async\n//! handlers, it needs to be a mutable reference until rustc's lifetime checks across await bounds\n//! improve.\n//!\n//! # Uploads and Downloads\n//!\n//! By default, every request body is parsed from json, and every respone is converted to json using\n//! [serde_json]. However, you may also use raw bodies. This is an example where the request body\n//! is simply returned as the response again, no json parsing involved:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # use gotham::{mime::{self, Mime}, router::builder::*};\n//! # use gotham_restful::*;\n//! # use serde::{Deserialize, Serialize};\n//! #[derive(Resource)]\n//! #[resource(create)]\n//! struct ImageResource;\n//!\n//! #[derive(FromBody, RequestBody)]\n//! #[supported_types(mime::IMAGE_GIF, mime::IMAGE_JPEG, mime::IMAGE_PNG)]\n//! struct RawImage {\n//! \tcontent: Vec<u8>,\n//! \tcontent_type: Mime\n//! }\n//!\n//! #[create]\n//! fn create(body: RawImage) -> Raw<Vec<u8>> {\n//! \tRaw::new(body.content, body.content_type)\n//! }\n//! # fn main() {\n//! # \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n//! # \t\troute.resource::<ImageResource>(\"image\");\n//! # \t})).expect(\"Failed to start gotham\");\n//! # }\n//! ```\n//!\n//! # Custom HTTP Headers\n//!\n//! You can read request headers from the state as you would in any other gotham handler, and specify\n//! custom response headers using [Response::header].\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # use gotham::hyper::header::{ACCEPT, HeaderMap, VARY};\n//! # use gotham::{router::builder::*, state::State};\n//! # use gotham_restful::*;\n//! #[derive(Resource)]\n//! #[resource(read_all)]\n//! struct FooResource;\n//!\n//! #[read_all]\n//! async fn read_all(state: &mut State) -> NoContent {\n//! \tlet headers: &HeaderMap = state.borrow();\n//! \tlet accept = &headers[ACCEPT];\n//! # drop(accept);\n//!\n//! \tlet mut res = NoContent::default();\n//! \tres.header(VARY, \"accept\".parse().unwrap());\n//! \tres\n//! }\n//! # fn main() {\n//! # \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n//! # \t\troute.resource::<FooResource>(\"foo\");\n//! # \t})).expect(\"Failed to start gotham\");\n//! # }\n//! ```\n//!\n//! # Features\n//!\n//! To make life easier for common use-cases, this create offers a few features that might be helpful\n//! when you implement your web server.  The complete feature list is\n//!  - [`auth`](#authentication-feature) Advanced JWT middleware\n//!  - [`cors`](#cors-feature) CORS handling for all endpoint handlers\n//!  - [`database`](#database-feature) diesel middleware support\n//!  - `errorlog` log errors returned from endpoint handlers\n//!  - `full` enables all features except `without-openapi`\n//!  - [`openapi`](#openapi-feature) router additions to generate an openapi spec\n//!  - `without-openapi` (**default**) disables `openapi` support.\n//!\n//! ## Authentication Feature\n//!\n//! In order to enable authentication support, enable the `auth` feature gate. This allows you to\n//! register a middleware that can automatically check for the existence of an JWT authentication\n//! token. Besides being supported by the endpoint macros, it supports to lookup the required JWT secret\n//! with the JWT data, hence you can use several JWT secrets and decide on the fly which secret to use.\n//! None of this is currently supported by gotham's own JWT middleware.\n//!\n//! A simple example that uses only a single secret looks like this:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # #[cfg(feature = \"auth\")]\n//! # mod auth_feature_enabled {\n//! # use gotham::{router::builder::*, pipeline::*, state::State};\n//! # use gotham_restful::*;\n//! # use serde::{Deserialize, Serialize};\n//! #[derive(Resource)]\n//! #[resource(read)]\n//! struct SecretResource;\n//!\n//! #[derive(Serialize)]\n//! # #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n//! struct Secret {\n//! \tid: u64,\n//! \tintended_for: String\n//! }\n//!\n//! #[derive(Deserialize, Clone)]\n//! struct AuthData {\n//! \tsub: String,\n//! \texp: u64\n//! }\n//!\n//! #[read]\n//! fn read(auth: AuthStatus<AuthData>, id: u64) -> AuthSuccess<Secret> {\n//! \tlet intended_for = auth.ok()?.sub;\n//! \tOk(Secret { id, intended_for })\n//! }\n//!\n//! fn main() {\n//! \tlet auth: AuthMiddleware<AuthData, _> = AuthMiddleware::new(\n//! \t\tAuthSource::AuthorizationHeader,\n//! \t\tAuthValidation::default(),\n//! \t\tStaticAuthHandler::from_array(b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\")\n//! \t);\n//! \tlet (chain, pipelines) = single_pipeline(new_pipeline().add(auth).build());\n//! \tgotham::start(\n//! \t\t\"127.0.0.1:8080\",\n//! \t\tbuild_router(chain, pipelines, |route| {\n//! \t\t\troute.resource::<SecretResource>(\"secret\");\n//! \t\t})\n//! \t)\n//! \t.expect(\"Failed to start gotham\");\n//! }\n//! # }\n//! ```\n//!\n//! ## CORS Feature\n//!\n//! The cors feature allows an easy usage of this web server from other origins. By default, only\n//! the `Access-Control-Allow-Methods` header is touched. To change the behaviour, add your desired\n//! configuration as a middleware.\n//!\n//! A simple example that allows authentication from every origin (note that `*` always disallows\n//! authentication), and every content type, looks like this:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # #[cfg(feature = \"cors\")]\n//! # mod cors_feature_enabled {\n//! # use gotham::{hyper::header::*, router::builder::*, pipeline::*, state::State};\n//! # use gotham_restful::{*, cors::*};\n//! # use serde::{Deserialize, Serialize};\n//! #[derive(Resource)]\n//! #[resource(read_all)]\n//! struct FooResource;\n//!\n//! #[read_all]\n//! fn read_all() {\n//! \t// your handler\n//! }\n//!\n//! fn main() {\n//! \tlet cors = CorsConfig {\n//! \t\torigin: Origin::Copy,\n//! \t\theaders: Headers::List(vec![CONTENT_TYPE]),\n//! \t\tmax_age: 0,\n//! \t\tcredentials: true\n//! \t};\n//! \tlet (chain, pipelines) = single_pipeline(new_pipeline().add(cors).build());\n//! \tgotham::start(\n//! \t\t\"127.0.0.1:8080\",\n//! \t\tbuild_router(chain, pipelines, |route| {\n//! \t\t\troute.resource::<FooResource>(\"foo\");\n//! \t\t})\n//! \t)\n//! \t.expect(\"Failed to start gotham\");\n//! }\n//! # }\n//! ```\n//!\n//! The cors feature can also be used for non-resource handlers. Take a look at [`CorsRoute`]\n//! for an example.\n//!\n//! ## Database Feature\n//!\n//! The database feature allows an easy integration of [diesel] into your handler functions. Please\n//! note however that due to the way gotham's diesel middleware implementation, it is not possible\n//! to run async code while holding a database connection. If you need to combine async and database,\n//! you'll need to borrow the connection from the [`State`] yourself and return a boxed future.\n//!\n//! A simple non-async example looks like this:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate diesel;\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # #[cfg(feature = \"database\")]\n//! # mod database_feature_enabled {\n//! # use diesel::{table, PgConnection, QueryResult, RunQueryDsl};\n//! # use gotham::{router::builder::*, pipeline::*, state::State};\n//! # use gotham_middleware_diesel::DieselMiddleware;\n//! # use gotham_restful::*;\n//! # use serde::{Deserialize, Serialize};\n//! # use std::env;\n//! # table! {\n//! #   foo (id) {\n//! #     id -> Int8,\n//! #     value -> Text,\n//! #   }\n//! # }\n//! #[derive(Resource)]\n//! #[resource(read_all)]\n//! struct FooResource;\n//!\n//! #[derive(Queryable, Serialize)]\n//! # #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n//! struct Foo {\n//! \tid: i64,\n//! \tvalue: String\n//! }\n//!\n//! #[read_all]\n//! fn read_all(conn: &PgConnection) -> QueryResult<Vec<Foo>> {\n//! \tfoo::table.load(conn)\n//! }\n//!\n//! type Repo = gotham_middleware_diesel::Repo<PgConnection>;\n//!\n//! fn main() {\n//! \tlet repo = Repo::new(&env::var(\"DATABASE_URL\").unwrap());\n//! \tlet diesel = DieselMiddleware::new(repo);\n//!\n//! \tlet (chain, pipelines) = single_pipeline(new_pipeline().add(diesel).build());\n//! \tgotham::start(\n//! \t\t\"127.0.0.1:8080\",\n//! \t\tbuild_router(chain, pipelines, |route| {\n//! \t\t\troute.resource::<FooResource>(\"foo\");\n//! \t\t})\n//! \t)\n//! \t.expect(\"Failed to start gotham\");\n//! }\n//! # }\n//! ```\n//!\n//! ## OpenAPI Feature\n//!\n//! The OpenAPI feature is probably the most powerful one of this crate. Definitely read this section\n//! carefully both as a binary as well as a library author to avoid unwanted suprises.\n//!\n//! In order to automatically create an openapi specification, gotham-restful needs knowledge over\n//! all routes and the types returned. `serde` does a great job at serialization but doesn't give\n//! enough type information, so all types used in the router need to implement\n//! [`OpenapiType`](openapi_type::OpenapiType). This can be derived for almoust any type and there\n//! should be no need to implement it manually. A simple example looks like this:\n//!\n//! ```rust,no_run\n//! # #[macro_use] extern crate gotham_restful_derive;\n//! # #[cfg(feature = \"openapi\")]\n//! # mod openapi_feature_enabled {\n//! # use gotham::{router::builder::*, state::State};\n//! # use gotham_restful::*;\n//! # use openapi_type::OpenapiType;\n//! # use serde::{Deserialize, Serialize};\n//! #[derive(Resource)]\n//! #[resource(read_all)]\n//! struct FooResource;\n//!\n//! #[derive(OpenapiType, Serialize)]\n//! struct Foo {\n//! \tbar: String\n//! }\n//!\n//! #[read_all]\n//! fn read_all() -> Success<Foo> {\n//! \tFoo {\n//! \t\tbar: \"Hello World\".to_owned()\n//! \t}\n//! \t.into()\n//! }\n//!\n//! fn main() {\n//! \tgotham::start(\n//! \t\t\"127.0.0.1:8080\",\n//! \t\tbuild_simple_router(|route| {\n//! \t\t\tlet info = OpenapiInfo {\n//! \t\t\t\ttitle: \"My Foo API\".to_owned(),\n//! \t\t\t\tversion: \"0.1.0\".to_owned(),\n//! \t\t\t\turls: vec![\"https://example.org/foo/api/v1\".to_owned()]\n//! \t\t\t};\n//! \t\t\troute.with_openapi(info, |mut route| {\n//! \t\t\t\troute.resource::<FooResource>(\"foo\");\n//! \t\t\t\troute.openapi_spec(\"openapi\");\n//! \t\t\t\troute.openapi_doc(\"/\");\n//! \t\t\t});\n//! \t\t})\n//! \t)\n//! \t.expect(\"Failed to start gotham\");\n//! }\n//! # }\n//! ```\n//!\n//! Above example adds the resource as before, but adds two other endpoints as well: `/openapi` and `/`.\n//! The first one will return the generated openapi specification in JSON format, allowing you to easily\n//! generate clients in different languages without worying to exactly replicate your api in each of those\n//! languages. The second one will return documentation in HTML format, so you can easily view your\n//! api and share it with other people.\n//!\n//! ### Gotchas\n//!\n//! The openapi feature has some gotchas you should be aware of.\n//!\n//!   - The name of a struct is used as a \"link\" in the openapi specification. Therefore, if you have two\n//!     structs with the same name in your project, the openapi specification will be invalid as only one\n//!     of the two will make it into the spec.\n//!   - By default, the `without-openapi` feature of this crate is enabled. Disabling it in favour of the\n//!     `openapi` feature will add additional type bounds and method requirements to some of the traits and\n//! \ttypes in this crate, for example instead of [`Endpoint`] you now have to implement\n//! \t[`EndpointWithSchema`]. This means that some code might only compile on either feature, but not\n//!     on both. If you are writing a library that uses gotham-restful, it is strongly recommended to pass\n//! \tboth features through and conditionally enable the openapi code, like this:\n//!\n//!     ```rust\n//!     # #[macro_use] extern crate gotham_restful;\n//!     # use serde::{Deserialize, Serialize};\n//!     #[derive(Deserialize, Serialize)]\n//!     #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n//!     struct Foo;\n//!     ```\n//!\n//!  [diesel]: https://diesel.rs/\n//!  [`State`]: gotham::state::State\n\n#[cfg(all(feature = \"openapi\", feature = \"without-openapi\"))]\ncompile_error!(\"The 'openapi' and 'without-openapi' features cannot be combined\");\n\n#[cfg(all(not(feature = \"openapi\"), not(feature = \"without-openapi\")))]\ncompile_error!(\"Either the 'openapi' or 'without-openapi' feature needs to be enabled\");\n\n// weird proc macro issue\nextern crate self as gotham_restful;\n\n#[macro_use]\nextern crate gotham_restful_derive;\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate serde;\n\n#[cfg(test)]\n#[macro_use]\nextern crate pretty_assertions;\n\n#[doc(no_inline)]\npub use gotham;\n\npub use gotham_restful_derive::*;\n\n/// Not public API\n#[doc(hidden)]\npub mod private {\n\tpub use crate::routing::PathExtractor as IdPlaceholder;\n\n\tpub use futures_util::future::{BoxFuture, FutureExt};\n\n\tpub use serde_json;\n\n\t#[cfg(feature = \"database\")]\n\tpub use gotham_middleware_diesel::Repo;\n\t#[cfg(feature = \"openapi\")]\n\tpub use openapi_type::{OpenapiSchema, OpenapiType, Visitor};\n}\n\n#[cfg(feature = \"auth\")]\nmod auth;\n#[cfg(feature = \"auth\")]\npub use auth::{\n\tAuthHandler, AuthMiddleware, AuthSource, AuthStatus, AuthValidation, StaticAuthHandler\n};\n\n#[cfg(feature = \"cors\")]\npub mod cors;\n#[cfg(feature = \"cors\")]\npub use cors::{handle_cors, CorsConfig, CorsRoute};\n\n#[cfg(feature = \"openapi\")]\nmod openapi;\n#[cfg(feature = \"openapi\")]\npub use openapi::{builder::OpenapiInfo, router::GetOpenapi};\n\nmod endpoint;\n#[cfg(feature = \"openapi\")]\npub use endpoint::EndpointWithSchema;\npub use endpoint::{Endpoint, NoopExtractor};\n\nmod response;\npub use response::{\n\tAuthError, AuthErrorOrOther, AuthResult, AuthSuccess, IntoResponse, IntoResponseError,\n\tNoContent, Raw, Redirect, Response, Success\n};\n#[cfg(feature = \"openapi\")]\npub use response::{IntoResponseWithSchema, ResponseSchema};\n\nmod routing;\npub use routing::{DrawResourceRoutes, DrawResources};\n#[cfg(feature = \"openapi\")]\npub use routing::{DrawResourceRoutesWithSchema, DrawResourcesWithSchema, WithOpenapi};\n\nmod types;\npub use types::{FromBody, RequestBody, ResponseBody};\n\n/// This trait must be implemented for every resource. It allows you to register the different\n/// endpoints that can be handled by this resource to be registered with the underlying router.\n///\n/// It is not recommended to implement this yourself, just use `#[derive(Resource)]`.\n#[_private_openapi_trait(ResourceWithSchema)]\npub trait Resource {\n\t/// Register all methods handled by this resource with the underlying router.\n\t#[openapi_bound(\"D: crate::DrawResourceRoutesWithSchema\")]\n\t#[non_openapi_bound(\"D: crate::DrawResourceRoutes\")]\n\tfn setup<D>(route: D);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","builder.rs"],"content":"use openapi_type::{\n\tindexmap::IndexMap,\n\topenapiv3::{\n\t\tself, Components, OpenAPI, PathItem, ReferenceOr,\n\t\tReferenceOr::{Item, Reference},\n\t\tSchema, Server\n\t},\n\tOpenapiSchema\n};\nuse parking_lot::RwLock;\nuse std::sync::Arc;\n\n#[derive(Clone, Debug)]\npub struct OpenapiInfo {\n\tpub title: String,\n\tpub version: String,\n\tpub urls: Vec<String>\n}\n\n#[derive(Clone, Debug)]\npub(crate) struct OpenapiBuilder {\n\tpub(crate) openapi: Arc<RwLock<OpenAPI>>\n}\n\nimpl OpenapiBuilder {\n\tpub(crate) fn new(info: OpenapiInfo) -> Self {\n\t\tSelf {\n\t\t\topenapi: Arc::new(RwLock::new(OpenAPI {\n\t\t\t\topenapi: \"3.0.2\".to_string(),\n\t\t\t\tinfo: openapiv3::Info {\n\t\t\t\t\ttitle: info.title,\n\t\t\t\t\tversion: info.version,\n\t\t\t\t\t..Default::default()\n\t\t\t\t},\n\t\t\t\tservers: info\n\t\t\t\t\t.urls\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|url| Server {\n\t\t\t\t\t\turl,\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t})\n\t\t\t\t\t.collect(),\n\t\t\t\t..Default::default()\n\t\t\t}))\n\t\t}\n\t}\n\n\t/// Remove path from the OpenAPI spec, or return an empty one if not included. This is handy if you need to\n\t/// modify the path and add it back after the modification\n\tpub(crate) fn remove_path(&mut self, path: &str) -> PathItem {\n\t\tlet mut openapi = self.openapi.write();\n\t\tmatch openapi.paths.paths.swap_remove(path) {\n\t\t\tSome(Item(item)) => item,\n\t\t\t_ => PathItem::default()\n\t\t}\n\t}\n\n\tpub(crate) fn add_path<Path: ToString>(&mut self, path: Path, item: PathItem) {\n\t\tlet mut openapi = self.openapi.write();\n\t\topenapi.paths.paths.insert(path.to_string(), Item(item));\n\t}\n\n\tfn add_schema_impl(&mut self, name: String, mut schema: OpenapiSchema) {\n\t\tself.add_schema_dependencies(&mut schema.dependencies);\n\n\t\tlet mut openapi = self.openapi.write();\n\t\tmatch &mut openapi.components {\n\t\t\tSome(comp) => {\n\t\t\t\tcomp.schemas.insert(name, Item(schema.schema));\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\tlet mut comp = Components::default();\n\t\t\t\tcomp.schemas.insert(name, Item(schema.schema));\n\t\t\t\topenapi.components = Some(comp);\n\t\t\t}\n\t\t};\n\t}\n\n\tfn add_schema_dependencies(&mut self, dependencies: &mut IndexMap<String, OpenapiSchema>) {\n\t\tlet keys: Vec<String> = dependencies.keys().map(|k| k.to_string()).collect();\n\t\tfor dep in keys {\n\t\t\tlet dep_schema = dependencies.swap_remove(&dep);\n\t\t\tif let Some(dep_schema) = dep_schema {\n\t\t\t\tself.add_schema_impl(dep, dep_schema);\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(crate) fn add_schema(&mut self, mut schema: OpenapiSchema) -> ReferenceOr<Schema> {\n\t\tmatch schema.schema.schema_data.title.clone() {\n\t\t\tSome(name) => {\n\t\t\t\tlet reference = Reference {\n\t\t\t\t\treference: format!(\"#/components/schemas/{name}\")\n\t\t\t\t};\n\t\t\t\tself.add_schema_impl(name, schema);\n\t\t\t\treference\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\tself.add_schema_dependencies(&mut schema.dependencies);\n\t\t\t\tItem(schema.schema)\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[cfg(test)]\n#[allow(dead_code)]\nmod test {\n\tuse super::*;\n\tuse openapi_type::OpenapiType;\n\n\t#[derive(OpenapiType)]\n\tstruct Message {\n\t\tmsg: String\n\t}\n\n\t#[derive(OpenapiType)]\n\tstruct Messages {\n\t\tmsgs: Vec<Message>\n\t}\n\n\tfn info() -> OpenapiInfo {\n\t\tOpenapiInfo {\n\t\t\ttitle: \"TEST CASE\".to_owned(),\n\t\t\tversion: \"1.2.3\".to_owned(),\n\t\t\turls: vec![\n\t\t\t\t\"http://localhost:1234\".to_owned(),\n\t\t\t\t\"https://example.org\".to_owned(),\n\t\t\t]\n\t\t}\n\t}\n\n\tfn openapi(builder: OpenapiBuilder) -> OpenAPI {\n\t\tArc::try_unwrap(builder.openapi).unwrap().into_inner()\n\t}\n\n\t#[test]\n\tfn new_builder() {\n\t\tlet info = info();\n\t\tlet builder = OpenapiBuilder::new(info.clone());\n\t\tlet openapi = openapi(builder);\n\n\t\tassert_eq!(info.title, openapi.info.title);\n\t\tassert_eq!(info.version, openapi.info.version);\n\t\tassert_eq!(info.urls.len(), openapi.servers.len());\n\t}\n\n\t#[test]\n\tfn add_schema() {\n\t\tlet mut builder = OpenapiBuilder::new(info());\n\t\tbuilder.add_schema(<Option<Messages>>::schema());\n\t\tlet openapi = openapi(builder);\n\n\t\tassert_eq!(\n\t\t\topenapi.components.clone().unwrap_or_default().schemas[\"Message\"],\n\t\t\tReferenceOr::Item(Message::schema().schema)\n\t\t);\n\t\tassert_eq!(\n\t\t\topenapi.components.clone().unwrap_or_default().schemas[\"Messages\"],\n\t\t\tReferenceOr::Item(Messages::schema().schema)\n\t\t);\n\t}\n}\n","traces":[{"line":26,"address":[1971408,1973205],"length":1,"stats":{"Line":4},"fn_name":"new"},{"line":28,"address":[4017186,4018521,4017996],"length":1,"stats":{"Line":12},"fn_name":null},{"line":50,"address":[4019613,4019376],"length":1,"stats":{"Line":2},"fn_name":"remove_path"},{"line":51,"address":[4019446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[4019628,4019481,4019573],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[4019648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[1973921,1973854],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[1975430,1974192],"length":1,"stats":{"Line":2},"fn_name":"add_schema_impl"},{"line":64,"address":[1974256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[4020180,4020118],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[4020316,4020209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4020357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4020365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[1974521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[1974774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[1975004,1975236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[1975472,1976304],"length":1,"stats":{"Line":3},"fn_name":"add_schema_dependencies"},{"line":80,"address":[1975518,1976336,1976371],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":81,"address":[1976229,1976258,1975594],"length":1,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[1975876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[1975970,1975891],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[1976036,1976151],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[1977216,1976400],"length":1,"stats":{"Line":3},"fn_name":"add_schema"},{"line":90,"address":[1976443,1976567],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[1976596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[1976629,1976787],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[1976889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[1976994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[1976579],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[1977099],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":33,"coverable":33},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","handler","mod.rs"],"content":"#![cfg_attr(not(feature = \"auth\"), allow(unused_imports))]\nuse super::SECURITY_NAME;\nuse either::Either;\nuse futures_util::{future, future::FutureExt};\nuse gotham::{\n\tanyhow,\n\thandler::{Handler, HandlerError, HandlerFuture, NewHandler},\n\thelpers::http::response::{create_empty_response, create_response},\n\thyper::{\n\t\theader::{\n\t\t\tHeaderMap, HeaderValue, CACHE_CONTROL, CONTENT_SECURITY_POLICY, ETAG, IF_NONE_MATCH,\n\t\t\tREFERRER_POLICY, X_CONTENT_TYPE_OPTIONS\n\t\t},\n\t\tBody, Response, StatusCode\n\t},\n\tmime::{APPLICATION_JSON, TEXT_HTML_UTF_8, TEXT_PLAIN_UTF_8},\n\tstate::State\n};\nuse openapi_type::{\n\tindexmap::IndexMap,\n\topenapiv3::{APIKeyLocation, OpenAPI, ReferenceOr, SecurityScheme}\n};\nuse parking_lot::RwLock;\nuse sha2::{Digest, Sha256};\nuse std::{io::Write, iter, panic::RefUnwindSafe, pin::Pin, sync::Arc};\n\n#[cfg(feature = \"auth\")]\nfn get_security(state: &State) -> IndexMap<String, ReferenceOr<SecurityScheme>> {\n\tuse crate::AuthSource;\n\tuse gotham::state::FromState;\n\n\tlet source = match AuthSource::try_borrow_from(state) {\n\t\tSome(source) => source,\n\t\tNone => return Default::default()\n\t};\n\n\tlet security_scheme = match source {\n\t\tAuthSource::Cookie(name) => SecurityScheme::APIKey {\n\t\t\tlocation: APIKeyLocation::Cookie,\n\t\t\tname: name.to_string(),\n\t\t\tdescription: None\n\t\t},\n\t\tAuthSource::Header(name) => SecurityScheme::APIKey {\n\t\t\tlocation: APIKeyLocation::Header,\n\t\t\tname: name.to_string(),\n\t\t\tdescription: None\n\t\t},\n\t\tAuthSource::AuthorizationHeader => SecurityScheme::HTTP {\n\t\t\tscheme: \"bearer\".to_owned(),\n\t\t\tbearer_format: Some(\"JWT\".to_owned()),\n\t\t\tdescription: None\n\t\t}\n\t};\n\n\tlet mut security_schemes: IndexMap<String, ReferenceOr<SecurityScheme>> = Default::default();\n\tsecurity_schemes.insert(SECURITY_NAME.to_owned(), ReferenceOr::Item(security_scheme));\n\n\tsecurity_schemes\n}\n\n#[cfg(not(feature = \"auth\"))]\nfn get_security(_state: &State) -> IndexMap<String, ReferenceOr<SecurityScheme>> {\n\tDefault::default()\n}\n\nfn openapi_string(\n\tstate: &State,\n\topenapi: &Arc<RwLock<OpenAPI>>\n) -> Result<String, serde_json::Error> {\n\tlet openapi = openapi.read();\n\n\tlet mut openapi = openapi.clone();\n\tlet security_schemes = get_security(state);\n\tlet mut components = openapi.components.unwrap_or_default();\n\tcomponents.security_schemes = security_schemes;\n\topenapi.components = Some(components);\n\n\tserde_json::to_string(&openapi)\n}\n\nfn create_openapi_response(state: &State, openapi: &Arc<RwLock<OpenAPI>>) -> Response<Body> {\n\tmatch openapi_string(state, openapi) {\n\t\tOk(body) => {\n\t\t\tlet mut res = create_response(state, StatusCode::OK, APPLICATION_JSON, body);\n\t\t\tlet headers = res.headers_mut();\n\t\t\theaders.insert(X_CONTENT_TYPE_OPTIONS, HeaderValue::from_static(\"nosniff\"));\n\t\t\tres\n\t\t},\n\t\tErr(e) => {\n\t\t\terror!(\"Unable to handle OpenAPI request due to error: {e}\");\n\t\t\tcreate_response(\n\t\t\t\tstate,\n\t\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\t\tTEXT_PLAIN_UTF_8,\n\t\t\t\t\"\"\n\t\t\t)\n\t\t}\n\t}\n}\n\n#[derive(Clone)]\npub(crate) struct OpenapiSpecHandler {\n\topenapi: Arc<RwLock<OpenAPI>>\n}\n\n// safety: the handler only ever aquires a read lock, so this usage of\n// RwLock is, in fact, unwind safe\nimpl RefUnwindSafe for OpenapiSpecHandler {}\n\nimpl OpenapiSpecHandler {\n\tpub(crate) fn new(openapi: Arc<RwLock<OpenAPI>>) -> Self {\n\t\tSelf { openapi }\n\t}\n}\n\nimpl NewHandler for OpenapiSpecHandler {\n\ttype Instance = Self;\n\n\tfn new_handler(&self) -> anyhow::Result<Self> {\n\t\tOk(self.clone())\n\t}\n}\n\nimpl Handler for OpenapiSpecHandler {\n\tfn handle(self, mut state: State) -> Pin<Box<HandlerFuture>> {\n\t\tlet res = create_openapi_response(&mut state, &self.openapi);\n\t\tfuture::ok((state, res)).boxed()\n\t}\n}\n\n#[derive(Clone)]\npub(crate) struct OpenapiDocHandler {\n\topenapi: Arc<RwLock<OpenAPI>>\n}\n\n// safety: the handler only ever aquires a read lock, so this usage of\n// RwLock is, in fact, unwind safe\nimpl RefUnwindSafe for OpenapiDocHandler {}\n\nimpl OpenapiDocHandler {\n\tpub(crate) fn new(openapi: Arc<RwLock<OpenAPI>>) -> Self {\n\t\tSelf { openapi }\n\t}\n}\n\nimpl NewHandler for OpenapiDocHandler {\n\ttype Instance = Self;\n\n\tfn new_handler(&self) -> anyhow::Result<Self> {\n\t\tOk(self.clone())\n\t}\n}\n\nfn redoc_handler(\n\tstate: &State,\n\topenapi: &Arc<RwLock<OpenAPI>>\n) -> Result<Response<Body>, HandlerError> {\n\tlet spec = openapi_string(state, openapi)?;\n\tlet encoded_spec = spec\n\t\t.chars()\n\t\t.flat_map(|c| match c {\n\t\t\t'&' => Either::Left(\"&amp;\".chars()),\n\t\t\t'<' => Either::Left(\"&lt;\".chars()),\n\t\t\t'>' => Either::Left(\"&gt;\".chars()),\n\t\t\tc => Either::Right(iter::once(c))\n\t\t})\n\t\t.collect::<String>();\n\n\tlet script = include_str!(\"script.min.js\");\n\tlet mut script_hash = Sha256::new();\n\tscript_hash.update(&script);\n\tlet script_hash = base64::encode(script_hash.finalize());\n\n\tlet mut buf = Vec::<u8>::new();\n\twrite!(\n\t\tbuf,\n\t\tr#\"<!DOCTYPE HTML><html><head><meta charset=\"utf-8\"/><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/></head>\"#\n\t)?;\n\twrite!(\n\t\tbuf,\n\t\tr#\"<body style=\"margin:0\"><div id=\"spec\" style=\"display:none\">{}</div><div id=\"redoc\"></div><script>{}</script></body></html>\"#,\n\t\tencoded_spec, script\n\t)?;\n\n\tlet mut etag = Sha256::new();\n\tetag.update(&buf);\n\tlet etag = format!(\"\\\"{}\\\"\", base64::encode(etag.finalize()));\n\n\tif state\n\t\t.borrow::<HeaderMap>()\n\t\t.get(IF_NONE_MATCH)\n\t\t.map_or(false, |header| header.as_bytes() == etag.as_bytes())\n\t{\n\t\tlet res = create_empty_response(&state, StatusCode::NOT_MODIFIED);\n\t\treturn Ok(res);\n\t}\n\n\tlet mut res = create_response(state, StatusCode::OK, TEXT_HTML_UTF_8, buf);\n\tlet headers = res.headers_mut();\n\theaders.insert(\n\t\tCACHE_CONTROL,\n\t\tHeaderValue::from_static(\"public,max-age=2592000\")\n\t);\n\theaders.insert(\n\t\tCONTENT_SECURITY_POLICY,\n\t\tformat!(\n\t\t\t\"default-src 'none';base-uri 'none';script-src 'unsafe-inline' https://cdn.jsdelivr.net 'sha256-{script_hash}' 'strict-dynamic';style-src 'unsafe-inline' https://fonts.googleapis.com;font-src https://fonts.gstatic.com;connect-src 'self';img-src blob: data:\",\n\t\t).parse().unwrap()\n\t);\n\theaders.insert(ETAG, etag.parse().unwrap());\n\theaders.insert(REFERRER_POLICY, HeaderValue::from_static(\"no-referrer\"));\n\theaders.insert(X_CONTENT_TYPE_OPTIONS, HeaderValue::from_static(\"nosniff\"));\n\tOk(res)\n}\n\nimpl Handler for OpenapiDocHandler {\n\tfn handle(self, state: State) -> Pin<Box<HandlerFuture>> {\n\t\tmatch redoc_handler(&state, &self.openapi) {\n\t\t\tOk(res) => future::ok((state, res)).boxed(),\n\t\t\tErr(err) => future::err((state, err)).boxed()\n\t\t}\n\t}\n}\n","traces":[{"line":28,"address":[2360960,2361489],"length":1,"stats":{"Line":2},"fn_name":"get_security"},{"line":32,"address":[2360998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[2361054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[2361043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2361080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[2361137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[2361180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2361198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2361223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2361504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[2361764,2362005,2361832],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[2362017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[2362080,2363463],"length":1,"stats":{"Line":2},"fn_name":"openapi_string"},{"line":70,"address":[2362137],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[2362270,2362199],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[2362286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[2362301,2362402],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[2362566,2362795,2362418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[2362654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2362788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2364271,2363504],"length":1,"stats":{"Line":2},"fn_name":"create_openapi_response"},{"line":82,"address":[2363542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[2363571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2363604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[2364299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[2364403,2364334],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[2364507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[2363716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2364103,2363818,2363894,2363729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2364544],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":119,"address":[2364576],"length":1,"stats":{"Line":2},"fn_name":"new_handler"},{"line":120,"address":[2364585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[2364640,2364951],"length":1,"stats":{"Line":2},"fn_name":"handle"},{"line":126,"address":[2364683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[2364695,2364886,2364657],"length":1,"stats":{"Line":6},"fn_name":null},{"line":141,"address":[2364992],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":149,"address":[2365024],"length":1,"stats":{"Line":0},"fn_name":"new_handler"},{"line":150,"address":[2365033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[2369168,2365088],"length":1,"stats":{"Line":0},"fn_name":"redoc_handler"},{"line":158,"address":[2365127,2365299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[2365449,2365361,2365268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[2369184,2369211],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":162,"address":[2369452,2369259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[2369291,2369421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[2369390,2369320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[2369244,2369357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[2365479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[2365514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[2365537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[2365585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[2365743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[2365943,2365762,2366235,2365866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[2366097,2366356,2366751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2366704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2366829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2367276,2366836],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2367453,2367322,2367252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[2369472,2369504,2367445],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":194,"address":[2367669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2367744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[2367488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[2367877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[2367987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[2367914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[2368406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[2368094,2368367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[2368532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[2368716],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[2368847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[2369020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[2369584,2370207],"length":1,"stats":{"Line":0},"fn_name":"handle"},{"line":218,"address":[2369601,2370101,2369692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[2369694,2370133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[2369894,2370091],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":31,"coverable":74},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","mod.rs"],"content":"const SECURITY_NAME: &str = \"authToken\";\n\npub(crate) mod builder;\npub(crate) mod handler;\npub(crate) mod operation;\npub(crate) mod router;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","operation.rs"],"content":"use super::SECURITY_NAME;\nuse crate::{response::OrAllTypes, EndpointWithSchema, IntoResponse, RequestBody};\nuse gotham::{hyper::StatusCode, mime::Mime};\nuse openapi_type::{\n\tindexmap::IndexMap,\n\topenapiv3::{\n\t\tMediaType, Operation, Parameter, ParameterData, ParameterSchemaOrContent, ReferenceOr,\n\t\tReferenceOr::Item, RequestBody as OARequestBody, Response, Responses, Schema, SchemaKind,\n\t\tStatusCode as OAStatusCode, Type\n\t},\n\tOpenapiSchema\n};\nuse std::collections::HashMap;\n\nfn new_parameter_data(\n\tname: String,\n\trequired: bool,\n\tschema: ReferenceOr<Box<Schema>>\n) -> ParameterData {\n\tParameterData {\n\t\tname,\n\t\tdescription: None,\n\t\trequired,\n\t\tdeprecated: None,\n\t\tformat: ParameterSchemaOrContent::Schema(schema.unbox()),\n\t\texample: None,\n\t\texamples: Default::default(),\n\t\texplode: None,\n\t\textensions: Default::default()\n\t}\n}\n\n#[derive(Default)]\nstruct OperationParams {\n\tpath_params: Option<OpenapiSchema>,\n\tquery_params: Option<OpenapiSchema>\n}\n\nimpl OperationParams {\n\t// TODO shouldn't this be a custom openapi_type::Visitor\n\t// rather than this hacky code?\n\tfn add_path_params(\n\t\tpath_params: Option<OpenapiSchema>,\n\t\tparams: &mut Vec<ReferenceOr<Parameter>>\n\t) {\n\t\tlet path_params = match path_params {\n\t\t\tSome(pp) => pp.schema,\n\t\t\tNone => return\n\t\t};\n\t\tlet path_params = match path_params.schema_kind {\n\t\t\tSchemaKind::Type(Type::Object(ty)) => ty,\n\t\t\t_ => panic!(\"Path Parameters needs to be a plain struct\")\n\t\t};\n\t\tfor (name, schema) in path_params.properties {\n\t\t\tlet required = path_params.required.contains(&name);\n\t\t\tparams.push(Item(Parameter::Path {\n\t\t\t\tparameter_data: new_parameter_data(name, required, schema),\n\t\t\t\tstyle: Default::default()\n\t\t\t}))\n\t\t}\n\t}\n\n\t// TODO shouldn't this be a custom openapi_type::Visitor\n\t// rather than this hacky code?\n\tfn add_query_params(\n\t\tquery_params: Option<OpenapiSchema>,\n\t\tparams: &mut Vec<ReferenceOr<Parameter>>\n\t) {\n\t\tlet query_params = match query_params {\n\t\t\tSome(qp) => qp.schema,\n\t\t\tNone => return\n\t\t};\n\t\tlet query_params = match query_params.schema_kind {\n\t\t\tSchemaKind::Type(Type::Object(ty)) => ty,\n\t\t\t_ => panic!(\"Query Parameters needs to be a plain struct\")\n\t\t};\n\t\tfor (name, schema) in query_params.properties {\n\t\t\tlet required = query_params.required.contains(&name);\n\t\t\tparams.push(Item(Parameter::Query {\n\t\t\t\tparameter_data: new_parameter_data(name, required, schema),\n\t\t\t\tallow_reserved: false,\n\t\t\t\tstyle: Default::default(),\n\t\t\t\tallow_empty_value: None\n\t\t\t}))\n\t\t}\n\t}\n\n\tfn into_params(self) -> Vec<ReferenceOr<Parameter>> {\n\t\tlet mut params: Vec<ReferenceOr<Parameter>> = Vec::new();\n\t\tSelf::add_path_params(self.path_params, &mut params);\n\t\tSelf::add_query_params(self.query_params, &mut params);\n\t\tparams\n\t}\n}\n\npub(crate) struct OperationDescription {\n\toperation_id: Option<String>,\n\tdescription: Option<String>,\n\n\taccepted_types: Option<Vec<Mime>>,\n\tresponses: HashMap<StatusCode, ReferenceOr<Schema>>,\n\tparams: OperationParams,\n\tbody_schema: Option<ReferenceOr<Schema>>,\n\tsupported_types: Option<Vec<Mime>>,\n\trequires_auth: bool\n}\n\nimpl OperationDescription {\n\t/// Create a new operation description for the given endpoint type and schema. If the endpoint\n\t/// does not specify an operation id, the path is used to generate one.\n\tpub(crate) fn new<E: EndpointWithSchema>(\n\t\tresponses: HashMap<StatusCode, ReferenceOr<Schema>>,\n\t\tpath: &str\n\t) -> Self {\n\t\tlet operation_id = E::operation_id().or_else(|| {\n\t\t\tE::operation_verb()\n\t\t\t\t.map(|verb| format!(\"{verb}_{}\", path.replace(\"/\", \"_\").trim_start_matches('_')))\n\t\t});\n\t\tSelf {\n\t\t\toperation_id,\n\t\t\tdescription: E::description(),\n\n\t\t\taccepted_types: E::Output::accepted_types(),\n\t\t\tresponses,\n\t\t\tparams: Default::default(),\n\t\t\tbody_schema: None,\n\t\t\tsupported_types: None,\n\t\t\trequires_auth: E::wants_auth()\n\t\t}\n\t}\n\n\tpub(crate) fn set_path_params(&mut self, params: OpenapiSchema) {\n\t\tself.params.path_params = Some(params);\n\t}\n\n\tpub(crate) fn set_query_params(&mut self, params: OpenapiSchema) {\n\t\tself.params.query_params = Some(params);\n\t}\n\n\tpub(crate) fn set_body<Body: RequestBody>(&mut self, schema: ReferenceOr<Schema>) {\n\t\tself.body_schema = Some(schema);\n\t\tself.supported_types = Body::supported_types();\n\t}\n\n\tfn schema_to_content(\n\t\ttypes: Vec<Mime>,\n\t\tschema: ReferenceOr<Schema>\n\t) -> IndexMap<String, MediaType> {\n\t\tlet mut content: IndexMap<String, MediaType> = IndexMap::new();\n\t\tfor ty in types {\n\t\t\tcontent.insert(ty.to_string(), MediaType {\n\t\t\t\tschema: Some(schema.clone()),\n\t\t\t\t..Default::default()\n\t\t\t});\n\t\t}\n\t\tcontent\n\t}\n\n\tpub(crate) fn into_operation(self) -> Operation {\n\t\t// this is unfortunately neccessary to prevent rust from complaining about partially moving self\n\t\tlet (\n\t\t\toperation_id,\n\t\t\tdescription,\n\t\t\taccepted_types,\n\t\t\tresponses,\n\t\t\tparams,\n\t\t\tbody_schema,\n\t\t\tsupported_types,\n\t\t\trequires_auth\n\t\t) = (\n\t\t\tself.operation_id,\n\t\t\tself.description,\n\t\t\tself.accepted_types,\n\t\t\tself.responses,\n\t\t\tself.params,\n\t\t\tself.body_schema,\n\t\t\tself.supported_types,\n\t\t\tself.requires_auth\n\t\t);\n\n\t\tlet responses: IndexMap<OAStatusCode, ReferenceOr<Response>> = responses\n\t\t\t.into_iter()\n\t\t\t.map(|(code, schema)| {\n\t\t\t\tlet content =\n\t\t\t\t\tSelf::schema_to_content(accepted_types.clone().or_all_types(), schema);\n\t\t\t\t(\n\t\t\t\t\tOAStatusCode::Code(code.as_u16()),\n\t\t\t\t\tItem(Response {\n\t\t\t\t\t\tdescription: code\n\t\t\t\t\t\t\t.canonical_reason()\n\t\t\t\t\t\t\t.map(|d| d.to_string())\n\t\t\t\t\t\t\t.unwrap_or_default(),\n\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t})\n\t\t\t.collect();\n\n\t\tlet request_body = body_schema.map(|schema| {\n\t\t\tItem(OARequestBody {\n\t\t\t\tcontent: Self::schema_to_content(supported_types.or_all_types(), schema),\n\t\t\t\trequired: true,\n\t\t\t\t..Default::default()\n\t\t\t})\n\t\t});\n\n\t\tlet mut security = None;\n\t\tif requires_auth {\n\t\t\tlet mut sec = IndexMap::new();\n\t\t\tsec.insert(SECURITY_NAME.to_owned(), Vec::new());\n\t\t\tsecurity = Some(vec![sec]);\n\t\t}\n\n\t\tOperation {\n\t\t\ttags: Vec::new(),\n\t\t\toperation_id,\n\t\t\tdescription,\n\t\t\tparameters: params.into_params(),\n\t\t\trequest_body,\n\t\t\tresponses: Responses {\n\t\t\t\tresponses,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tdeprecated: false,\n\t\t\tsecurity,\n\t\t\t..Default::default()\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse crate::{NoContent, Raw, ResponseSchema};\n\n\t#[test]\n\tfn no_content_schema_to_content() {\n\t\tlet types = NoContent::accepted_types();\n\t\tlet schema = <NoContent as ResponseSchema>::schema(StatusCode::NO_CONTENT);\n\t\tlet content =\n\t\t\tOperationDescription::schema_to_content(types.or_all_types(), Item(schema.schema));\n\t\tassert!(content.is_empty());\n\t}\n\n\t#[test]\n\tfn raw_schema_to_content() {\n\t\tlet types = Raw::<&str>::accepted_types();\n\t\tlet schema = <Raw<&str> as ResponseSchema>::schema(StatusCode::OK);\n\t\tlet content =\n\t\t\tOperationDescription::schema_to_content(types.or_all_types(), Item(schema.schema));\n\t\tassert_eq!(content.len(), 1);\n\t\tlet json = serde_json::to_string(&content.values().nth(0).unwrap()).unwrap();\n\t\tassert_eq!(json, r#\"{\"schema\":{\"type\":\"string\",\"format\":\"binary\"}}\"#);\n\t}\n}\n","traces":[{"line":15,"address":[2321151,2320560],"length":1,"stats":{"Line":1},"fn_name":"new_parameter_data"},{"line":25,"address":[2320623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[2320713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[2320778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[2321168,2322576],"length":1,"stats":{"Line":2},"fn_name":"add_path_params"},{"line":46,"address":[2321199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2321266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[2321336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2321400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2321647,2321774,2321478,2322358,2322391],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[2322045,2321942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[2322189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[2322057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[2322174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[2322848,2324286],"length":1,"stats":{"Line":2},"fn_name":"add_query_params"},{"line":69,"address":[2322879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2322946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[2323016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[2323080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[2324101,2323327,2323158,2323454,2324068],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[2323725,2323622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2323877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[2323737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[2323854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[2323869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[2324860,2324560],"length":1,"stats":{"Line":2},"fn_name":"into_params"},{"line":89,"address":[2324585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[2324633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[2324728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[3424352,3427616,3423500,3422720,3424320,3428396,3425948,3426768,3423536,3427580,3425168,3426800,3425136,3425984],"length":1,"stats":{"Line":8},"fn_name":"new<openapi_specification::read_secret___gotham_restful_endpoint>"},{"line":115,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":132,"address":[2324896,2325053],"length":1,"stats":{"Line":1},"fn_name":"set_path_params"},{"line":133,"address":[2325030,2324950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[2325274,2325104],"length":1,"stats":{"Line":1},"fn_name":"set_query_params"},{"line":137,"address":[2325158,2325248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[2325312,2326471],"length":1,"stats":{"Line":3},"fn_name":"schema_to_content"},{"line":149,"address":[2325348],"length":1,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[2325376,2325456,2326376,2325552],"length":1,"stats":{"Line":12},"fn_name":null},{"line":151,"address":[2325746,2325934],"length":1,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[2325846,2325758],"length":1,"stats":{"Line":6},"fn_name":null},{"line":153,"address":[2325856],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[2329350,2326512],"length":1,"stats":{"Line":2},"fn_name":"into_operation"},{"line":161,"address":[2326870,2326540],"length":1,"stats":{"Line":4},"fn_name":null},{"line":162,"address":[2327117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[2327157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[2327197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[2327229],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[2327285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[2327318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[2327336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[2327376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[2326620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[2326643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[2326667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[2326691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[2326727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[2326778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[2326830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[2326860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[2327394,2327489,2327577],"length":1,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[2330720,2331876,2327481,2330763],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":185,"address":[2330823,2330905],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[2330986],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[2331239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[2331106,2331021],"length":1,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[2331904,2331926],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":193,"address":[2331136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[2331232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[2331952,2332450,2327592],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":201,"address":[2331974,2332163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[2331990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[2332151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[2327715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[2327727,2328380],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[2327804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[2327952,2327887,2327811],"length":1,"stats":{"Line":3},"fn_name":null},{"line":212,"address":[2328089,2328385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[2327774],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[2328559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[2328832],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":89,"coverable":89},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","router.rs"],"content":"use super::{\n\tbuilder::OpenapiBuilder,\n\thandler::{OpenapiDocHandler, OpenapiSpecHandler},\n\toperation::OperationDescription\n};\nuse crate::{routing::*, EndpointWithSchema, ResourceWithSchema, ResponseSchema};\nuse gotham::{\n\thyper::{Method, StatusCode},\n\tpipeline::PipelineHandleChain,\n\tprelude::*,\n\trouter::builder::{RouterBuilder, ScopeBuilder}\n};\nuse lazy_regex::regex_replace_all;\nuse openapi_type::OpenapiType;\nuse std::{collections::HashMap, panic::RefUnwindSafe};\n\n/// This trait adds the `openapi_spec` and `openapi_doc` method to an OpenAPI-aware router.\npub trait GetOpenapi {\n\t/// Register a GET route to `path` that returns the OpenAPI specification in JSON format.\n\tfn openapi_spec(&mut self, path: &str);\n\n\t/// Register a GET route to `path` that returns the OpenAPI documentation in HTML format.\n\tfn openapi_doc(&mut self, path: &str);\n}\n\n#[derive(Debug)]\npub struct OpenapiRouter<'a, D> {\n\tpub(crate) router: &'a mut D,\n\tpub(crate) scope: Option<&'a str>,\n\tpub(crate) openapi_builder: &'a mut OpenapiBuilder\n}\n\nmacro_rules! implOpenapiRouter {\n\t($implType:ident) => {\n\t\timpl<'a, 'b, C, P> OpenapiRouter<'a, $implType<'b, C, P>>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tpub fn scope<F>(&mut self, path: &str, callback: F)\n\t\t\twhere\n\t\t\t\tF: FnOnce(&mut OpenapiRouter<'_, ScopeBuilder<'_, C, P>>)\n\t\t\t{\n\t\t\t\tlet mut openapi_builder = self.openapi_builder.clone();\n\t\t\t\tlet new_scope = self\n\t\t\t\t\t.scope\n\t\t\t\t\t.map(|scope| format!(\"{scope}/{path}\").replace(\"//\", \"/\"));\n\t\t\t\tself.router.scope(path, |router| {\n\t\t\t\t\tlet mut router = OpenapiRouter {\n\t\t\t\t\t\trouter,\n\t\t\t\t\t\tscope: Some(new_scope.as_ref().map(String::as_ref).unwrap_or(path)),\n\t\t\t\t\t\topenapi_builder: &mut openapi_builder\n\t\t\t\t\t};\n\t\t\t\t\tcallback(&mut router);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, 'b, C, P> GetOpenapi for OpenapiRouter<'a, $implType<'b, C, P>>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn openapi_spec(&mut self, path: &str) {\n\t\t\t\tself.router\n\t\t\t\t\t.get(path)\n\t\t\t\t\t.to_new_handler(OpenapiSpecHandler::new(\n\t\t\t\t\t\tself.openapi_builder.openapi.clone()\n\t\t\t\t\t));\n\t\t\t}\n\n\t\t\tfn openapi_doc(&mut self, path: &str) {\n\t\t\t\tself.router\n\t\t\t\t\t.get(path)\n\t\t\t\t\t.to_new_handler(OpenapiDocHandler::new(self.openapi_builder.openapi.clone()));\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, 'b, C, P> DrawResourcesWithSchema for OpenapiRouter<'a, $implType<'b, C, P>>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn resource<R: ResourceWithSchema>(&mut self, mut path: &str) {\n\t\t\t\tif path.starts_with('/') {\n\t\t\t\t\tpath = &path[1..];\n\t\t\t\t}\n\t\t\t\tR::setup((self, path));\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, 'b, C, P> DrawResourceRoutesWithSchema\n\t\t\tfor (&mut OpenapiRouter<'a, $implType<'b, C, P>>, &str)\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn endpoint<E: EndpointWithSchema + 'static>(&mut self) {\n\t\t\t\tlet mut responses: HashMap<StatusCode, _> = HashMap::new();\n\t\t\t\tfor code in E::Output::status_codes() {\n\t\t\t\t\tresponses.insert(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\t(self.0).openapi_builder.add_schema(E::Output::schema(code))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet mut path = format!(\"{}/{}\", self.0.scope.unwrap_or_default(), self.1);\n\t\t\t\tlet mut descr = OperationDescription::new::<E>(responses, &path);\n\t\t\t\tif E::has_placeholders() {\n\t\t\t\t\tdescr.set_path_params(E::Placeholders::schema());\n\t\t\t\t}\n\t\t\t\tif E::needs_params() {\n\t\t\t\t\tdescr.set_query_params(E::Params::schema());\n\t\t\t\t}\n\t\t\t\tif E::needs_body() {\n\t\t\t\t\tlet body_schema = (self.0).openapi_builder.add_schema(E::Body::schema());\n\t\t\t\t\tdescr.set_body::<E::Body>(body_schema);\n\t\t\t\t}\n\n\t\t\t\tlet uri: &str = &E::uri();\n\t\t\t\tlet uri =\n\t\t\t\t\tregex_replace_all!(r#\"(^|/):([^/]+)(/|$)\"#, uri, |_, prefix, name, suffix| {\n\t\t\t\t\t\tformat!(\"{prefix}{{{name}}}{suffix}\")\n\t\t\t\t\t});\n\t\t\t\tif !uri.is_empty() {\n\t\t\t\t\tpath = format!(\"{path}/{uri}\");\n\t\t\t\t}\n\n\t\t\t\tlet op = descr.into_operation();\n\t\t\t\tlet mut item = (self.0).openapi_builder.remove_path(&path);\n\t\t\t\tmatch E::http_method() {\n\t\t\t\t\tMethod::GET => item.get = Some(op),\n\t\t\t\t\tMethod::PUT => item.put = Some(op),\n\t\t\t\t\tMethod::POST => item.post = Some(op),\n\t\t\t\t\tMethod::DELETE => item.delete = Some(op),\n\t\t\t\t\tMethod::OPTIONS => item.options = Some(op),\n\t\t\t\t\tMethod::HEAD => item.head = Some(op),\n\t\t\t\t\tMethod::PATCH => item.patch = Some(op),\n\t\t\t\t\tMethod::TRACE => item.trace = Some(op),\n\t\t\t\t\tmethod => {\n\t\t\t\t\t\twarn!(\"Ignoring unsupported method '{method}' in OpenAPI Specification\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t(self.0).openapi_builder.add_path(path, item);\n\n\t\t\t\t(&mut *(self.0).router, self.1).endpoint::<E>()\n\t\t\t}\n\t\t}\n\t};\n}\n\nimplOpenapiRouter!(RouterBuilder);\nimplOpenapiRouter!(ScopeBuilder);\n","traces":[{"line":40,"address":[2311248,2302892,2302576,2311564],"length":1,"stats":{"Line":2},"fn_name":"scope<(), (), openapi_supports_scope::openapi_supports_scope::{closure#0}::{closure#0}::{closure#0}>"},{"line":44,"address":[2311275,2302603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[2302662,2311334,2302644,2311316],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[2302657,2311329,2311584,2302912,2311619,2302947],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}<(), (), openapi_supports_scope::openapi_supports_scope::{closure#0}::{closure#0}::{closure#0}>"},{"line":48,"address":[2311394,2303344,2302722,2312016,2303601,2312273],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}<(), (), openapi_supports_scope::openapi_supports_scope::{closure#0}::{closure#0}::{closure#0}>"},{"line":49,"address":[2312041,2303369,2303536,2312208],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[2303379,2312051,2312145,2303473],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[2312204,2303532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[2303566,2312238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[2695648,2695804],"length":1,"stats":{"Line":2},"fn_name":"openapi_spec<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()), (gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ())>"},{"line":65,"address":[2695777,2695678],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[2695731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2695706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2696016,2696192,2695840,2696368],"length":1,"stats":{"Line":6},"fn_name":"resource<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()), (gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()), openapi_specification::CoffeeResource>"},{"line":85,"address":[2696358,2696182,2696534,2695864,2696006,2696216,2696040,2696392],"length":1,"stats":{"Line":7},"fn_name":null},{"line":86,"address":[2696293,2696117,2696469,2695941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[2695904,2696256,2696080,2696432],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[2727520,2727480,2696544,2702708,2733676,2715100,2721328,2702752,2733712,2721288,2739872,2708904,2715136,2708944],"length":1,"stats":{"Line":9},"fn_name":"endpoint<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()), (gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()), openapi_specification::custom_patch___gotham_restful_endpoint>"},{"line":99,"address":[2702781,2721357,2733741,2727549,2708973,2715165,2696573],"length":1,"stats":{"Line":9},"fn_name":null},{"line":100,"address":[2696714,2703001,2721506,2702930,2715385,2727690,2733882,2733965,2727773,2696797,2709193,2721577,2715314,2709122],"length":1,"stats":{"Line":18},"fn_name":null},{"line":101,"address":[2697095,2703295,2709487,2728071,2734263,2715679,2721871],"length":1,"stats":{"Line":9},"fn_name":null},{"line":103,"address":[2721795,2727991,2703219,2715603,2734183,2709411,2697015],"length":1,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[2703359,2709551,2721935,2728135,2697159,2734327,2715743],"length":1,"stats":{"Line":9},"fn_name":null},{"line":107,"address":[2716388,2722355,2722580,2709971,2728780,2703779,2704004,2697804,2716163,2728555,2734747,2734972,2697579,2710196],"length":1,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[2697827,2716355,2722547,2716411,2697771,2710219,2703971,2728747,2728803,2704027,2734939,2710163,2722603,2734995],"length":1,"stats":{"Line":18},"fn_name":null},{"line":109,"address":[2716477,2728869,2710277,2704093,2735061,2697885,2722661],"length":1,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[2735104,2716455,2735039,2716520,2704071,2710332,2697940,2710263,2704136,2722647,2697871,2722716,2728847,2728912],"length":1,"stats":{"Line":18},"fn_name":null},{"line":112,"address":[2697960,2704156,2710352,2728932,2735124,2716540,2722744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[2704142,2710407,2697946,2722722,2728918,2704211,2710338,2716595,2735110,2698015,2716526,2735179,2722787,2728987],"length":1,"stats":{"Line":18},"fn_name":null},{"line":115,"address":[2722819,2729019,2735211,2698047,2710439,2704243,2716627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[2716732,2722924,2710544,2698152,2704348,2729120,2735316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[2698182,2735193,2704225,2716609,2710574,2722954,2729001,2710421,2729150,2698029,2704378,2722801,2735346,2716762],"length":1,"stats":{"Line":18},"fn_name":null},{"line":121,"address":[4167584,4167280,4167407,4167295,4167599,4167711,4167538,4167842],"length":1,"stats":{"Line":71},"fn_name":"{closure#0}"},{"line":122,"address":[2745213,2745645,2743917,2746077,2743485,2744349,2744781],"length":1,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[2704687,2717570,2723263,2736154,2716958,2698491,2698990,2723762,2729459,2729958,2710770,2705186,2711382,2735542,2729346,2710883,2698378,2723150,2717071,2704574,2735655],"length":1,"stats":{"Line":23},"fn_name":null},{"line":125,"address":[2711387,2736159,2698581,2698995,2717575,2723767,2729963,2710973,2729549,2735745,2704777,2717161,2705191,2723353],"length":1,"stats":{"Line":5},"fn_name":null},{"line":128,"address":[2717666,2735661,2704693,2723858,2717077,2698497,2710889,2699086,2729465,2711478,2705282,2730054,2723269,2736250],"length":1,"stats":{"Line":18},"fn_name":null},{"line":129,"address":[2699224,2717674,2711486,2730192,2711616,2723866,2730062,2736388,2699094,2723996,2736258,2705290,2717804,2705420],"length":1,"stats":{"Line":18},"fn_name":null},{"line":130,"address":[2724076,2699304,2705500,2711696,2717884,2736468,2730272],"length":1,"stats":{"Line":9},"fn_name":null},{"line":131,"address":[2726275,2724380,2730576,2699608,2713895,2720083,2736772,2701503,2707699,2732471,2738667,2712000,2705804,2718188],"length":1,"stats":{"Line":14},"fn_name":null},{"line":132,"address":[2726047,2713667,2699844,2737008,2738439,2718424,2701275,2730812,2732243,2706040,2707471,2712236,2719855,2724616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[2730694,2701389,2736890,2713781,2738553,2724498,2707585,2712118,2718306,2726161,2732357,2699726,2719969,2705922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[2701161,2719741,2730930,2699962,2725933,2718542,2712354,2724734,2713553,2737126,2706158,2707357,2732129,2738325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[2738775,2711882,2707807,2726383,2718070,2705686,2699490,2730458,2732579,2714003,2720191,2724262,2701611,2736654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[2707243,2719627,2737244,2700080,2718660,2731048,2712472,2713439,2724852,2725819,2706276,2732015,2738211,2701047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2700822,2725594,2700286,2707018,2706482,2737986,2718866,2713214,2712678,2725058,2719402,2731254,2737450,2731790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[2731901,2712578,2737350,2738097,2706382,2707129,2719513,2724958,2725705,2731154,2718766,2700186,2700933,2713325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[2724178,2711798,2730374,2699406,2736570,2705602,2717986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[2725288,2731572,2737768,2725165,2737680,2736610,2712908,2718973,2700393,2699446,2719184,2705642,2712996,2700440,2731484,2706712,2700604,2706636,2724218,2725212,2718026,2712785,2725376,2730414,2712832,2700516,2706800,2706589,2731408,2719020,2737604,2737557,2719096,2731361,2711838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[2738924,2714152,2726532,2701760,2732728,2707956,2720340],"length":1,"stats":{"Line":9},"fn_name":null},{"line":145,"address":[2739138,2714366,2708170,2720554,2732942,2701974,2726746],"length":1,"stats":{"Line":9},"fn_name":null}],"covered":44,"coverable":51},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","auth_result.rs"],"content":"use crate::{IntoResponseError, Response};\nuse gotham::{hyper::StatusCode, mime::TEXT_PLAIN_UTF_8};\nuse gotham_restful_derive::ResourceError;\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\n\n/// This is an error type that always yields a _403 Forbidden_ response. This type\n/// is best used in combination with [`AuthSuccess`] or [`AuthResult`].\n#[derive(Clone, Debug)]\npub struct AuthError(String);\n\nimpl AuthError {\n\tpub fn new<T: Into<String>>(msg: T) -> Self {\n\t\tSelf(msg.into())\n\t}\n}\n\nimpl IntoResponseError for AuthError {\n\t// TODO why does this need to be serde_json::Error ?!?\n\ttype Err = serde_json::Error;\n\n\tfn into_response_error(self) -> Result<Response, Self::Err> {\n\t\tOk(Response::new(\n\t\t\tStatusCode::FORBIDDEN,\n\t\t\tself.0,\n\t\t\tSome(TEXT_PLAIN_UTF_8)\n\t\t))\n\t}\n\n\t#[cfg(feature = \"openapi\")]\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::FORBIDDEN]\n\t}\n\n\t#[cfg(feature = \"openapi\")]\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::FORBIDDEN);\n\t\t<super::Raw<String> as OpenapiType>::schema()\n\t}\n}\n\n/**\nThis return type can be used to wrap any type implementing [IntoResponse](crate::IntoResponse)\nthat can only be returned if the client is authenticated. Otherwise, an empty _403 Forbidden_\nresponse will be issued.\n\nUse can look something like this (assuming the `auth` feature is enabled):\n\n```rust\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"auth\")]\n# mod auth_feature_enabled {\n# use gotham::state::State;\n# use gotham_restful::*;\n# use serde::Deserialize;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n# #[derive(Clone, Deserialize)]\n# struct MyAuthData { exp : u64 }\n#\n#[read_all]\nfn read_all(auth : AuthStatus<MyAuthData>) -> AuthSuccess<NoContent> {\n\tlet auth_data = auth.ok()?;\n\t// do something\n\tOk(NoContent::default())\n}\n# }\n```\n*/\npub type AuthSuccess<T> = Result<T, AuthError>;\n\n/// This is an error type that either yields a _403 Forbidden_ response if produced\n/// from an authentication error, or delegates to another error type. This type is\n/// best used with [`AuthResult`].\n#[derive(Debug, Clone, ResourceError)]\npub enum AuthErrorOrOther<E> {\n\tForbidden(#[from] AuthError),\n\n\t#[status(INTERNAL_SERVER_ERROR)]\n\t#[display(\"{0}\")]\n\tOther(E)\n}\n\nmod private {\n\tuse gotham::handler::HandlerError;\n\tpub trait Sealed {}\n\timpl<E: Into<HandlerError>> Sealed for E {}\n}\n\nimpl<E, F> From<F> for AuthErrorOrOther<E>\nwhere\n\t// TODO https://github.com/msrd0/gotham_restful/issues/20\n\tF: private::Sealed + Into<E>\n{\n\tfn from(err: F) -> Self {\n\t\tSelf::Other(err.into())\n\t}\n}\n\n/**\nThis return type can be used to wrap any type implementing [IntoResponse](crate::IntoResponse)\nthat can only be returned if the client is authenticated. Otherwise, an empty _403 Forbidden_\nresponse will be issued.\n\nUse can look something like this (assuming the `auth` feature is enabled):\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"auth\")]\n# mod auth_feature_enabled {\n# use gotham::state::State;\n# use gotham_restful::*;\n# use serde::Deserialize;\n# use std::io;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n# #[derive(Clone, Deserialize)]\n# struct MyAuthData { exp : u64 }\n#\n#[read_all]\nfn read_all(auth : AuthStatus<MyAuthData>) -> AuthResult<NoContent, io::Error> {\n\tlet auth_data = auth.ok()?;\n\t// do something\n\tOk(NoContent::default().into())\n}\n# }\n*/\npub type AuthResult<T, E> = Result<T, AuthErrorOrOther<E>>;\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[3402512],"length":1,"stats":{"Line":0},"fn_name":"into_response_error"},{"line":23,"address":[1978749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[3402529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[2087812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[1978832],"length":1,"stats":{"Line":1},"fn_name":"status_codes"},{"line":32,"address":[2087933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[1978912],"length":1,"stats":{"Line":1},"fn_name":"schema"},{"line":38,"address":[1979019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":12},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","mod.rs"],"content":"use futures_util::future::{self, BoxFuture, FutureExt};\nuse gotham::{\n\thandler::HandlerError,\n\thyper::{\n\t\theader::{HeaderMap, HeaderName, HeaderValue},\n\t\tBody, StatusCode\n\t},\n\tmime::{Mime, APPLICATION_JSON, STAR_STAR}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\nuse serde::Serialize;\nuse std::{\n\tconvert::Infallible,\n\tfmt::{Debug, Display},\n\tfuture::Future,\n\tpin::Pin\n};\n\nmod auth_result;\n#[allow(unreachable_pub)]\npub use auth_result::{AuthError, AuthErrorOrOther, AuthResult, AuthSuccess};\n\nmod no_content;\n#[allow(unreachable_pub)]\npub use no_content::NoContent;\n\nmod raw;\n#[allow(unreachable_pub)]\npub use raw::Raw;\n\nmod redirect;\n#[allow(unreachable_pub)]\npub use redirect::Redirect;\n\nmod result;\n#[allow(unreachable_pub)]\npub use result::IntoResponseError;\n\nmod success;\n#[allow(unreachable_pub)]\npub use success::Success;\n\npub(crate) trait OrAllTypes {\n\tfn or_all_types(self) -> Vec<Mime>;\n}\n\nimpl OrAllTypes for Option<Vec<Mime>> {\n\tfn or_all_types(self) -> Vec<Mime> {\n\t\tself.unwrap_or_else(|| vec![STAR_STAR])\n\t}\n}\n\n/// A response, used to create the final gotham response from.\n///\n/// This type is not meant to be used as the return type of endpoint handlers. While it can be\n/// freely used without the `openapi` feature, it is more complicated to use when you enable it,\n/// since this type does not store any schema information. You can attach schema information\n/// like so:\n///\n/// ```rust\n/// # #[cfg(feature = \"openapi\")] mod example {\n/// # use gotham::hyper::StatusCode;\n/// # use gotham_restful::*;\n/// # use openapi_type::*;\n/// fn schema(code: StatusCode) -> OpenapiSchema {\n/// \tassert_eq!(code, StatusCode::ACCEPTED);\n/// \t<()>::schema()\n/// }\n///\n/// fn status_codes() -> Vec<StatusCode> {\n/// \tvec![StatusCode::ACCEPTED]\n/// }\n///\n/// #[create(schema = \"schema\", status_codes = \"status_codes\")]\n/// fn create(body: Raw<Vec<u8>>) {}\n/// # }\n/// ```\n#[derive(Debug)]\npub struct Response {\n\tpub(crate) status: StatusCode,\n\tpub(crate) body: Body,\n\tpub(crate) mime: Option<Mime>,\n\tpub(crate) headers: HeaderMap\n}\n\nimpl Response {\n\t/// Create a new [Response] from raw data.\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn new<B: Into<Body>>(status: StatusCode, body: B, mime: Option<Mime>) -> Self {\n\t\tSelf {\n\t\t\tstatus,\n\t\t\tbody: body.into(),\n\t\t\tmime,\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Create a [Response] with mime type json from already serialized data.\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn json<B: Into<Body>>(status: StatusCode, body: B) -> Self {\n\t\tSelf {\n\t\t\tstatus,\n\t\t\tbody: body.into(),\n\t\t\tmime: Some(APPLICATION_JSON),\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Create a _204 No Content_ [Response].\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn no_content() -> Self {\n\t\tSelf {\n\t\t\tstatus: StatusCode::NO_CONTENT,\n\t\t\tbody: Body::empty(),\n\t\t\tmime: None,\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Create an empty _403 Forbidden_ [Response].\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn forbidden() -> Self {\n\t\tSelf {\n\t\t\tstatus: StatusCode::FORBIDDEN,\n\t\t\tbody: Body::empty(),\n\t\t\tmime: None,\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Return the status code of this [Response].\n\tpub fn status(&self) -> StatusCode {\n\t\tself.status\n\t}\n\n\t/// Return the mime type of this [Response].\n\tpub fn mime(&self) -> Option<&Mime> {\n\t\tself.mime.as_ref()\n\t}\n\n\t/// Add an HTTP header to the [Response].\n\tpub fn header(&mut self, name: HeaderName, value: HeaderValue) {\n\t\tself.headers.insert(name, value);\n\t}\n\n\tpub(crate) fn with_headers(mut self, headers: HeaderMap) -> Self {\n\t\tself.headers = headers;\n\t\tself\n\t}\n\n\t#[cfg(test)]\n\tpub(crate) fn full_body(\n\t\tmut self\n\t) -> Result<Vec<u8>, <Body as gotham::hyper::body::HttpBody>::Error> {\n\t\tuse futures_executor::block_on;\n\t\tuse gotham::hyper::body::to_bytes;\n\n\t\tlet bytes: &[u8] = &block_on(to_bytes(&mut self.body))?;\n\t\tOk(bytes.to_vec())\n\t}\n}\n\nimpl IntoResponse for Response {\n\ttype Err = Infallible;\n\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>> {\n\t\tfuture::ok(self).boxed()\n\t}\n}\n\n/// This trait needs to be implemented by every type returned from an endpoint to\n/// to provide the response.\npub trait IntoResponse {\n\ttype Err: Into<HandlerError> + Send + Sync + 'static;\n\n\t/// Turn this into a response that can be returned to the browser. This api will likely\n\t/// change in the future.\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>>;\n\n\t/// Return a list of supported mime types.\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tNone\n\t}\n}\n\n/// Additional details for [IntoResponse] to be used with an OpenAPI-aware router.\n#[cfg(feature = \"openapi\")]\npub trait ResponseSchema {\n\t/// All status codes returned by this response. Returns `[StatusCode::OK]` by default.\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::OK]\n\t}\n\n\t/// Return the schema of the response for the given status code. The code may\n\t/// only be one that was previously returned by [Self::status_codes]. The\n\t/// implementation should panic if that is not the case.\n\tfn schema(code: StatusCode) -> OpenapiSchema;\n}\n\n#[cfg(feature = \"openapi\")]\nmod private {\n\tpub trait Sealed {}\n}\n\n/// A trait provided to convert a resource's result to json, and provide an OpenAPI schema to the\n/// router. This trait is implemented for all types that implement [IntoResponse] and\n/// [ResponseSchema].\n#[cfg(feature = \"openapi\")]\npub trait IntoResponseWithSchema: IntoResponse + ResponseSchema + private::Sealed {}\n\n#[cfg(feature = \"openapi\")]\nimpl<R: IntoResponse + ResponseSchema> private::Sealed for R {}\n\n#[cfg(feature = \"openapi\")]\nimpl<R: IntoResponse + ResponseSchema> IntoResponseWithSchema for R {}\n\n/// The default json returned on an 500 Internal Server Error.\n#[derive(Debug, Serialize)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\npub(crate) struct ResourceError {\n\t/// This is always `true` and can be used to detect an error response without looking at the\n\t/// HTTP status code.\n\terror: bool,\n\t/// The error message.\n\tmessage: String\n}\n\nimpl<T: ToString> From<T> for ResourceError {\n\tfn from(message: T) -> Self {\n\t\tSelf {\n\t\t\terror: true,\n\t\t\tmessage: message.to_string()\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"errorlog\")]\nfn errorlog<E: Display>(e: E) {\n\terror!(\"The handler encountered an error: {e}\");\n}\n\n#[cfg(not(feature = \"errorlog\"))]\nfn errorlog<E>(_e: E) {}\n\nfn handle_error<E>(e: E) -> Pin<Box<dyn Future<Output = Result<Response, E::Err>> + Send>>\nwhere\n\tE: Debug + IntoResponseError\n{\n\tlet msg = format!(\"{e:?}\");\n\tlet res = e.into_response_error();\n\tmatch &res {\n\t\tOk(res) if res.status.is_server_error() => errorlog(msg),\n\t\tErr(err) => {\n\t\t\terrorlog(msg);\n\t\t\terrorlog(format!(\"{err:?}\"));\n\t\t},\n\t\t_ => {}\n\t};\n\tfuture::ready(res).boxed()\n}\n\nimpl<Res> IntoResponse for Pin<Box<dyn Future<Output = Res> + Send>>\nwhere\n\tRes: IntoResponse + 'static\n{\n\ttype Err = Res::Err;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, Self::Err>> + Send>> {\n\t\tself.then(IntoResponse::into_response).boxed()\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tRes::accepted_types()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<Res> ResponseSchema for Pin<Box<dyn Future<Output = Res> + Send>>\nwhere\n\tRes: ResponseSchema\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tRes::status_codes()\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tRes::schema(code)\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Deserialize, Serialize)]\n\t#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n\tstruct Msg {\n\t\tmsg: String\n\t}\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn result_from_future() {\n\t\tlet nc = NoContent::default();\n\t\tlet res = block_on(nc.into_response()).unwrap();\n\n\t\tlet fut_nc = async move { NoContent::default() }.boxed();\n\t\tlet fut_res = block_on(fut_nc.into_response()).unwrap();\n\n\t\tassert_eq!(res.status, fut_res.status);\n\t\tassert_eq!(res.mime, fut_res.mime);\n\t\tassert_eq!(res.full_body().unwrap(), fut_res.full_body().unwrap());\n\t}\n}\n","traces":[{"line":49,"address":[2038960],"length":1,"stats":{"Line":3},"fn_name":"or_all_types"},{"line":50,"address":[2038972],"length":1,"stats":{"Line":9},"fn_name":null},{"line":90,"address":[2105069,2104688,2103824,2104218,2104651,2104256],"length":1,"stats":{"Line":7},"fn_name":"new<&str>"},{"line":93,"address":[2104309,2104741,2103915],"length":1,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[2104859,2104435,2104008],"length":1,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[2105104,2105423],"length":1,"stats":{"Line":2},"fn_name":"json<alloc::string::String>"},{"line":104,"address":[2105136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[2105178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[2105262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[2105637,2105440],"length":1,"stats":{"Line":3},"fn_name":"no_content"},{"line":115,"address":[2105457],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[2105476],"length":1,"stats":{"Line":3},"fn_name":null},{"line":123,"address":[2105861,2105664],"length":1,"stats":{"Line":0},"fn_name":"forbidden"},{"line":126,"address":[2105681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[2105700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[2105888],"length":1,"stats":{"Line":1},"fn_name":"status"},{"line":134,"address":[2105893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[2105904],"length":1,"stats":{"Line":1},"fn_name":"mime"},{"line":139,"address":[2105913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[2105952],"length":1,"stats":{"Line":1},"fn_name":"header"},{"line":144,"address":[2105972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[2106064,2106286],"length":1,"stats":{"Line":3},"fn_name":"with_headers"},{"line":148,"address":[2106230,2106094],"length":1,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[2106202],"length":1,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[2106304,2106763],"length":1,"stats":{"Line":1},"fn_name":"full_body"},{"line":159,"address":[2106408,2106334,2106634,2106549,2106599],"length":1,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[2106679,2106615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[2106784],"length":1,"stats":{"Line":0},"fn_name":"into_response"},{"line":168,"address":[2106794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[1893328],"length":1,"stats":{"Line":7},"fn_name":"accepted_types<gotham_restful::response::raw::Raw<&str>>"},{"line":183,"address":[1893331],"length":1,"stats":{"Line":7},"fn_name":null},{"line":191,"address":[1893344],"length":1,"stats":{"Line":4},"fn_name":"status_codes<gotham_restful::response::raw::Raw<alloc::string::String>>"},{"line":192,"address":[1893357],"length":1,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[2107009,2106896],"length":1,"stats":{"Line":2},"fn_name":"from<anyhow::Error>"},{"line":233,"address":[2106925],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[2107416,2107040],"length":1,"stats":{"Line":1},"fn_name":"errorlog<alloc::string::String>"},{"line":240,"address":[2107052,2107205,2107132,2107269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[2107440,2109426,2109456,2108448,2108418,2110434,2110464,2111442],"length":1,"stats":{"Line":1},"fn_name":"handle_error<gotham_restful::response::no_content::test::MsgError>"},{"line":250,"address":[2108646,2110662,2107484,2109654,2107638,2109500,2108492,2110508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[2110714,2109706,2107690,2108698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[2109737,2108729,2107721,2110745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[2110252,2110889,2109881,2107865,2108236,2111260,2109244,2108873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[2110950,2108934,2109942,2107926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[2108950,2110966,2109958,2107942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[2109007,2110015,2111023,2108098,2110114,2111122,2107999,2109106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[2109815,2107799,2110823,2108807,2109315,2108307,2110323,2107447,2108455,2109463,2110471,2111331],"length":1,"stats":{"Line":3},"fn_name":null},{"line":269,"address":[2155168],"length":1,"stats":{"Line":1},"fn_name":"into_response<gotham_restful::response::no_content::NoContent>"},{"line":270,"address":[2155188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":40,"coverable":55},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","no_content.rs"],"content":"use super::{handle_error, IntoResponse};\n#[cfg(feature = \"openapi\")]\nuse crate::ResponseSchema;\nuse crate::{IntoResponseError, Response};\nuse futures_util::{future, future::FutureExt};\n#[cfg(feature = \"openapi\")]\nuse gotham::hyper::StatusCode;\nuse gotham::{\n\thyper::header::{HeaderMap, HeaderValue, IntoHeaderName},\n\tmime::Mime\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\nuse std::{fmt::Debug, future::Future, pin::Pin};\n\n/**\nThis is the return type of a resource that doesn't actually return something. It will result\nin a _204 No Content_ answer by default. You don't need to use this type directly if using\nthe function attributes:\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# mod doc_tests_are_broken {\n# use gotham::state::State;\n# use gotham_restful::*;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n#[read_all]\nfn read_all() {\n\t// do something\n}\n# }\n```\n*/\n#[derive(Clone, Debug, Default)]\npub struct NoContent {\n\theaders: HeaderMap\n}\n\nimpl From<()> for NoContent {\n\tfn from(_: ()) -> Self {\n\t\tSelf::default()\n\t}\n}\n\nimpl NoContent {\n\t/// Set a custom HTTP header. If a header with this name was set before, its value is being updated.\n\tpub fn header<K: IntoHeaderName>(&mut self, name: K, value: HeaderValue) {\n\t\tself.headers.insert(name, value);\n\t}\n\n\t/// Allow manipulating HTTP headers.\n\tpub fn headers_mut(&mut self) -> &mut HeaderMap {\n\t\t&mut self.headers\n\t}\n}\n\nimpl IntoResponse for NoContent {\n\t// TODO this shouldn't be a serde_json::Error\n\ttype Err = serde_json::Error; // just for easier handling of `Result<NoContent, E>`\n\n\t/// This will always be a _204 No Content_ together with an empty string.\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, Self::Err>> + Send>> {\n\t\tfuture::ok(Response::no_content().with_headers(self.headers)).boxed()\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tSome(Vec::new())\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl ResponseSchema for NoContent {\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::NO_CONTENT]\n\t}\n\n\t/// Returns the schema of the `()` type.\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::NO_CONTENT);\n\t\t<()>::schema()\n\t}\n}\n\nimpl<E> IntoResponse for Result<NoContent, E>\nwhere\n\tE: Debug + IntoResponseError<Err = serde_json::Error>\n{\n\ttype Err = serde_json::Error;\n\n\tfn into_response(\n\t\tself\n\t) -> Pin<Box<dyn Future<Output = Result<Response, serde_json::Error>> + Send>> {\n\t\tmatch self {\n\t\t\tOk(nc) => nc.into_response(),\n\t\t\tErr(e) => handle_error(e)\n\t\t}\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tNoContent::accepted_types()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<E> ResponseSchema for Result<NoContent, E>\nwhere\n\tE: Debug + IntoResponseError<Err = serde_json::Error>\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::NO_CONTENT);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::NO_CONTENT => <NoContent as ResponseSchema>::schema(StatusCode::NO_CONTENT),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse gotham::hyper::{header::ACCESS_CONTROL_ALLOW_ORIGIN, StatusCode};\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn no_content_has_empty_response() {\n\t\tlet no_content = NoContent::default();\n\t\tlet res = block_on(no_content.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::NO_CONTENT);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(NoContent::status_codes(), vec![StatusCode::NO_CONTENT]);\n\t}\n\n\t#[test]\n\tfn no_content_result() {\n\t\tlet no_content: Result<NoContent, MsgError> = Ok(NoContent::default());\n\t\tlet res = block_on(no_content.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::NO_CONTENT);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Result<NoContent, MsgError>>::status_codes(), vec![\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tStatusCode::NO_CONTENT\n\t\t]);\n\t}\n\n\t#[test]\n\tfn no_content_custom_headers() {\n\t\tlet mut no_content = NoContent::default();\n\t\tno_content.header(ACCESS_CONTROL_ALLOW_ORIGIN, HeaderValue::from_static(\"*\"));\n\t\tlet res = block_on(no_content.into_response()).expect(\"didn't expect error response\");\n\t\tlet cors = res.headers.get(ACCESS_CONTROL_ALLOW_ORIGIN);\n\t\tassert_eq!(cors.map(|value| value.to_str().unwrap()), Some(\"*\"));\n\t}\n}\n","traces":[{"line":44,"address":[4053184],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":45,"address":[4053196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4053216],"length":1,"stats":{"Line":0},"fn_name":"headers_mut"},{"line":66,"address":[2411404,2411152],"length":1,"stats":{"Line":2},"fn_name":"into_response"},{"line":67,"address":[4053432,4053244],"length":1,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[4053536],"length":1,"stats":{"Line":4},"fn_name":"accepted_types"},{"line":71,"address":[4053549],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[2411504],"length":1,"stats":{"Line":2},"fn_name":"status_codes"},{"line":78,"address":[2411517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[4053680],"length":1,"stats":{"Line":2},"fn_name":"schema"},{"line":84,"address":[4053784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[2100640],"length":1,"stats":{"Line":1},"fn_name":"into_response<gotham_restful::response::no_content::test::MsgError>"},{"line":97,"address":[2100652,2100757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[2100742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[2100817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[2100832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":27},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","raw.rs"],"content":"use super::{handle_error, IntoResponse, IntoResponseError};\nuse crate::{types::ResourceType, FromBody, RequestBody, Response};\n#[cfg(feature = \"openapi\")]\nuse crate::{IntoResponseWithSchema, ResponseSchema};\nuse futures_core::future::Future;\nuse futures_util::{future, future::FutureExt};\nuse gotham::{\n\thyper::{\n\t\tbody::{Body, Bytes},\n\t\tStatusCode\n\t},\n\tmime::Mime\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType, Visitor};\nuse serde_json::error::Error as SerdeJsonError;\nuse std::{convert::Infallible, fmt::Debug, pin::Pin};\n\n/**\nThis type can be used both as a raw request body, as well as as a raw response. However, all types\nof request bodies are accepted by this type. It is therefore recommended to derive your own type\nfrom [RequestBody] and only use this when you need to return a raw response. This is a usage\nexample that simply returns its body:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::router::builder::*;\n# use gotham_restful::*;\n#[derive(Resource)]\n#[resource(create)]\nstruct ImageResource;\n\n#[create]\nfn create(body : Raw<Vec<u8>>) -> Raw<Vec<u8>> {\n\tbody\n}\n# fn main() {\n# \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n# \t\troute.resource::<ImageResource>(\"img\");\n# \t}));\n# }\n```\n*/\n#[derive(Debug)]\npub struct Raw<T> {\n\tpub raw: T,\n\tpub mime: Mime\n}\n\nimpl<T> Raw<T> {\n\tpub fn new(raw: T, mime: Mime) -> Self {\n\t\tSelf { raw, mime }\n\t}\n}\n\nimpl<T, U> AsMut<U> for Raw<T>\nwhere\n\tT: AsMut<U>\n{\n\tfn as_mut(&mut self) -> &mut U {\n\t\tself.raw.as_mut()\n\t}\n}\n\nimpl<T, U> AsRef<U> for Raw<T>\nwhere\n\tT: AsRef<U>\n{\n\tfn as_ref(&self) -> &U {\n\t\tself.raw.as_ref()\n\t}\n}\n\nimpl<T: Clone> Clone for Raw<T> {\n\tfn clone(&self) -> Self {\n\t\tSelf {\n\t\t\traw: self.raw.clone(),\n\t\t\tmime: self.mime.clone()\n\t\t}\n\t}\n}\n\nimpl<T: for<'a> From<&'a [u8]>> FromBody for Raw<T> {\n\ttype Err = Infallible;\n\n\tfn from_body(body: Bytes, mime: Mime) -> Result<Self, Self::Err> {\n\t\tOk(Self::new(body.as_ref().into(), mime))\n\t}\n}\n\nimpl<T> RequestBody for Raw<T> where Raw<T>: FromBody + ResourceType {}\n\n#[cfg(feature = \"openapi\")]\nimpl<T> OpenapiType for Raw<T> {\n\tfn visit_type<V: Visitor>(visitor: &mut V) {\n\t\tvisitor.visit_binary()\n\t}\n}\n\nimpl<T: Into<Body>> IntoResponse for Raw<T>\nwhere\n\tSelf: Send\n{\n\ttype Err = SerdeJsonError; // just for easier handling of `Result<Raw<T>, E>`\n\n\tfn into_response(\n\t\tself\n\t) -> Pin<Box<dyn Future<Output = Result<Response, SerdeJsonError>> + Send>> {\n\t\tfuture::ok(Response::new(StatusCode::OK, self.raw, Some(self.mime))).boxed()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<T: Into<Body>> ResponseSchema for Raw<T>\nwhere\n\tSelf: Send\n{\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::OK);\n\t\t<Self as OpenapiType>::schema()\n\t}\n}\n\nimpl<T, E> IntoResponse for Result<Raw<T>, E>\nwhere\n\tRaw<T>: IntoResponse,\n\tE: Debug + IntoResponseError<Err = <Raw<T> as IntoResponse>::Err>\n{\n\ttype Err = E::Err;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, E::Err>> + Send>> {\n\t\tmatch self {\n\t\t\tOk(raw) => raw.into_response(),\n\t\t\tErr(e) => handle_error(e)\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<T, E> ResponseSchema for Result<Raw<T>, E>\nwhere\n\tRaw<T>: IntoResponseWithSchema,\n\tE: Debug + IntoResponseError<Err = <Raw<T> as IntoResponse>::Err>\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::OK);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::OK => <Raw<T> as ResponseSchema>::schema(StatusCode::OK),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse gotham::mime::TEXT_PLAIN;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn raw_response() {\n\t\tlet msg = \"Test\";\n\t\tlet raw = Raw::new(msg, TEXT_PLAIN);\n\t\tlet res = block_on(raw.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(TEXT_PLAIN));\n\t\tassert_eq!(res.full_body().unwrap(), msg.as_bytes());\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Raw<String>>::status_codes(), vec![StatusCode::OK]);\n\t}\n\n\t#[test]\n\tfn raw_result() {\n\t\tlet msg = \"Test\";\n\t\tlet raw: Result<Raw<_>, MsgError> = Ok(Raw::new(msg, TEXT_PLAIN));\n\t\tlet res = block_on(raw.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(TEXT_PLAIN));\n\t\tassert_eq!(res.full_body().unwrap(), msg.as_bytes());\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Result<Raw<String>, MsgError>>::status_codes(), vec![\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tStatusCode::OK\n\t\t]);\n\t}\n}\n","traces":[{"line":51,"address":[2290784],"length":1,"stats":{"Line":6},"fn_name":"new<&[u8]>"},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[3436992],"length":1,"stats":{"Line":4},"fn_name":"visit_type<&[u8], openapi_type::visitor::openapi::OpenapiVisitor>"},{"line":96,"address":[4165173],"length":1,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[1892048],"length":1,"stats":{"Line":5},"fn_name":"into_response<&str>"},{"line":109,"address":[1892058],"length":1,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[1892224],"length":1,"stats":{"Line":3},"fn_name":"schema<&str>"},{"line":120,"address":[3437288],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2102240],"length":1,"stats":{"Line":1},"fn_name":"into_response<&str, gotham_restful::response::raw::test::MsgError>"},{"line":132,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2102400,2102477],"length":1,"stats":{"Line":1},"fn_name":"status_codes<alloc::string::String, gotham_restful::response::raw::test::MsgError>"},{"line":146,"address":[2102417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[2102432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":15,"coverable":28},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","redirect.rs"],"content":"use super::{handle_error, IntoResponse};\nuse crate::{IntoResponseError, Response};\n#[cfg(feature = \"openapi\")]\nuse crate::{NoContent, ResponseSchema};\nuse futures_util::future::{BoxFuture, FutureExt, TryFutureExt};\nuse gotham::hyper::{\n\theader::{InvalidHeaderValue, LOCATION},\n\tBody, StatusCode\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiSchema;\nuse std::{error::Error as StdError, fmt::Debug};\nuse thiserror::Error;\n\n/**\nThis is the return type of a resource that only returns a redirect. It will result\nin a _303 See Other_ answer, meaning the redirect will always result in a GET request\non the target.\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# mod doc_tests_are_broken {\n# use gotham::state::State;\n# use gotham_restful::*;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n#[read_all]\nfn read_all() -> Redirect {\n\tRedirect {\n\t\tto: \"http://localhost:8080/cool/new/location\".to_owned()\n\t}\n}\n# }\n```\n*/\n#[derive(Clone, Debug, Default)]\npub struct Redirect {\n\tpub to: String\n}\n\nimpl IntoResponse for Redirect {\n\ttype Err = InvalidHeaderValue;\n\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>> {\n\t\tasync move {\n\t\t\tlet mut res = Response::new(StatusCode::SEE_OTHER, Body::empty(), None);\n\t\t\tres.header(LOCATION, self.to.parse()?);\n\t\t\tOk(res)\n\t\t}\n\t\t.boxed()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl ResponseSchema for Redirect {\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::SEE_OTHER]\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::SEE_OTHER);\n\t\t<NoContent as ResponseSchema>::schema(StatusCode::NO_CONTENT)\n\t}\n}\n\n// private type due to parent mod\n#[derive(Debug, Error)]\npub enum RedirectError<E: StdError + 'static> {\n\t#[error(\"{0}\")]\n\tInvalidLocation(#[from] InvalidHeaderValue),\n\t#[error(\"{0}\")]\n\tOther(#[source] E)\n}\n\n#[allow(ambiguous_associated_items)] // an enum variant is not a type. never.\nimpl<E> IntoResponse for Result<Redirect, E>\nwhere\n\tE: Debug + IntoResponseError,\n\t<E as IntoResponseError>::Err: StdError + Sync\n{\n\ttype Err = RedirectError<<E as IntoResponseError>::Err>;\n\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>> {\n\t\tmatch self {\n\t\t\tOk(nc) => nc.into_response().map_err(Into::into).boxed(),\n\t\t\tErr(e) => handle_error(e).map_err(RedirectError::Other).boxed()\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<E> ResponseSchema for Result<Redirect, E>\nwhere\n\tE: Debug + IntoResponseError,\n\t<E as IntoResponseError>::Err: StdError + Sync\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::SEE_OTHER);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::SEE_OTHER => <Redirect as ResponseSchema>::schema(StatusCode::SEE_OTHER),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse gotham::hyper::StatusCode;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn redirect_response() {\n\t\tlet redir = Redirect {\n\t\t\tto: \"http://localhost/foo\".to_owned()\n\t\t};\n\t\tlet res = block_on(redir.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::SEE_OTHER);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(\n\t\t\tres.headers.get(LOCATION).map(|hdr| hdr.to_str().unwrap()),\n\t\t\tSome(\"http://localhost/foo\")\n\t\t);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(Redirect::status_codes(), vec![StatusCode::SEE_OTHER]);\n\t}\n\n\t#[test]\n\tfn redirect_result() {\n\t\tlet redir: Result<Redirect, MsgError> = Ok(Redirect {\n\t\t\tto: \"http://localhost/foo\".to_owned()\n\t\t});\n\t\tlet res = block_on(redir.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::SEE_OTHER);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(\n\t\t\tres.headers.get(LOCATION).map(|hdr| hdr.to_str().unwrap()),\n\t\t\tSome(\"http://localhost/foo\")\n\t\t);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Result<Redirect, MsgError>>::status_codes(), vec![\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tStatusCode::SEE_OTHER\n\t\t]);\n\t}\n}\n","traces":[{"line":47,"address":[2001168],"length":1,"stats":{"Line":1},"fn_name":"into_response"},{"line":48,"address":[3196107,3196064,3195972,3196164,3196775],"length":1,"stats":{"Line":3},"fn_name":"{generator#0}"},{"line":49,"address":[3884046,3883965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[3355626,3355978,3355707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[3356152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[3884720],"length":1,"stats":{"Line":1},"fn_name":"status_codes"},{"line":60,"address":[3356221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[3356288],"length":1,"stats":{"Line":0},"fn_name":"schema"},{"line":65,"address":[3356392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[2102496],"length":1,"stats":{"Line":1},"fn_name":"into_response<gotham_restful::response::redirect::test::MsgError>"},{"line":87,"address":[2102726,2102508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[2102754,2102533],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[2102893,2102816],"length":1,"stats":{"Line":1},"fn_name":"status_codes<gotham_restful::response::redirect::test::MsgError>"},{"line":101,"address":[2102833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[2102848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":21},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","result.rs"],"content":"use super::{handle_error, IntoResponse, ResourceError};\n#[cfg(feature = \"openapi\")]\nuse crate::ResponseSchema;\nuse crate::{Response, ResponseBody, Success};\nuse futures_core::future::Future;\nuse gotham::{\n\tanyhow::Error,\n\thyper::StatusCode,\n\tmime::{Mime, APPLICATION_JSON}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\nuse std::{fmt::Debug, pin::Pin};\n\npub trait IntoResponseError {\n\ttype Err: Debug + Send + 'static;\n\n\tfn into_response_error(self) -> Result<Response, Self::Err>;\n\n\t#[cfg(feature = \"openapi\")]\n\tfn status_codes() -> Vec<StatusCode>;\n\n\t#[cfg(feature = \"openapi\")]\n\tfn schema(code: StatusCode) -> OpenapiSchema;\n}\n\nimpl<E> IntoResponseError for E\nwhere\n\tE: Into<Error>\n{\n\ttype Err = serde_json::Error;\n\n\tfn into_response_error(self) -> Result<Response, Self::Err> {\n\t\tlet err: Error = self.into();\n\t\tlet err: ResourceError = err.into();\n\t\tOk(Response::json(\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tserde_json::to_string(&err)?\n\t\t))\n\t}\n\n\t#[cfg(feature = \"openapi\")]\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::INTERNAL_SERVER_ERROR]\n\t}\n\n\t#[cfg(feature = \"openapi\")]\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::INTERNAL_SERVER_ERROR);\n\t\tResourceError::schema()\n\t}\n}\n\nimpl<R, E> IntoResponse for Result<R, E>\nwhere\n\tR: ResponseBody,\n\tE: Debug + IntoResponseError<Err = serde_json::Error>\n{\n\ttype Err = E::Err;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, E::Err>> + Send>> {\n\t\tmatch self {\n\t\t\tOk(r) => Success::from(r).into_response(),\n\t\t\tErr(e) => handle_error(e)\n\t\t}\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tSome(vec![APPLICATION_JSON])\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<R, E> ResponseSchema for Result<R, E>\nwhere\n\tR: ResponseBody,\n\tE: Debug + IntoResponseError<Err = serde_json::Error>\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::OK);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::OK => R::schema(),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse crate::response::OrAllTypes;\n\tuse futures_executor::block_on;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Deserialize, Serialize)]\n\t#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n\tstruct Msg {\n\t\tmsg: String\n\t}\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn result_ok() {\n\t\tlet ok: Result<Msg, MsgError> = Ok(Msg::default());\n\t\tlet res = block_on(ok.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(APPLICATION_JSON));\n\t\tassert_eq!(res.full_body().unwrap(), br#\"{\"msg\":\"\"}\"#);\n\t}\n\n\t#[test]\n\tfn result_err() {\n\t\tlet err: Result<Msg, MsgError> = Err(MsgError::default());\n\t\tlet res = block_on(err.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::INTERNAL_SERVER_ERROR);\n\t\tassert_eq!(res.mime, Some(APPLICATION_JSON));\n\t\tassert_eq!(\n\t\t\tres.full_body().unwrap(),\n\t\t\tformat!(r#\"{{\"error\":true,\"message\":\"{}\"}}\"#, MsgError::default()).as_bytes()\n\t\t);\n\t}\n\n\t#[test]\n\tfn success_accepts_json() {\n\t\tassert!(\n\t\t\t<Result<Msg, MsgError>>::accepted_types()\n\t\t\t\t.or_all_types()\n\t\t\t\t.contains(&APPLICATION_JSON)\n\t\t)\n\t}\n}\n","traces":[{"line":33,"address":[2154688,2154831],"length":1,"stats":{"Line":2},"fn_name":"into_response_error<gotham_restful::response::no_content::test::MsgError>"},{"line":34,"address":[2102928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[2154727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[2103263,2103154],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[2334352],"length":1,"stats":{"Line":3},"fn_name":"status_codes<gotham_restful::response::raw::test::MsgError>"},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[2104800,2105072],"length":1,"stats":{"Line":1},"fn_name":"into_response<openapi_specification::Secrets, gotham_restful::response::auth_result::AuthError>"},{"line":62,"address":[2105084,2104812,2105212,2105001],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2103429,2103547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[2103514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[2103600],"length":1,"stats":{"Line":3},"fn_name":"accepted_types<gotham_restful::response::result::test::Msg, gotham_restful::response::result::test::MsgError>"},{"line":69,"address":[2103614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":20,"coverable":24},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","success.rs"],"content":"use super::IntoResponse;\n#[cfg(feature = \"openapi\")]\nuse crate::ResponseSchema;\nuse crate::{Response, ResponseBody};\nuse futures_util::future::{self, FutureExt};\nuse gotham::{\n\thyper::{\n\t\theader::{HeaderMap, HeaderValue, IntoHeaderName},\n\t\tStatusCode\n\t},\n\tmime::{Mime, APPLICATION_JSON}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiSchema;\nuse std::{fmt::Debug, future::Future, pin::Pin};\n\n/**\nThis can be returned from a resource when there is no cause of an error.\n\nUsage example:\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# mod doc_tests_are_broken {\n# use gotham::state::State;\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n#[derive(Deserialize, Serialize)]\n# #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct MyResponse {\n\tmessage: &'static str\n}\n\n#[read_all]\nfn read_all() -> Success<MyResponse> {\n\tlet res = MyResponse { message: \"I'm always happy\" };\n\tres.into()\n}\n# }\n```\n*/\n#[derive(Clone, Debug, Default)]\npub struct Success<T> {\n\tvalue: T,\n\theaders: HeaderMap\n}\n\nimpl<T> From<T> for Success<T> {\n\tfn from(t: T) -> Self {\n\t\tSelf {\n\t\t\tvalue: t,\n\t\t\theaders: HeaderMap::new()\n\t\t}\n\t}\n}\n\nimpl<T> Success<T> {\n\t/// Set a custom HTTP header. If a header with this name was set before, its value is being updated.\n\tpub fn header<K: IntoHeaderName>(&mut self, name: K, value: HeaderValue) {\n\t\tself.headers.insert(name, value);\n\t}\n\n\t/// Allow manipulating HTTP headers.\n\tpub fn headers_mut(&mut self) -> &mut HeaderMap {\n\t\t&mut self.headers\n\t}\n}\n\nimpl<T: ResponseBody> IntoResponse for Success<T> {\n\ttype Err = serde_json::Error;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, Self::Err>> + Send>> {\n\t\tlet res = serde_json::to_string(&self.value)\n\t\t\t.map(|body| Response::json(StatusCode::OK, body).with_headers(self.headers));\n\t\tfuture::ready(res).boxed()\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tSome(vec![APPLICATION_JSON])\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<T: ResponseBody> ResponseSchema for Success<T> {\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::OK);\n\t\tT::schema()\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse crate::response::OrAllTypes;\n\tuse futures_executor::block_on;\n\tuse gotham::hyper::header::ACCESS_CONTROL_ALLOW_ORIGIN;\n\n\t#[derive(Debug, Default, Serialize)]\n\t#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n\tstruct Msg {\n\t\tmsg: String\n\t}\n\n\t#[test]\n\tfn success_always_successfull() {\n\t\tlet success: Success<Msg> = Msg::default().into();\n\t\tlet res = block_on(success.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(APPLICATION_JSON));\n\t\tassert_eq!(res.full_body().unwrap(), br#\"{\"msg\":\"\"}\"#);\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Success<Msg>>::status_codes(), vec![StatusCode::OK]);\n\t}\n\n\t#[test]\n\tfn success_custom_headers() {\n\t\tlet mut success: Success<Msg> = Msg::default().into();\n\t\tsuccess.header(ACCESS_CONTROL_ALLOW_ORIGIN, HeaderValue::from_static(\"*\"));\n\t\tlet res = block_on(success.into_response()).expect(\"didn't expect error response\");\n\t\tlet cors = res.headers.get(ACCESS_CONTROL_ALLOW_ORIGIN);\n\t\tassert_eq!(cors.map(|value| value.to_str().unwrap()), Some(\"*\"));\n\t}\n\n\t#[test]\n\tfn success_accepts_json() {\n\t\tassert!(\n\t\t\t<Success<Msg>>::accepted_types()\n\t\t\t\t.or_all_types()\n\t\t\t\t.contains(&APPLICATION_JSON)\n\t\t)\n\t}\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[2002929,2002769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[2003056],"length":1,"stats":{"Line":1},"fn_name":"header<gotham_restful::response::success::test::Msg, http::header::name::HeaderName>"},{"line":65,"address":[2003076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[2003207,2003672,2003559,2003320],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[2003571,2003872,2003219,2003893,2004144,2004165],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}<gotham_restful::response::success::test::Msg>"},{"line":80,"address":[2003743,2003535,2003183,2003391],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[2004416],"length":1,"stats":{"Line":1},"fn_name":"accepted_types<gotham_restful::response::success::test::Msg>"},{"line":84,"address":[2004430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":14},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","routing.rs"],"content":"#[cfg(feature = \"openapi\")]\nuse crate::openapi::{\n\tbuilder::{OpenapiBuilder, OpenapiInfo},\n\trouter::OpenapiRouter\n};\nuse crate::{response::ResourceError, Endpoint, FromBody, IntoResponse, Resource, Response};\n#[cfg(feature = \"cors\")]\nuse gotham::router::route::matcher::AccessControlRequestMethodMatcher;\nuse gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::{create_empty_response, create_response},\n\thyper::{body::to_bytes, header::CONTENT_TYPE, Body, HeaderMap, Method, StatusCode},\n\tmime::{Mime, APPLICATION_JSON},\n\tpipeline::PipelineHandleChain,\n\tprelude::*,\n\trouter::{\n\t\tbuilder::{RouterBuilder, ScopeBuilder},\n\t\troute::matcher::{AcceptHeaderRouteMatcher, ContentTypeHeaderRouteMatcher, RouteMatcher},\n\t\tRouteNonMatch\n\t},\n\tstate::{FromState, State}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse std::{any::TypeId, panic::RefUnwindSafe};\n\n/// Allow us to extract an id from a path.\n#[derive(Clone, Copy, Debug, Deserialize, StateData, StaticResponseExtender)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\npub struct PathExtractor<ID: RefUnwindSafe + Send + 'static> {\n\tpub id: ID\n}\n\n/// This trait adds the `with_openapi` method to gotham's routing. It turns the default\n/// router into one that will only allow RESTful resources, but record them and generate\n/// an OpenAPI specification on request.\n#[cfg(feature = \"openapi\")]\npub trait WithOpenapi<D> {\n\tfn with_openapi<F>(&mut self, info: OpenapiInfo, block: F)\n\twhere\n\t\tF: FnOnce(OpenapiRouter<'_, D>);\n}\n\n/// This trait adds the `resource` method to gotham's routing. It allows you to register\n/// any RESTful [Resource] with a path.\n#[_private_openapi_trait(DrawResourcesWithSchema)]\npub trait DrawResources {\n\t#[openapi_bound(\"R: crate::ResourceWithSchema\")]\n\t#[non_openapi_bound(\"R: crate::Resource\")]\n\tfn resource<R>(&mut self, path: &str);\n}\n\n/// This trait allows to draw routes within an resource. Use this only inside the\n/// [Resource::setup] method.\n#[_private_openapi_trait(DrawResourceRoutesWithSchema)]\npub trait DrawResourceRoutes {\n\t#[openapi_bound(\"E: crate::EndpointWithSchema\")]\n\t#[non_openapi_bound(\"E: crate::Endpoint\")]\n\tfn endpoint<E: 'static>(&mut self);\n}\n\nfn response_from(res: Response, state: &State) -> gotham::hyper::Response<Body> {\n\tlet mut r = create_empty_response(state, res.status);\n\tlet headers = r.headers_mut();\n\tif let Some(mime) = res.mime {\n\t\theaders.insert(CONTENT_TYPE, mime.as_ref().parse().unwrap());\n\t}\n\tlet mut last_name = None;\n\tfor (name, value) in res.headers {\n\t\tif name.is_some() {\n\t\t\tlast_name = name;\n\t\t}\n\t\t// this unwrap is safe: the first item will always be Some\n\t\tlet name = last_name.clone().unwrap();\n\t\theaders.insert(name, value);\n\t}\n\n\tlet method = Method::borrow_from(state);\n\tif method != Method::HEAD {\n\t\t*r.body_mut() = res.body;\n\t}\n\n\t#[cfg(feature = \"cors\")]\n\tcrate::cors::handle_cors(state, &mut r);\n\n\tr\n}\n\nasync fn endpoint_handler<E: Endpoint>(\n\tstate: &mut State\n) -> Result<gotham::hyper::Response<Body>, HandlerError>\nwhere\n\tE: Endpoint,\n\t<E::Output as IntoResponse>::Err: Into<HandlerError>\n{\n\ttrace!(\"entering endpoint_handler\");\n\tlet placeholders = E::Placeholders::take_from(state);\n\t// workaround for E::Placeholders and E::Param being the same type\n\t// when fixed remove `Clone` requirement on endpoint\n\tif TypeId::of::<E::Placeholders>() == TypeId::of::<E::Params>() {\n\t\tstate.put(placeholders.clone());\n\t}\n\tlet params = E::Params::take_from(state);\n\n\tlet body = match E::needs_body() {\n\t\ttrue => {\n\t\t\tlet body = to_bytes(Body::take_from(state)).await?;\n\n\t\t\tlet content_type: Mime = match HeaderMap::borrow_from(state).get(CONTENT_TYPE) {\n\t\t\t\tSome(content_type) => content_type.to_str().unwrap().parse().unwrap(),\n\t\t\t\tNone => {\n\t\t\t\t\tdebug!(\"Missing Content-Type: Returning 415 Response\");\n\t\t\t\t\tlet res = create_empty_response(state, StatusCode::UNSUPPORTED_MEDIA_TYPE);\n\t\t\t\t\treturn Ok(res);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch E::Body::from_body(body, content_type) {\n\t\t\t\tOk(body) => Some(body),\n\t\t\t\tErr(e) => {\n\t\t\t\t\tdebug!(\"Invalid Body: Returning 400 Response\");\n\t\t\t\t\tlet error: ResourceError = e.into();\n\t\t\t\t\tlet json = serde_json::to_string(&error)?;\n\t\t\t\t\tlet res =\n\t\t\t\t\t\tcreate_response(state, StatusCode::BAD_REQUEST, APPLICATION_JSON, json);\n\t\t\t\t\treturn Ok(res);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfalse => None\n\t};\n\n\tlet out = E::handle(state, placeholders, params, body).await;\n\tlet res = out.into_response().await.map_err(Into::into)?;\n\tdebug!(\"Returning response {res:?}\");\n\tOk(response_from(res, state))\n}\n\n#[derive(Clone)]\nstruct MaybeMatchAcceptHeader {\n\tmatcher: Option<AcceptHeaderRouteMatcher>\n}\n\nimpl RouteMatcher for MaybeMatchAcceptHeader {\n\tfn is_match(&self, state: &State) -> Result<(), RouteNonMatch> {\n\t\tmatch &self.matcher {\n\t\t\tSome(matcher) => matcher.is_match(state),\n\t\t\tNone => Ok(())\n\t\t}\n\t}\n}\n\nimpl MaybeMatchAcceptHeader {\n\tfn new(types: Option<Vec<Mime>>) -> Self {\n\t\tlet types = match types {\n\t\t\tSome(types) if types.is_empty() => None,\n\t\t\ttypes => types\n\t\t};\n\t\tSelf {\n\t\t\tmatcher: types.map(AcceptHeaderRouteMatcher::new)\n\t\t}\n\t}\n}\n\nimpl From<Option<Vec<Mime>>> for MaybeMatchAcceptHeader {\n\tfn from(types: Option<Vec<Mime>>) -> Self {\n\t\tSelf::new(types)\n\t}\n}\n\n#[derive(Clone)]\nstruct MaybeMatchContentTypeHeader {\n\tmatcher: Option<ContentTypeHeaderRouteMatcher>\n}\n\nimpl RouteMatcher for MaybeMatchContentTypeHeader {\n\tfn is_match(&self, state: &State) -> Result<(), RouteNonMatch> {\n\t\tmatch &self.matcher {\n\t\t\tSome(matcher) => matcher.is_match(state),\n\t\t\tNone => Ok(())\n\t\t}\n\t}\n}\n\nimpl MaybeMatchContentTypeHeader {\n\tfn new(types: Option<Vec<Mime>>) -> Self {\n\t\tSelf {\n\t\t\tmatcher: types.map(|types| ContentTypeHeaderRouteMatcher::new(types).allow_no_type())\n\t\t}\n\t}\n}\n\nimpl From<Option<Vec<Mime>>> for MaybeMatchContentTypeHeader {\n\tfn from(types: Option<Vec<Mime>>) -> Self {\n\t\tSelf::new(types)\n\t}\n}\n\nmacro_rules! implDrawResourceRoutes {\n\t($implType:ident) => {\n\t\t#[cfg(feature = \"openapi\")]\n\t\timpl<'a, C, P> WithOpenapi<Self> for $implType<'a, C, P>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn with_openapi<F>(&mut self, info: OpenapiInfo, block: F)\n\t\t\twhere\n\t\t\t\tF: FnOnce(OpenapiRouter<'_, $implType<'a, C, P>>)\n\t\t\t{\n\t\t\t\tlet router = OpenapiRouter {\n\t\t\t\t\trouter: self,\n\t\t\t\t\tscope: None,\n\t\t\t\t\topenapi_builder: &mut OpenapiBuilder::new(info)\n\t\t\t\t};\n\t\t\t\tblock(router);\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, C, P> DrawResources for $implType<'a, C, P>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn resource<R: Resource>(&mut self, mut path: &str) {\n\t\t\t\tif path.starts_with('/') {\n\t\t\t\t\tpath = &path[1..];\n\t\t\t\t}\n\t\t\t\tR::setup((self, path));\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, C, P> DrawResourceRoutes for (&mut $implType<'a, C, P>, &str)\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn endpoint<E: Endpoint + 'static>(&mut self) {\n\t\t\t\tlet uri = format!(\"{}/{}\", self.1, E::uri());\n\t\t\t\tdebug!(\"Registering endpoint for {uri}\");\n\t\t\t\tself.0.associate(&uri, |assoc| {\n\t\t\t\t\tassoc\n\t\t\t\t\t\t.request(vec![E::http_method()])\n\t\t\t\t\t\t.add_route_matcher(MaybeMatchAcceptHeader::new(E::Output::accepted_types()))\n\t\t\t\t\t\t.with_path_extractor::<E::Placeholders>()\n\t\t\t\t\t\t.with_query_string_extractor::<E::Params>()\n\t\t\t\t\t\t.to_async_borrowing(endpoint_handler::<E>);\n\n\t\t\t\t\t#[cfg(feature = \"cors\")]\n\t\t\t\t\tif E::http_method() != Method::GET {\n\t\t\t\t\t\tassoc\n\t\t\t\t\t\t\t.options()\n\t\t\t\t\t\t\t.add_route_matcher(AccessControlRequestMethodMatcher::new(\n\t\t\t\t\t\t\t\tE::http_method()\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t.to(crate::cors::cors_preflight_handler);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n\nimplDrawResourceRoutes!(RouterBuilder);\nimplDrawResourceRoutes!(ScopeBuilder);\n","traces":[{"line":62,"address":[1895693,1893536],"length":1,"stats":{"Line":5},"fn_name":"response_from"},{"line":63,"address":[1893579],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[1893689,1893761],"length":1,"stats":{"Line":10},"fn_name":null},{"line":65,"address":[1893846,1893769],"length":1,"stats":{"Line":9},"fn_name":null},{"line":66,"address":[1894104,1894164,1893937],"length":1,"stats":{"Line":12},"fn_name":null},{"line":68,"address":[1893962],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[1893970,1895131,1894409,1894324,1895102],"length":1,"stats":{"Line":15},"fn_name":null},{"line":70,"address":[1894614,1894803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[1894808,1894702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[1894861,1894692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[1894896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[1895182],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[1895211,1895440],"length":1,"stats":{"Line":10},"fn_name":null},{"line":80,"address":[1895276,1895450],"length":1,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[1895261],"length":1,"stats":{"Line":5},"fn_name":null},{"line":86,"address":[1895516],"length":1,"stats":{"Line":5},"fn_name":null},{"line":89,"address":[1793824,1793888,1793504,1793568,1793696,1793632,1793760],"length":1,"stats":{"Line":21},"fn_name":"endpoint_handler<openapi_specification::coffee_read_all___gotham_restful_endpoint>"},{"line":96,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":145,"address":[1895920],"length":1,"stats":{"Line":6},"fn_name":"is_match"},{"line":146,"address":[1895948],"length":1,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[1896001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[1895981],"length":1,"stats":{"Line":6},"fn_name":null},{"line":154,"address":[1896032,1896394],"length":1,"stats":{"Line":7},"fn_name":"new"},{"line":155,"address":[1896054],"length":1,"stats":{"Line":7},"fn_name":null},{"line":156,"address":[1896214,1896112,1896266],"length":1,"stats":{"Line":9},"fn_name":null},{"line":157,"address":[1896136],"length":1,"stats":{"Line":5},"fn_name":null},{"line":160,"address":[1896316],"length":1,"stats":{"Line":7},"fn_name":null},{"line":166,"address":[1896496],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":167,"address":[1896508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[1896560],"length":1,"stats":{"Line":0},"fn_name":"is_match"},{"line":178,"address":[1896588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[1896640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[1896620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[1896672],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":188,"address":[1896685,1896768,1896785],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":194,"address":[1896864],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":195,"address":[1896876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[2987808,2988148],"length":1,"stats":{"Line":2},"fn_name":"with_openapi<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()), (gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()), openapi_specification::openapi_specification::{closure#0}::{closure#0}>"},{"line":211,"address":[2987828,2987939],"length":1,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[2987844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[2987853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[2987974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[1989024],"length":1,"stats":{"Line":5},"fn_name":"resource<(), (), custom_request_body::FooResource>"},{"line":226,"address":[1989048,1989190],"length":1,"stats":{"Line":7},"fn_name":null},{"line":227,"address":[1989125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[1989088],"length":1,"stats":{"Line":5},"fn_name":null},{"line":238,"address":[2988552,2989120,2991952,2988176,2990440,2989496,2993272,2992896,2993840,2990064,2991384,2994216,2992328,2991008],"length":1,"stats":{"Line":31},"fn_name":"endpoint<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()), (gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()), openapi_specification::coffee_read_all___gotham_restful_endpoint>"},{"line":239,"address":[2992919,2992413,2993357,2989581,2988567,2994301,2990455,2988199,2991975,2988637,2991399,2991469,2993287,2990087,2990525,2991031,2989143,2993863,2989511,2992343,2994231],"length":1,"stats":{"Line":62},"fn_name":null},{"line":240,"address":[2992578,2993522,2988802,2993632,2990567,2990800,2991431,2988599,2992688,2993399,2989670,2988726,2992375,2990487,2992502,2991558,2994390,2994263,2993319,2994466,2991634,2989623,2994576,2991511,2990614,2988679,2989746,2994343,2993446,2991744,2989856,2990690,2992455,2988912,2989543],"length":1,"stats":{"Line":93},"fn_name":null},{"line":241,"address":[1846304,1844112,1845568,1841952,1844848,1843567,1842672,1842847,1845023,1843392,1845743,1846479,1842127,1844287],"length":1,"stats":{"Line":93},"fn_name":"{closure#0}<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()), (gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()), openapi_specification::get_image___gotham_restful_endpoint>"},{"line":242,"address":[1845588,1843019,1842692,1843739,1845236,1845960,1844868,1842340,1846608,1844463,1846655,1843692,1846696,1844132,1843412,1843780,1841972,1844307,1844416,1842147,1842299,1844504,1845919,1842972,1843587,1846499,1846324,1845148,1843060,1842252,1845872,1842867,1845043,1845763,1845195],"length":1,"stats":{"Line":155},"fn_name":null},{"line":243,"address":[1844884,1845604,1842168,1842708,1845064,1845784,1843608,1841988,1843428,1844148,1844328,1846340,1842888,1846520],"length":1,"stats":{"Line":62},"fn_name":null},{"line":244,"address":[1845942,1846647,1846678,1843042,1843731,1845187,1844486,1842184,1844455,1842291,1844336,1845792,1843011,1842904,1843624,1845218,1846528,1842322,1843762,1845080,1845911],"length":1,"stats":{"Line":62},"fn_name":null},{"line":250,"address":[1845264,1845988,1846724,1842368,1843808,1843088,1844532],"length":1,"stats":{"Line":31},"fn_name":null},{"line":251,"address":[1843307,1844074,1842634,1842587,1844798,1846207,1846943,1844651,1845383,1844751,1844027,1843354,1845530,1843207,1846843,1846254,1842487,1846990,1843927,1846107,1845483],"length":1,"stats":{"Line":45},"fn_name":null},{"line":253,"address":[1845419,1846143,1842523,1843243,1846879,1844687,1843963],"length":1,"stats":{"Line":15},"fn_name":null},{"line":254,"address":[1846872,1846136,1843236,1842516,1843956,1844680,1845412],"length":1,"stats":{"Line":15},"fn_name":null}],"covered":57,"coverable":84},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","types.rs"],"content":"use gotham::{\n\thyper::body::Bytes,\n\tmime::{Mime, APPLICATION_JSON}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::error::Error;\n\n#[cfg(not(feature = \"openapi\"))]\npub trait ResourceType {}\n\n#[cfg(not(feature = \"openapi\"))]\nimpl<T> ResourceType for T {}\n\n#[cfg(feature = \"openapi\")]\npub trait ResourceType: OpenapiType {}\n\n#[cfg(feature = \"openapi\")]\nimpl<T: OpenapiType> ResourceType for T {}\n\n/// A type that can be used inside a response body. Implemented for every type that is\n/// serializable with serde. If the `openapi` feature is used, it must also be of type\n/// [OpenapiType].\n///\n///  [OpenapiType]: trait.OpenapiType.html\npub trait ResponseBody: ResourceType + Serialize {}\n\nimpl<T: ResourceType + Serialize> ResponseBody for T {}\n\n/**\nThis trait should be implemented for every type that can be built from an HTTP request body\nplus its media type.\n\nFor most use cases it is sufficient to derive this trait, you usually don't need to manually\nimplement this. Therefore, make sure that the first variable of your struct can be built from\n[Bytes], and the second one can be build from [Mime]. If you have any additional variables, they\nneed to be [Default]. This is an example of such a struct:\n\n```rust\n# use gotham::mime::{self, Mime};\n# use gotham_restful::{FromBody, RequestBody};\n#[derive(FromBody, RequestBody)]\n#[supported_types(mime::IMAGE_GIF, mime::IMAGE_JPEG, mime::IMAGE_PNG)]\nstruct RawImage {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n```\n*/\npub trait FromBody: Sized {\n\t/// The error type returned by the conversion if it was unsuccessfull. When using the derive\n\t/// macro, there is no way to trigger an error, so [std::convert::Infallible] is used here.\n\t/// However, this might change in the future.\n\ttype Err: Error;\n\n\t/// Perform the conversion.\n\tfn from_body(body: Bytes, content_type: Mime) -> Result<Self, Self::Err>;\n}\n\nimpl<T: DeserializeOwned> FromBody for T {\n\ttype Err = serde_json::Error;\n\n\tfn from_body(body: Bytes, _content_type: Mime) -> Result<Self, Self::Err> {\n\t\tserde_json::from_slice(&body)\n\t}\n}\n\n/**\nA type that can be used inside a request body. Implemented for every type that is deserializable\nwith serde. If the `openapi` feature is used, it must also be of type [OpenapiType].\n\nIf you want a non-deserializable type to be used as a request body, e.g. because you'd like to\nget the raw data, you can derive it for your own type. All you need is to have a type implementing\n[FromBody] and optionally a list of supported media types:\n\n```rust\n# use gotham::mime::{self, Mime};\n# use gotham_restful::{FromBody, RequestBody};\n#[derive(FromBody, RequestBody)]\n#[supported_types(mime::IMAGE_GIF, mime::IMAGE_JPEG, mime::IMAGE_PNG)]\nstruct RawImage {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n```\n\n [OpenapiType]: trait.OpenapiType.html\n*/\npub trait RequestBody: ResourceType + FromBody {\n\t/// Return all types that are supported as content types. Use `None` if all types are supported.\n\tfn supported_types() -> Option<Vec<Mime>> {\n\t\tNone\n\t}\n}\n\nimpl<T: ResourceType + DeserializeOwned> RequestBody for T {\n\tfn supported_types() -> Option<Vec<Mime>> {\n\t\tSome(vec![APPLICATION_JSON])\n\t}\n}\n","traces":[{"line":64,"address":[2430304,2430462],"length":1,"stats":{"Line":2},"fn_name":"from_body<alloc::string::String>"},{"line":65,"address":[1729070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","async_methods.rs"],"content":"use gotham::{\n\thyper::{HeaderMap, Method},\n\tmime::{APPLICATION_JSON, TEXT_PLAIN},\n\tprelude::*,\n\trouter::build_simple_router,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_restful::*;\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse serde::Deserialize;\nuse tokio::time::{sleep, Duration};\n\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::{test_delete_response, test_get_response, test_post_response, test_put_response};\n\n#[derive(Resource)]\n#[resource(\n\tread_all, read, search, create, update_all, update, delete_all, delete, state_test\n)]\nstruct FooResource;\n\n#[derive(Deserialize)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooBody {\n\tdata: String\n}\n\n#[derive(Clone, Deserialize, StateData, StaticResponseExtender)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooSearch {\n\tquery: String\n}\n\nconst READ_ALL_RESPONSE: &[u8] = b\"1ARwwSPVyOKpJKrYwqGgECPVWDl1BqajAAj7g7WJ3e\";\n#[read_all]\nasync fn read_all() -> Raw<&'static [u8]> {\n\tRaw::new(READ_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst READ_RESPONSE: &[u8] = b\"FEReHoeBKU17X2bBpVAd1iUvktFL43CDu0cFYHdaP9\";\n#[read]\nasync fn read(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(READ_RESPONSE, TEXT_PLAIN)\n}\n\nconst SEARCH_RESPONSE: &[u8] = b\"AWqcQUdBRHXKh3at4u79mdupOAfEbnTcx71ogCVF0E\";\n#[search]\nasync fn search(_body: FooSearch) -> Raw<&'static [u8]> {\n\tRaw::new(SEARCH_RESPONSE, TEXT_PLAIN)\n}\n\nconst CREATE_RESPONSE: &[u8] = b\"y6POY7wOMAB0jBRBw0FJT7DOpUNbhmT8KdpQPLkI83\";\n#[create]\nasync fn create(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(CREATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_ALL_RESPONSE: &[u8] = b\"QlbYg8gHE9OQvvk3yKjXJLTSXlIrg9mcqhfMXJmQkv\";\n#[update_all]\nasync fn update_all(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_RESPONSE: &[u8] = b\"qGod55RUXkT1lgPO8h0uVM6l368O2S0GrwENZFFuRu\";\n#[update]\nasync fn update(_id: u64, _body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_ALL_RESPONSE: &[u8] = b\"Y36kZ749MRk2Nem4BedJABOZiZWPLOtiwLfJlGTwm5\";\n#[delete_all]\nasync fn delete_all() -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_RESPONSE: &[u8] = b\"CwRzBrKErsVZ1N7yeNfjZuUn1MacvgBqk4uPOFfDDq\";\n#[delete]\nasync fn delete(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_RESPONSE, TEXT_PLAIN)\n}\n\nconst STATE_TEST_RESPONSE: &[u8] = b\"xxJbxOuwioqR5DfzPuVqvaqRSfpdNQGluIvHU4n1LM\";\n#[endpoint(method = \"Method::GET\", uri = \"state_test\")]\nasync fn state_test(state: &mut State) -> Raw<&'static [u8]> {\n\tsleep(Duration::from_nanos(1)).await;\n\tstate.borrow::<HeaderMap>();\n\tsleep(Duration::from_nanos(1)).await;\n\tRaw::new(STATE_TEST_RESPONSE, TEXT_PLAIN)\n}\n\n#[test]\nfn async_methods() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.resource::<FooResource>(\"foo\");\n\t}))\n\t.unwrap();\n\n\ttest_get_response(&server, \"http://localhost/foo\", READ_ALL_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/1\", READ_RESPONSE);\n\ttest_get_response(\n\t\t&server,\n\t\t\"http://localhost/foo/search?query=hello+world\",\n\t\tSEARCH_RESPONSE\n\t);\n\ttest_post_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tCREATE_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_ALL_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo/1\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_RESPONSE\n\t);\n\ttest_delete_response(&server, \"http://localhost/foo\", DELETE_ALL_RESPONSE);\n\ttest_delete_response(&server, \"http://localhost/foo/1\", DELETE_RESPONSE);\n\ttest_get_response(\n\t\t&server,\n\t\t\"http://localhost/foo/state_test\",\n\t\tSTATE_TEST_RESPONSE\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","cors_handling.rs"],"content":"#![cfg(feature = \"cors\")]\nuse gotham::{\n\thyper::{body::Body, client::connect::Connect, header::*, StatusCode},\n\tmime::TEXT_PLAIN,\n\tpipeline::{new_pipeline, single_pipeline},\n\trouter::build_router,\n\ttest::{Server, TestRequest, TestServer}\n};\nuse gotham_restful::{\n\tcors::{Headers, Origin},\n\tread_all, update_all, CorsConfig, DrawResources, Raw, Resource\n};\n\n#[derive(Resource)]\n#[resource(read_all, update_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() {}\n\n#[update_all]\nfn update_all(_body: Raw<Vec<u8>>) {}\n\nfn test_server(cfg: CorsConfig) -> TestServer {\n\tlet (chain, pipeline) = single_pipeline(new_pipeline().add(cfg).build());\n\tTestServer::new(build_router(chain, pipeline, |router| {\n\t\trouter.resource::<FooResource>(\"/foo\")\n\t}))\n\t.unwrap()\n}\n\nfn test_response<TS, C>(\n\treq: TestRequest<TS, C>,\n\torigin: Option<&str>,\n\tvary: Option<&str>,\n\tcredentials: bool\n) where\n\tTS: Server + 'static,\n\tC: Connect + Clone + Send + Sync + 'static\n{\n\tlet res = req\n\t\t.with_header(ORIGIN, \"http://example.org\".parse().unwrap())\n\t\t.perform()\n\t\t.unwrap();\n\tassert_eq!(res.status(), StatusCode::NO_CONTENT);\n\tlet headers = res.headers();\n\tprintln!(\n\t\t\"{}\",\n\t\theaders\n\t\t\t.keys()\n\t\t\t.map(|name| name.as_str())\n\t\t\t.collect::<Vec<_>>()\n\t\t\t.join(\",\")\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_ORIGIN)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\torigin\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(VARY)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\tvary\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.map(|value| value == \"true\")\n\t\t\t.unwrap_or(false),\n\t\tcredentials\n\t);\n\tassert!(headers.get(ACCESS_CONTROL_MAX_AGE).is_none());\n}\n\nfn test_preflight(\n\tserver: &TestServer,\n\tmethod: &str,\n\torigin: Option<&str>,\n\tvary: &str,\n\tcredentials: bool,\n\tmax_age: u64\n) {\n\tlet res = server\n\t\t.client()\n\t\t.options(\"http://example.org/foo\")\n\t\t.with_header(ACCESS_CONTROL_REQUEST_METHOD, method.parse().unwrap())\n\t\t.with_header(ORIGIN, \"http://example.org\".parse().unwrap())\n\t\t.perform()\n\t\t.unwrap();\n\tassert_eq!(res.status(), StatusCode::NO_CONTENT);\n\tlet headers = res.headers();\n\tprintln!(\n\t\t\"{}\",\n\t\theaders\n\t\t\t.keys()\n\t\t\t.map(|name| name.as_str())\n\t\t\t.collect::<Vec<_>>()\n\t\t\t.join(\",\")\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_METHODS)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\tSome(method)\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_ORIGIN)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\torigin\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(VARY)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\tSome(vary)\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.map(|value| value == \"true\")\n\t\t\t.unwrap_or(false),\n\t\tcredentials\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_MAX_AGE)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.and_then(|value| value.parse().ok()),\n\t\tSome(max_age)\n\t);\n}\n\nfn test_preflight_headers(\n\tserver: &TestServer,\n\tmethod: &str,\n\trequest_headers: Option<&str>,\n\tallowed_headers: Option<&str>,\n\tvary: &str\n) {\n\tlet client = server.client();\n\tlet mut res = client\n\t\t.options(\"http://example.org/foo\")\n\t\t.with_header(ACCESS_CONTROL_REQUEST_METHOD, method.parse().unwrap())\n\t\t.with_header(ORIGIN, \"http://example.org\".parse().unwrap());\n\tif let Some(hdr) = request_headers {\n\t\tres = res.with_header(ACCESS_CONTROL_REQUEST_HEADERS, hdr.parse().unwrap());\n\t}\n\tlet res = res.perform().unwrap();\n\tassert_eq!(res.status(), StatusCode::NO_CONTENT);\n\tlet headers = res.headers();\n\tprintln!(\n\t\t\"{}\",\n\t\theaders\n\t\t\t.keys()\n\t\t\t.map(|name| name.as_str())\n\t\t\t.collect::<Vec<_>>()\n\t\t\t.join(\",\")\n\t);\n\tif let Some(hdr) = allowed_headers {\n\t\tassert_eq!(\n\t\t\theaders\n\t\t\t\t.get(ACCESS_CONTROL_ALLOW_HEADERS)\n\t\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t\t.as_deref(),\n\t\t\tSome(hdr)\n\t\t)\n\t} else {\n\t\tassert!(!headers.contains_key(ACCESS_CONTROL_ALLOW_HEADERS));\n\t}\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(VARY)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\tSome(vary)\n\t);\n}\n\n#[test]\nfn cors_origin_none() {\n\tlet cfg = Default::default();\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tNone,\n\t\t\"access-control-request-method\",\n\t\tfalse,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tNone,\n\t\tNone,\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver\n\t\t\t.client()\n\t\t\t.put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tNone,\n\t\tNone,\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_origin_star() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::Star,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"*\"),\n\t\t\"access-control-request-method\",\n\t\tfalse,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tSome(\"*\"),\n\t\tNone,\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver\n\t\t\t.client()\n\t\t\t.put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tSome(\"*\"),\n\t\tNone,\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_origin_single() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::Single(\"https://foo.com\".to_owned()),\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"https://foo.com\"),\n\t\t\"access-control-request-method\",\n\t\tfalse,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tSome(\"https://foo.com\"),\n\t\tNone,\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver\n\t\t\t.client()\n\t\t\t.put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tSome(\"https://foo.com\"),\n\t\tNone,\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_origin_copy() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::Copy,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"http://example.org\"),\n\t\t\"access-control-request-method,origin\",\n\t\tfalse,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tSome(\"http://example.org\"),\n\t\tSome(\"origin\"),\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver\n\t\t\t.client()\n\t\t\t.put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tSome(\"http://example.org\"),\n\t\tSome(\"origin\"),\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_headers_none() {\n\tlet cfg = Default::default();\n\tlet server = test_server(cfg);\n\n\ttest_preflight_headers(&server, \"PUT\", None, None, \"access-control-request-method\");\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"Content-Type\"),\n\t\tNone,\n\t\t\"access-control-request-method\"\n\t);\n}\n\n#[test]\nfn cors_headers_list() {\n\tlet cfg = CorsConfig {\n\t\theaders: Headers::List(vec![CONTENT_TYPE]),\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tNone,\n\t\tSome(\"content-type\"),\n\t\t\"access-control-request-method\"\n\t);\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"content-type\"),\n\t\tSome(\"content-type\"),\n\t\t\"access-control-request-method\"\n\t);\n}\n\n#[test]\nfn cors_headers_copy() {\n\tlet cfg = CorsConfig {\n\t\theaders: Headers::Copy,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tNone,\n\t\tNone,\n\t\t\"access-control-request-method,access-control-request-headers\"\n\t);\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"content-type\"),\n\t\tSome(\"content-type\"),\n\t\t\"access-control-request-method,access-control-request-headers\"\n\t);\n}\n\n#[test]\nfn cors_credentials() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::None,\n\t\tcredentials: true,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tNone,\n\t\t\"access-control-request-method\",\n\t\ttrue,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tNone,\n\t\tNone,\n\t\ttrue\n\t);\n\ttest_response(\n\t\tserver\n\t\t\t.client()\n\t\t\t.put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tNone,\n\t\tNone,\n\t\ttrue\n\t);\n}\n\n#[test]\nfn cors_max_age() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::None,\n\t\tmax_age: 31536000,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tNone,\n\t\t\"access-control-request-method\",\n\t\tfalse,\n\t\t31536000\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tNone,\n\t\tNone,\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver\n\t\t\t.client()\n\t\t\t.put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tNone,\n\t\tNone,\n\t\tfalse\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","custom_request_body.rs"],"content":"use gotham::{\n\thyper::header::CONTENT_TYPE,\n\tmime::{Mime, TEXT_PLAIN},\n\trouter::builder::*,\n\ttest::TestServer\n};\nuse gotham_restful::{create, DrawResources, FromBody, Raw, RequestBody, Resource};\n\nconst RESPONSE: &[u8] = b\"This is the only valid response.\";\n\n#[derive(Resource)]\n#[resource(create)]\nstruct FooResource;\n\n#[derive(FromBody, RequestBody)]\n#[supported_types(TEXT_PLAIN)]\nstruct Foo {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n\n#[create]\nfn create(body: Foo) -> Raw<Vec<u8>> {\n\tRaw::new(body.content, body.content_type)\n}\n\n#[test]\nfn custom_request_body() {\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.resource::<FooResource>(\"foo\");\n\t}))\n\t.unwrap();\n\n\tlet res = server\n\t\t.client()\n\t\t.post(\"http://localhost/foo\", RESPONSE, TEXT_PLAIN)\n\t\t.perform()\n\t\t.unwrap();\n\tassert_eq!(\n\t\tres.headers().get(CONTENT_TYPE).unwrap().to_str().unwrap(),\n\t\t\"text/plain\"\n\t);\n\tlet res = res.read_body().unwrap();\n\tlet body: &[u8] = res.as_ref();\n\tassert_eq!(body, RESPONSE);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","openapi_specification.rs"],"content":"#![cfg(all(feature = \"auth\", feature = \"openapi\"))]\n\n#[macro_use]\nextern crate pretty_assertions;\n\nuse gotham::{\n\thyper::{Method, StatusCode},\n\tmime::{IMAGE_PNG, TEXT_PLAIN_UTF_8},\n\tpipeline::{new_pipeline, single_pipeline},\n\tprelude::*,\n\trouter::build_router,\n\ttest::TestServer\n};\nuse gotham_restful::*;\nuse openapi_type::{OpenapiSchema, OpenapiType, Visitor};\nuse serde::{Deserialize, Serialize};\n\n#[allow(dead_code)]\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::test_openapi_response;\n\nconst IMAGE_RESPONSE : &[u8] = b\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUA/wA0XsCoAAAAAXRSTlN/gFy0ywAAAApJREFUeJxjYgAAAAYAAzY3fKgAAAAASUVORK5CYII=\";\n\n#[derive(Resource)]\n#[resource(get_image, set_image)]\nstruct ImageResource;\n\n#[derive(FromBody, RequestBody)]\n#[supported_types(IMAGE_PNG)]\nstruct Image(Vec<u8>);\n\n#[read(operation_id = \"getImage\")]\nfn get_image(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(IMAGE_RESPONSE, \"image/png;base64\".parse().unwrap())\n}\n\n#[update(operation_id = \"setImage\")]\nfn set_image(_id: u64, _image: Image) {}\n\n#[derive(Resource)]\n#[resource(read_secret, search_secret)]\nstruct SecretResource;\n\n#[derive(Deserialize, Clone)]\nstruct AuthData {\n\tsub: String,\n\tiat: u64,\n\texp: u64\n}\n\ntype AuthStatus = gotham_restful::AuthStatus<AuthData>;\n\n#[derive(OpenapiType, Serialize)]\nstruct Secret {\n\tcode: f32\n}\n\n#[derive(OpenapiType, Serialize)]\nstruct Secrets {\n\tsecrets: Vec<Secret>\n}\n\n#[derive(Clone, Deserialize, OpenapiType, StateData, StaticResponseExtender)]\nstruct SecretQuery {\n\tdate: String,\n\thour: Option<u16>,\n\tminute: Option<u16>\n}\n\n/// This endpoint gives access to the secret.\n///\n/// You need to be authenticated to call this endpoint.\n#[read]\nfn read_secret(auth: AuthStatus, _id: String) -> AuthSuccess<Secret> {\n\tauth.ok()?;\n\tOk(Secret { code: 4.2 })\n}\n\n#[search]\nfn search_secret(auth: AuthStatus, _query: SecretQuery) -> AuthSuccess<Secrets> {\n\tauth.ok()?;\n\tOk(Secrets {\n\t\tsecrets: vec![Secret { code: 4.2 }, Secret { code: 3.14 }]\n\t})\n}\n\n#[derive(Resource)]\n#[resource(coffee_read_all)]\nstruct CoffeeResource;\n\nfn teapot_status_codes() -> Vec<StatusCode> {\n\tvec![StatusCode::IM_A_TEAPOT]\n}\n\nfn teapot_schema(code: StatusCode) -> OpenapiSchema {\n\tassert_eq!(code, StatusCode::IM_A_TEAPOT);\n\n\tstruct Binary;\n\n\timpl OpenapiType for Binary {\n\t\tfn visit_type<V: Visitor>(visitor: &mut V) {\n\t\t\tvisitor.visit_binary();\n\t\t}\n\t}\n\n\tBinary::schema()\n}\n\n#[read_all(status_codes = \"teapot_status_codes\", schema = \"teapot_schema\")]\nfn coffee_read_all() -> Response {\n\tResponse::new(\n\t\tStatusCode::IM_A_TEAPOT,\n\t\t\"Sorry, this is just your fancy grandma's teapot. Can't make coffee.\",\n\t\tSome(TEXT_PLAIN_UTF_8)\n\t)\n}\n\n#[derive(Resource)]\n#[resource(custom_read_with, custom_patch)]\nstruct CustomResource;\n\n#[derive(Clone, Deserialize, OpenapiType, StateData, StaticResponseExtender)]\nstruct ReadWithPath {\n\tfrom: String,\n\tid: u64\n}\n\n#[endpoint(method = \"Method::GET\", uri = \"read/:from/with/:id\")]\nfn custom_read_with(_path: ReadWithPath) {}\n\n#[endpoint(method = \"Method::PATCH\", uri = \"\", body = true)]\nfn custom_patch(_body: String) {}\n\n#[test]\nfn openapi_specification() {\n\tlet info = OpenapiInfo {\n\t\ttitle: \"This is just a test\".to_owned(),\n\t\tversion: \"1.2.3\".to_owned(),\n\t\turls: vec![\"http://localhost:12345/api/v1\".to_owned()]\n\t};\n\tlet auth: AuthMiddleware<AuthData, _> = AuthMiddleware::new(\n\t\tAuthSource::AuthorizationHeader,\n\t\tAuthValidation::default(),\n\t\tStaticAuthHandler::from_array(b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\")\n\t);\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(auth).build());\n\tlet server = TestServer::new(build_router(chain, pipelines, |router| {\n\t\trouter.with_openapi(info, |mut router| {\n\t\t\t// the leading slash tests that the spec doesn't contain '//img' nonsense\n\t\t\trouter.resource::<ImageResource>(\"/img\");\n\t\t\trouter.resource::<SecretResource>(\"secret\");\n\t\t\trouter.resource::<CoffeeResource>(\"coffee\");\n\t\t\trouter.resource::<CustomResource>(\"custom\");\n\t\t\trouter.openapi_spec(\"openapi\");\n\t\t});\n\t}))\n\t.unwrap();\n\n\ttest_openapi_response(\n\t\t&server,\n\t\t\"http://localhost/openapi\",\n\t\t\"tests/openapi_specification.json\"\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","openapi_supports_scope.rs"],"content":"#![cfg(feature = \"openapi\")]\n\n#[macro_use]\nextern crate pretty_assertions;\n\nuse gotham::{mime::TEXT_PLAIN, router::builder::*, test::TestServer};\nuse gotham_restful::*;\n\n#[allow(dead_code)]\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::{test_get_response, test_openapi_response};\n\nconst RESPONSE: &[u8] = b\"This is the only valid response.\";\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() -> Raw<&'static [u8]> {\n\tRaw::new(RESPONSE, TEXT_PLAIN)\n}\n\n#[test]\nfn openapi_supports_scope() {\n\tlet info = OpenapiInfo {\n\t\ttitle: \"Test\".to_owned(),\n\t\tversion: \"1.2.3\".to_owned(),\n\t\turls: Vec::new()\n\t};\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.with_openapi(info, |mut router| {\n\t\t\trouter.openapi_spec(\"openapi\");\n\t\t\trouter.resource::<FooResource>(\"foo1\");\n\t\t\trouter.scope(\"/bar\", |router| {\n\t\t\t\trouter.resource::<FooResource>(\"foo2\");\n\t\t\t\trouter.scope(\"/baz\", |router| {\n\t\t\t\t\trouter.resource::<FooResource>(\"foo3\");\n\t\t\t\t})\n\t\t\t});\n\t\t\trouter.resource::<FooResource>(\"foo4\");\n\t\t});\n\t}))\n\t.unwrap();\n\n\ttest_get_response(&server, \"http://localhost/foo1\", RESPONSE);\n\ttest_get_response(&server, \"http://localhost/bar/foo2\", RESPONSE);\n\ttest_get_response(&server, \"http://localhost/bar/baz/foo3\", RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo4\", RESPONSE);\n\ttest_openapi_response(\n\t\t&server,\n\t\t\"http://localhost/openapi\",\n\t\t\"tests/openapi_supports_scope.json\"\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","resource_error.rs"],"content":"use gotham_restful::ResourceError;\n\n#[derive(ResourceError)]\nenum Error {\n\t#[display(\"I/O Error: {0}\")]\n\tIoError(#[from] std::io::Error),\n\n\t#[status(INTERNAL_SERVER_ERROR)]\n\t#[display(\"Internal Server Error: {0}\")]\n\tInternalServerError(String)\n}\n\n#[allow(deprecated)]\nmod resource_error {\n\tuse super::Error;\n\tuse gotham::{hyper::StatusCode, mime::APPLICATION_JSON};\n\tuse gotham_restful::IntoResponseError;\n\n\t#[test]\n\tfn io_error() {\n\t\tlet err = Error::IoError(std::io::Error::last_os_error());\n\t\tlet res = err.into_response_error().unwrap();\n\t\tassert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n\t\tassert_eq!(res.mime(), Some(&APPLICATION_JSON));\n\t}\n\n\t#[test]\n\tfn internal_server_error() {\n\t\tlet err = Error::InternalServerError(\"Brocken\".to_owned());\n\t\tassert_eq!(&format!(\"{err}\"), \"Internal Server Error: Brocken\");\n\n\t\tlet res = err.into_response_error().unwrap();\n\t\tassert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n\t\tassert_eq!(res.mime(), None); // TODO shouldn't this be a json error message?\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","sync_methods.rs"],"content":"use gotham::{\n\tmime::{APPLICATION_JSON, TEXT_PLAIN},\n\tprelude::*,\n\trouter::build_simple_router,\n\ttest::TestServer\n};\nuse gotham_restful::*;\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse serde::Deserialize;\n\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::{test_delete_response, test_get_response, test_post_response, test_put_response};\n\n#[derive(Resource)]\n#[resource(read_all, read, search, create, update_all, update, delete_all, delete)]\nstruct FooResource;\n\n#[derive(Deserialize)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooBody {\n\tdata: String\n}\n\n#[derive(Clone, Deserialize, StateData, StaticResponseExtender)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooSearch {\n\tquery: String\n}\n\nconst READ_ALL_RESPONSE: &[u8] = b\"1ARwwSPVyOKpJKrYwqGgECPVWDl1BqajAAj7g7WJ3e\";\n#[read_all]\nfn read_all() -> Raw<&'static [u8]> {\n\tRaw::new(READ_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst READ_RESPONSE: &[u8] = b\"FEReHoeBKU17X2bBpVAd1iUvktFL43CDu0cFYHdaP9\";\n#[read]\nfn read(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(READ_RESPONSE, TEXT_PLAIN)\n}\n\nconst SEARCH_RESPONSE: &[u8] = b\"AWqcQUdBRHXKh3at4u79mdupOAfEbnTcx71ogCVF0E\";\n#[search]\nfn search(_body: FooSearch) -> Raw<&'static [u8]> {\n\tRaw::new(SEARCH_RESPONSE, TEXT_PLAIN)\n}\n\nconst CREATE_RESPONSE: &[u8] = b\"y6POY7wOMAB0jBRBw0FJT7DOpUNbhmT8KdpQPLkI83\";\n#[create]\nfn create(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(CREATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_ALL_RESPONSE: &[u8] = b\"QlbYg8gHE9OQvvk3yKjXJLTSXlIrg9mcqhfMXJmQkv\";\n#[update_all]\nfn update_all(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_RESPONSE: &[u8] = b\"qGod55RUXkT1lgPO8h0uVM6l368O2S0GrwENZFFuRu\";\n#[update]\nfn update(_id: u64, _body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_ALL_RESPONSE: &[u8] = b\"Y36kZ749MRk2Nem4BedJABOZiZWPLOtiwLfJlGTwm5\";\n#[delete_all]\nfn delete_all() -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_RESPONSE: &[u8] = b\"CwRzBrKErsVZ1N7yeNfjZuUn1MacvgBqk4uPOFfDDq\";\n#[delete]\nfn delete(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_RESPONSE, TEXT_PLAIN)\n}\n\n#[test]\nfn sync_methods() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.resource::<FooResource>(\"foo\");\n\t}))\n\t.unwrap();\n\n\ttest_get_response(&server, \"http://localhost/foo\", READ_ALL_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/1\", READ_RESPONSE);\n\ttest_get_response(\n\t\t&server,\n\t\t\"http://localhost/foo/search?query=hello+world\",\n\t\tSEARCH_RESPONSE\n\t);\n\ttest_post_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tCREATE_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_ALL_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo/1\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_RESPONSE\n\t);\n\ttest_delete_response(&server, \"http://localhost/foo\", DELETE_ALL_RESPONSE);\n\ttest_delete_response(&server, \"http://localhost/foo/1\", DELETE_RESPONSE);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","trybuild_ui.rs"],"content":"use trybuild::TestCases;\n\n#[test]\n#[ignore]\nfn trybuild_ui() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/ui/endpoint/*.rs\");\n\tt.compile_fail(\"tests/ui/from_body/*.rs\");\n\tt.compile_fail(\"tests/ui/resource/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","async_state.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham::state::State;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nasync fn read_all(state: &State) {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","auth_data_non_clone.rs"],"content":"use gotham_restful::*;\nuse serde::Deserialize;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[derive(Deserialize)]\nstruct AuthData {\n\tiat: u64,\n\texp: u64\n}\n\n#[read_all]\nasync fn read_all(auth: AuthStatus<AuthData>) -> Result<NoContent, AuthError> {\n\tauth.ok()?;\n\tOk(NoContent::default())\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_method_invalid_expr.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(method = \"I like pizza\", uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_method_invalid_type.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(method = \"String::new()\", uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_method_missing.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_uri_missing.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(method = \"gotham_restful::gotham::hyper::Method::GET\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","dynamic_schema_missing_schema.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\nuse gotham::hyper::StatusCode;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\nfn status_codes() -> Vec<StatusCode> {\n\tunimplemented!()\n}\n\n#[read_all(status_codes = \"status_codes\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","dynamic_schema_missing_status_codes.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\nuse gotham::hyper::StatusCode;\nuse gotham_restful::private::OpenapiSchema;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\nfn schema(_: StatusCode) -> OpenapiSchema {\n\tunimplemented!()\n}\n\n#[read_all(schema = \"schema\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","dynamic_schema_wrong_type.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\nfn schema(_: u16) -> String {\n\tunimplemented!()\n}\n\nfn status_codes() -> Vec<u16> {\n\tunimplemented!()\n}\n\n#[read_all(schema = \"schema\", status_codes = \"status_codes\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(FooResource)]\nfn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_body_ty.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\n#[derive(Debug)]\nstruct FooBody {\n\tfoo: String\n}\n\n#[endpoint(method = \"Method::GET\", uri = \"\", body = true)]\nfn endpoint(_: FooBody) {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_params_ty.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\n#[derive(Debug)]\nstruct FooParams {\n\tfoo: String\n}\n\n#[endpoint(method = \"Method::GET\", uri = \"\", params = true)]\nfn endpoint(_: FooParams) {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_placeholders_ty.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\n#[derive(Debug)]\nstruct FooPlaceholders {\n\tfoo: String\n}\n\n#[endpoint(method = \"Method::GET\", uri = \":foo\")]\nfn endpoint(_: FooPlaceholders) {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_return_type.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\nstruct FooResponse;\n\n#[endpoint(method = \"Method::GET\", uri = \"\")]\nfn endpoint() -> FooResponse {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_body_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(body = false)]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_method_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(method = \"gotham_restful::gotham::hyper::Method::GET\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_params_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(params = true)]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_uri_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","self.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all(self) {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","too_few_args.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read)]\nstruct FooResource;\n\n#[read]\nfn read() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","too_many_args.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all(_id: u64) {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","unknown_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(pineapple = \"on pizza\")]\nfn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","unsafe.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nunsafe fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","wants_auth_non_bool.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(wants_auth = \"yes, please\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","from_body","enum.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(FromBody)]\nenum FromBodyEnum {\n\tSomeVariant(Vec<u8>),\n\tOtherVariant(String)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","resource","unknown_method.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_any)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","util","mod.rs"],"content":"use gotham::{\n\thyper::Body,\n\ttest::TestServer\n};\nuse log::info;\nuse gotham::mime::Mime;\n#[allow(unused_imports)]\nuse std::{fs::File, io::{Read, Write}, str};\n\npub fn test_get_response(server : &TestServer, path : &str, expected : &[u8])\n{\n\tinfo!(\"GET {path}\");\n\tlet res = server.client().get(path).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\npub fn test_post_response<B>(server : &TestServer, path : &str, body : B, mime : Mime, expected : &[u8])\nwhere\n\tB : Into<Body>\n{\n\tinfo!(\"POST {path}\");\n\tlet res = server.client().post(path, body, mime).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\npub fn test_put_response<B>(server : &TestServer, path : &str, body : B, mime : Mime, expected : &[u8])\nwhere\n\tB : Into<Body>\n{\n\tinfo!(\"PUT {path}\");\n\tlet res = server.client().put(path, body, mime).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\npub fn test_delete_response(server : &TestServer, path : &str, expected : &[u8])\n{\n\tinfo!(\"DELETE {path}\");\n\tlet res = server.client().delete(path).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\n#[cfg(feature = \"openapi\")]\npub fn test_openapi_response(server : &TestServer, path : &str, output_file : &str)\n{\n\tinfo!(\"GET {path}\");\n\tlet res = server.client().get(path).perform().unwrap().read_body().unwrap();\n\tlet body: serde_json::Value = serde_json::from_slice(&res).unwrap();\n\n\tlet mut file = File::open(output_file).unwrap();\n\tlet expected: serde_json::Value = serde_json::from_reader(&mut file).unwrap();\n\n\t//eprintln!(\"{body}\");\n\tassert_eq!(body, expected);\n}\n","traces":[],"covered":0,"coverable":0}]}