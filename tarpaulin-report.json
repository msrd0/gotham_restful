{"files":[{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","endpoint.rs"],"content":"use crate::util::{CollectToResult, ExpectLit};\nuse lazy_regex::regex_is_match;\nuse paste::paste;\nuse proc_macro2::{Ident, Span, TokenStream};\nuse quote::{format_ident, quote, quote_spanned, ToTokens};\nuse std::str::FromStr;\nuse syn::{\n\tparse::Parse, spanned::Spanned, Attribute, AttributeArgs, Error, Expr, FnArg, ItemFn, LitBool, LitStr, Meta, NestedMeta,\n\tPatType, Result, ReturnType, Type\n};\n\n#[allow(clippy::large_enum_variant)]\npub enum EndpointType {\n\tReadAll,\n\tRead,\n\tSearch,\n\tCreate,\n\tUpdateAll,\n\tUpdate,\n\tDeleteAll,\n\tDelete,\n\tCustom {\n\t\tmethod: Option<Expr>,\n\t\turi: Option<LitStr>,\n\t\tparams: Option<LitBool>,\n\t\tbody: Option<LitBool>\n\t}\n}\n\nimpl EndpointType {\n\tpub fn custom() -> Self {\n\t\tSelf::Custom {\n\t\t\tmethod: None,\n\t\t\turi: None,\n\t\t\tparams: None,\n\t\t\tbody: None\n\t\t}\n\t}\n}\n\nmacro_rules! endpoint_type_setter {\n\t($name:ident : $ty:ty) => {\n\t\timpl EndpointType {\n\t\t\tpaste! {\n\t\t\t\tfn [<set_ $name>](&mut self, span: Span, [<new_ $name>]: $ty) -> Result<()> {\n\t\t\t\t\tmatch self {\n\t\t\t\t\t\tSelf::Custom { $name, .. } if $name.is_some() => {\n\t\t\t\t\t\t\tErr(Error::new(span, concat!(\"`\", concat!(stringify!($name), \"` must not appear more than once\"))))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSelf::Custom { $name, .. } => {\n\t\t\t\t\t\t\t*$name = Some([<new_ $name>]);\n\t\t\t\t\t\t\tOk(())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t_ => Err(Error::new(span, concat!(\"`\", concat!(stringify!($name), \"` can only be used on custom endpoints\"))))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nendpoint_type_setter!(method: Expr);\nendpoint_type_setter!(uri: LitStr);\nendpoint_type_setter!(params: LitBool);\nendpoint_type_setter!(body: LitBool);\n\nimpl FromStr for EndpointType {\n\ttype Err = Error;\n\n\tfn from_str(str: &str) -> Result<Self> {\n\t\tmatch str {\n\t\t\t\"ReadAll\" | \"read_all\" => Ok(Self::ReadAll),\n\t\t\t\"Read\" | \"read\" => Ok(Self::Read),\n\t\t\t\"Search\" | \"search\" => Ok(Self::Search),\n\t\t\t\"Create\" | \"create\" => Ok(Self::Create),\n\t\t\t\"ChangeAll\" | \"change_all\" => Ok(Self::UpdateAll),\n\t\t\t\"Change\" | \"change\" => Ok(Self::Update),\n\t\t\t\"RemoveAll\" | \"remove_all\" => Ok(Self::DeleteAll),\n\t\t\t\"Remove\" | \"remove\" => Ok(Self::Delete),\n\t\t\t_ => Err(Error::new(Span::call_site(), format!(\"Unknown method: `{}'\", str)))\n\t\t}\n\t}\n}\n\nimpl EndpointType {\n\tfn http_method(&self) -> Option<TokenStream> {\n\t\tlet hyper_method = quote!(::gotham_restful::gotham::hyper::Method);\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Read | Self::Search => Some(quote!(#hyper_method::GET)),\n\t\t\tSelf::Create => Some(quote!(#hyper_method::POST)),\n\t\t\tSelf::UpdateAll | Self::Update => Some(quote!(#hyper_method::PUT)),\n\t\t\tSelf::DeleteAll | Self::Delete => Some(quote!(#hyper_method::DELETE)),\n\t\t\tSelf::Custom { method, .. } => method.as_ref().map(ToTokens::to_token_stream)\n\t\t}\n\t}\n\n\tfn uri(&self) -> Option<TokenStream> {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Create | Self::UpdateAll | Self::DeleteAll => Some(quote!(\"\")),\n\t\t\tSelf::Read | Self::Update | Self::Delete => Some(quote!(\":id\")),\n\t\t\tSelf::Search => Some(quote!(\"search\")),\n\t\t\tSelf::Custom { uri, .. } => uri.as_ref().map(ToTokens::to_token_stream)\n\t\t}\n\t}\n\n\tfn operation_verb(&self) -> TokenStream {\n\t\tlet some = quote!(::core::option::Option::Some);\n\t\tmatch self {\n\t\t\tSelf::ReadAll => quote!(#some(\"read_all\")),\n\t\t\tSelf::Read => quote!(#some(\"read\")),\n\t\t\tSelf::Search => quote!(#some(\"search\")),\n\t\t\tSelf::Create => quote!(#some(\"create\")),\n\t\t\tSelf::UpdateAll => quote!(#some(\"update_all\")),\n\t\t\tSelf::Update => quote!(#some(\"update\")),\n\t\t\tSelf::DeleteAll => quote!(#some(\"delete_all\")),\n\t\t\tSelf::Delete => quote!(#some(\"delete\")),\n\t\t\tSelf::Custom { .. } => quote!(::core::option::Option::None)\n\t\t}\n\t}\n\n\tfn has_placeholders(&self) -> LitBool {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Search | Self::Create | Self::UpdateAll | Self::DeleteAll => LitBool {\n\t\t\t\tvalue: false,\n\t\t\t\tspan: Span::call_site()\n\t\t\t},\n\t\t\tSelf::Read | Self::Update | Self::Delete => LitBool {\n\t\t\t\tvalue: true,\n\t\t\t\tspan: Span::call_site()\n\t\t\t},\n\t\t\tSelf::Custom { uri, .. } => LitBool {\n\t\t\t\tvalue: uri\n\t\t\t\t\t.as_ref()\n\t\t\t\t\t.map(|uri| regex_is_match!(r#\"(^|/):[^/]+(/|$)\"#, &uri.value()))\n\t\t\t\t\t.unwrap_or(false),\n\t\t\t\tspan: Span::call_site()\n\t\t\t}\n\t\t}\n\t}\n\n\tfn placeholders_ty(&self, arg_ty: Option<&Type>) -> TokenStream {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Search | Self::Create | Self::UpdateAll | Self::DeleteAll => {\n\t\t\t\tquote!(::gotham_restful::NoopExtractor)\n\t\t\t},\n\t\t\tSelf::Read | Self::Update | Self::Delete => quote!(::gotham_restful::private::IdPlaceholder::<#arg_ty>),\n\t\t\tSelf::Custom { .. } => {\n\t\t\t\tif self.has_placeholders().value {\n\t\t\t\t\targ_ty.to_token_stream()\n\t\t\t\t} else {\n\t\t\t\t\tquote!(::gotham_restful::NoopExtractor)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\tfn needs_params(&self) -> LitBool {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Read | Self::Create | Self::UpdateAll | Self::Update | Self::DeleteAll | Self::Delete => {\n\t\t\t\tLitBool {\n\t\t\t\t\tvalue: false,\n\t\t\t\t\tspan: Span::call_site()\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::Search => LitBool {\n\t\t\t\tvalue: true,\n\t\t\t\tspan: Span::call_site()\n\t\t\t},\n\t\t\tSelf::Custom { params, .. } => params.clone().unwrap_or_else(|| LitBool {\n\t\t\t\tvalue: false,\n\t\t\t\tspan: Span::call_site()\n\t\t\t})\n\t\t}\n\t}\n\n\tfn params_ty(&self, arg_ty: Option<&Type>) -> TokenStream {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Read | Self::Create | Self::UpdateAll | Self::Update | Self::DeleteAll | Self::Delete => {\n\t\t\t\tquote!(::gotham_restful::NoopExtractor)\n\t\t\t},\n\t\t\tSelf::Search => quote!(#arg_ty),\n\t\t\tSelf::Custom { .. } => {\n\t\t\t\tif self.needs_params().value {\n\t\t\t\t\targ_ty.to_token_stream()\n\t\t\t\t} else {\n\t\t\t\t\tquote!(::gotham_restful::NoopExtractor)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\tfn needs_body(&self) -> LitBool {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Read | Self::Search | Self::DeleteAll | Self::Delete => LitBool {\n\t\t\t\tvalue: false,\n\t\t\t\tspan: Span::call_site()\n\t\t\t},\n\t\t\tSelf::Create | Self::UpdateAll | Self::Update => LitBool {\n\t\t\t\tvalue: true,\n\t\t\t\tspan: Span::call_site()\n\t\t\t},\n\t\t\tSelf::Custom { body, .. } => body.clone().unwrap_or_else(|| LitBool {\n\t\t\t\tvalue: false,\n\t\t\t\tspan: Span::call_site()\n\t\t\t})\n\t\t}\n\t}\n\n\tfn body_ty(&self, arg_ty: Option<&Type>) -> TokenStream {\n\t\tmatch self {\n\t\t\tSelf::ReadAll | Self::Read | Self::Search | Self::DeleteAll | Self::Delete => quote!(()),\n\t\t\tSelf::Create | Self::UpdateAll | Self::Update => quote!(#arg_ty),\n\t\t\tSelf::Custom { .. } => {\n\t\t\t\tif self.needs_body().value {\n\t\t\t\t\targ_ty.to_token_stream()\n\t\t\t\t} else {\n\t\t\t\t\tquote!(())\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n}\n\n#[allow(clippy::large_enum_variant)]\nenum HandlerArgType {\n\tStateRef,\n\tStateMutRef,\n\tMethodArg(Type),\n\tDatabaseConnection(Type),\n\tAuthStatus(Type),\n\tAuthStatusRef(Type)\n}\n\nimpl HandlerArgType {\n\tfn is_method_arg(&self) -> bool {\n\t\tmatches!(self, Self::MethodArg(_))\n\t}\n\n\tfn is_database_conn(&self) -> bool {\n\t\tmatches!(self, Self::DatabaseConnection(_))\n\t}\n\n\tfn is_auth_status(&self) -> bool {\n\t\tmatches!(self, Self::AuthStatus(_) | Self::AuthStatusRef(_))\n\t}\n\n\tfn ty(&self) -> Option<&Type> {\n\t\tmatch self {\n\t\t\tSelf::MethodArg(ty) | Self::DatabaseConnection(ty) | Self::AuthStatus(ty) | Self::AuthStatusRef(ty) => Some(ty),\n\t\t\t_ => None\n\t\t}\n\t}\n\n\tfn quote_ty(&self) -> Option<TokenStream> {\n\t\tself.ty().map(|ty| quote!(#ty))\n\t}\n}\n\nstruct HandlerArg {\n\tident_span: Span,\n\tty: HandlerArgType\n}\n\nimpl Spanned for HandlerArg {\n\tfn span(&self) -> Span {\n\t\tself.ident_span\n\t}\n}\n\nfn interpret_arg_ty(attrs: &[Attribute], name: &str, ty: Type) -> Result<HandlerArgType> {\n\tlet attr = attrs\n\t\t.iter()\n\t\t.find(|arg| arg.path.segments.iter().any(|path| &path.ident.to_string() == \"rest_arg\"))\n\t\t.map(|arg| arg.tokens.to_string());\n\n\t// TODO issue a warning for _state usage once diagnostics become stable\n\tif attr.as_deref() == Some(\"state\") || (attr.is_none() && (name == \"state\" || name == \"_state\")) {\n\t\treturn match ty {\n\t\t\tType::Reference(ty) => Ok(if ty.mutability.is_none() {\n\t\t\t\tHandlerArgType::StateRef\n\t\t\t} else {\n\t\t\t\tHandlerArgType::StateMutRef\n\t\t\t}),\n\t\t\t_ => Err(Error::new(\n\t\t\t\tty.span(),\n\t\t\t\t\"The state parameter has to be a (mutable) reference to gotham_restful::State\"\n\t\t\t))\n\t\t};\n\t}\n\n\tif cfg!(feature = \"auth\") && (attr.as_deref() == Some(\"auth\") || (attr.is_none() && name == \"auth\")) {\n\t\treturn Ok(match ty {\n\t\t\tType::Reference(ty) => HandlerArgType::AuthStatusRef(*ty.elem),\n\t\t\tty => HandlerArgType::AuthStatus(ty)\n\t\t});\n\t}\n\n\tif cfg!(feature = \"database\")\n\t\t&& (attr.as_deref() == Some(\"connection\") || attr.as_deref() == Some(\"conn\") || (attr.is_none() && name == \"conn\"))\n\t{\n\t\treturn Ok(HandlerArgType::DatabaseConnection(match ty {\n\t\t\tType::Reference(ty) => *ty.elem,\n\t\t\tty => ty\n\t\t}));\n\t}\n\n\tOk(HandlerArgType::MethodArg(ty))\n}\n\nfn interpret_arg(_index: usize, arg: &PatType) -> Result<HandlerArg> {\n\tlet pat = &arg.pat;\n\tlet orig_name = quote!(#pat);\n\tlet ty = interpret_arg_ty(&arg.attrs, &orig_name.to_string(), *arg.ty.clone())?;\n\n\tOk(HandlerArg {\n\t\tident_span: arg.pat.span(),\n\t\tty\n\t})\n}\n\n#[cfg(feature = \"openapi\")]\nfn expand_operation_verb(operation_verb: TokenStream) -> Option<TokenStream> {\n\tSome(quote! {\n\t\tfn operation_verb() -> ::core::option::Option<&'static ::core::primitive::str> {\n\t\t\t#operation_verb\n\t\t}\n\t})\n}\n\n#[cfg(not(feature = \"openapi\"))]\nfn expand_operation_verb(_: TokenStream) -> Option<TokenStream> {\n\tNone\n}\n\n#[cfg(feature = \"openapi\")]\nfn expand_operation_id(operation_id: Option<LitStr>) -> Option<TokenStream> {\n\toperation_id.map(|operation_id| {\n\t\tquote! {\n\t\t\tfn operation_id() -> ::core::option::Option<::std::string::String> {\n\t\t\t\t::core::option::Option::Some(::std::string::String::from(#operation_id))\n\t\t\t}\n\t\t}\n\t})\n}\n\n#[cfg(not(feature = \"openapi\"))]\nfn expand_operation_id(_: Option<LitStr>) -> Option<TokenStream> {\n\tNone\n}\n\nfn expand_wants_auth(wants_auth: Option<LitBool>, default: bool) -> TokenStream {\n\tlet wants_auth = wants_auth.unwrap_or_else(|| LitBool {\n\t\tvalue: default,\n\t\tspan: Span::call_site()\n\t});\n\n\tquote! {\n\t\tfn wants_auth() -> ::core::primitive::bool {\n\t\t\t#wants_auth\n\t\t}\n\t}\n}\n\npub fn endpoint_ident(fn_ident: &Ident) -> Ident {\n\tformat_ident!(\"{}___gotham_restful_endpoint\", fn_ident)\n}\n\n// clippy doesn't realize that vectors can be used in closures\n#[cfg_attr(feature = \"cargo-clippy\", allow(clippy::needless_collect))]\nfn expand_endpoint_type(mut ty: EndpointType, attrs: AttributeArgs, fun: &ItemFn) -> Result<TokenStream> {\n\t// reject unsafe functions\n\tif let Some(unsafety) = fun.sig.unsafety {\n\t\treturn Err(Error::new(unsafety.span(), \"Endpoint handler methods must not be unsafe\"));\n\t}\n\n\t// parse arguments\n\tlet mut debug: bool = false;\n\tlet mut operation_id: Option<LitStr> = None;\n\tlet mut wants_auth: Option<LitBool> = None;\n\tfor meta in attrs {\n\t\tmatch meta {\n\t\t\tNestedMeta::Meta(Meta::NameValue(kv)) => {\n\t\t\t\tif kv.path.is_ident(\"debug\") {\n\t\t\t\t\tdebug = kv.lit.expect_bool()?.value;\n\t\t\t\t} else if kv.path.is_ident(\"operation_id\") {\n\t\t\t\t\toperation_id = Some(kv.lit.expect_str()?);\n\t\t\t\t} else if kv.path.is_ident(\"wants_auth\") {\n\t\t\t\t\twants_auth = Some(kv.lit.expect_bool()?);\n\t\t\t\t} else if kv.path.is_ident(\"method\") {\n\t\t\t\t\tty.set_method(kv.path.span(), kv.lit.expect_str()?.parse_with(Expr::parse)?)?;\n\t\t\t\t} else if kv.path.is_ident(\"uri\") {\n\t\t\t\t\tty.set_uri(kv.path.span(), kv.lit.expect_str()?)?;\n\t\t\t\t} else if kv.path.is_ident(\"params\") {\n\t\t\t\t\tty.set_params(kv.path.span(), kv.lit.expect_bool()?)?;\n\t\t\t\t} else if kv.path.is_ident(\"body\") {\n\t\t\t\t\tty.set_body(kv.path.span(), kv.lit.expect_bool()?)?;\n\t\t\t\t} else {\n\t\t\t\t\treturn Err(Error::new(kv.path.span(), \"Unknown attribute\"));\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => return Err(Error::new(meta.span(), \"Invalid attribute syntax\"))\n\t\t}\n\t}\n\t#[cfg(not(feature = \"openapi\"))]\n\tif let Some(operation_id) = operation_id {\n\t\treturn Err(Error::new(\n\t\t\toperation_id.span(),\n\t\t\t\"`operation_id` is only supported with the openapi feature\"\n\t\t));\n\t}\n\n\t// extract the documentation\n\tlet mut doc: Vec<String> = Vec::new();\n\tfor attr in &fun.attrs {\n\t\tif attr.path.is_ident(\"doc\") {\n\t\t\tif let Some(lit) = attr.parse_meta().and_then(|meta| {\n\t\t\t\tOk(match meta {\n\t\t\t\t\tMeta::NameValue(kv) => Some(kv.lit.expect_str()?),\n\t\t\t\t\t_ => None\n\t\t\t\t})\n\t\t\t})? {\n\t\t\t\tdoc.push(lit.value());\n\t\t\t}\n\t\t}\n\t}\n\tlet doc = doc.join(\"\\n\");\n\t#[allow(unused_variables)]\n\tlet doc = doc.trim();\n\n\t#[allow(unused_mut)]\n\tlet mut description = quote!();\n\t#[cfg(feature = \"openapi\")]\n\tif !doc.is_empty() {\n\t\tdescription = quote! {\n\t\t\tfn description() -> ::core::option::Option<::std::string::String> {\n\t\t\t\t::core::option::Option::Some(::std::string::String::from(#doc))\n\t\t\t}\n\t\t};\n\t}\n\n\t// extract arguments into pattern, ident and type\n\tlet args = fun\n\t\t.sig\n\t\t.inputs\n\t\t.iter()\n\t\t.enumerate()\n\t\t.map(|(i, arg)| match arg {\n\t\t\tFnArg::Typed(arg) => interpret_arg(i, arg),\n\t\t\tFnArg::Receiver(_) => Err(Error::new(arg.span(), \"Didn't expect self parameter\"))\n\t\t})\n\t\t.collect_to_result()?;\n\n\tlet fun_vis = &fun.vis;\n\tlet fun_ident = &fun.sig.ident;\n\tlet fun_is_async = fun.sig.asyncness.is_some();\n\n\tlet ident = endpoint_ident(fun_ident);\n\tlet dummy_ident = format_ident!(\"_IMPL_Endpoint_for_{}\", ident);\n\tlet (output_ty, is_no_content) = match &fun.sig.output {\n\t\tReturnType::Default => (quote!(::gotham_restful::NoContent), true),\n\t\tReturnType::Type(_, ty) => (quote!(#ty), false)\n\t};\n\tlet output_typedef = quote_spanned!(output_ty.span() => type Output = #output_ty;);\n\n\tlet arg_tys = args.iter().filter(|arg| arg.ty.is_method_arg()).collect::<Vec<_>>();\n\tlet mut arg_ty_idx = 0;\n\tlet mut next_arg_ty = |return_none: bool| {\n\t\tif return_none {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tif arg_ty_idx >= arg_tys.len() {\n\t\t\treturn Err(Error::new(fun_ident.span(), \"Too few arguments\"));\n\t\t}\n\t\tlet ty = arg_tys[arg_ty_idx].ty.ty().unwrap();\n\t\targ_ty_idx += 1;\n\t\tOk(Some(ty))\n\t};\n\n\tlet http_method = ty.http_method().ok_or_else(|| {\n\t\tError::new(\n\t\t\tSpan::call_site(),\n\t\t\t\"Missing `method` attribute (e.g. `#[endpoint(method = \\\"gotham_restful::gotham::hyper::Method::GET\\\")]`)\"\n\t\t)\n\t})?;\n\tlet uri = ty.uri().ok_or_else(|| {\n\t\tError::new(\n\t\t\tSpan::call_site(),\n\t\t\t\"Missing `uri` attribute (e.g. `#[endpoint(uri = \\\"custom_endpoint\\\")]`)\"\n\t\t)\n\t})?;\n\tlet has_placeholders = ty.has_placeholders();\n\tlet placeholder_ty = ty.placeholders_ty(next_arg_ty(!has_placeholders.value)?);\n\tlet placeholder_typedef = quote_spanned!(placeholder_ty.span() => type Placeholders = #placeholder_ty;);\n\tlet needs_params = ty.needs_params();\n\tlet params_ty = ty.params_ty(next_arg_ty(!needs_params.value)?);\n\tlet params_typedef = quote_spanned!(params_ty.span() => type Params = #params_ty;);\n\tlet needs_body = ty.needs_body();\n\tlet body_ty = ty.body_ty(next_arg_ty(!needs_body.value)?);\n\tlet body_typedef = quote_spanned!(body_ty.span() => type Body = #body_ty;);\n\n\tif arg_ty_idx < arg_tys.len() {\n\t\treturn Err(Error::new(fun_ident.span(), \"Too many arguments\"));\n\t}\n\n\tlet mut handle_args: Vec<TokenStream> = Vec::new();\n\tif has_placeholders.value {\n\t\tif matches!(ty, EndpointType::Custom { .. }) {\n\t\t\thandle_args.push(quote!(placeholders));\n\t\t} else {\n\t\t\thandle_args.push(quote!(placeholders.id));\n\t\t}\n\t}\n\tif needs_params.value {\n\t\thandle_args.push(quote!(params));\n\t}\n\tif needs_body.value {\n\t\thandle_args.push(quote!(body.unwrap()));\n\t}\n\tlet handle_args = args.iter().map(|arg| match arg.ty {\n\t\tHandlerArgType::StateRef | HandlerArgType::StateMutRef => quote!(state),\n\t\tHandlerArgType::MethodArg(_) => handle_args.remove(0),\n\t\tHandlerArgType::DatabaseConnection(_) => quote!(&conn),\n\t\tHandlerArgType::AuthStatus(_) => quote!(auth),\n\t\tHandlerArgType::AuthStatusRef(_) => quote!(&auth)\n\t});\n\n\tlet expand_handle_content = || {\n\t\tlet mut state_block = quote!();\n\t\tif let Some(arg) = args.iter().find(|arg| arg.ty.is_auth_status()) {\n\t\t\tlet auth_ty = arg.ty.quote_ty();\n\t\t\tlet auth_borrow = quote_spanned! { auth_ty.span() =>\n\t\t\t\t<#auth_ty as ::core::clone::Clone>::clone(\n\t\t\t\t\t<#auth_ty as ::gotham_restful::gotham::state::FromState>::borrow_from(state)\n\t\t\t\t)\n\t\t\t};\n\t\t\tstate_block = quote! {\n\t\t\t\t#state_block\n\t\t\t\tlet auth: #auth_ty = #auth_borrow;\n\t\t\t}\n\t\t}\n\n\t\tlet mut handle_content = quote!(#fun_ident(#(#handle_args),*));\n\t\tif fun_is_async {\n\t\t\tif let Some(arg) = args.iter().find(|arg| matches!(arg.ty, HandlerArgType::StateRef)) {\n\t\t\t\treturn Err(Error::new(arg.span(), \"Endpoint handler functions that are async must not take `&State` as an argument, consider taking `&mut State`\"));\n\t\t\t}\n\t\t\thandle_content = quote!(#handle_content.await);\n\t\t}\n\t\tif is_no_content {\n\t\t\thandle_content = quote!(#handle_content; <::gotham_restful::NoContent as ::std::default::Default>::default())\n\t\t}\n\n\t\tif let Some(arg) = args.iter().find(|arg| arg.ty.is_database_conn()) {\n\t\t\tlet conn_ty = arg.ty.quote_ty();\n\t\t\tstate_block = quote! {\n\t\t\t\t#state_block\n\t\t\t\tlet repo = <::gotham_restful::private::Repo<#conn_ty>>::borrow_from(state).clone();\n\t\t\t};\n\t\t\thandle_content = quote! {\n\t\t\t\trepo.run::<_, _, ()>(move |conn| {\n\t\t\t\t\tOk({ #handle_content })\n\t\t\t\t}).await.unwrap()\n\t\t\t};\n\t\t}\n\n\t\tOk(quote! {\n\t\t\tuse ::gotham_restful::private::FutureExt as _;\n\t\t\tuse ::gotham_restful::gotham::state::FromState as _;\n\t\t\t#state_block\n\t\t\tasync move {\n\t\t\t\t#handle_content\n\t\t\t}.boxed()\n\t\t})\n\t};\n\tlet handle_content = match expand_handle_content() {\n\t\tOk(content) => content,\n\t\tErr(err) => err.to_compile_error()\n\t};\n\n\tlet tr8 = if cfg!(feature = \"openapi\") {\n\t\tquote!(::gotham_restful::EndpointWithSchema)\n\t} else {\n\t\tquote!(::gotham_restful::Endpoint)\n\t};\n\tlet operation_verb = expand_operation_verb(ty.operation_verb());\n\tlet operation_id = expand_operation_id(operation_id);\n\tlet wants_auth = expand_wants_auth(wants_auth, args.iter().any(|arg| arg.ty.is_auth_status()));\n\tlet code = quote! {\n\t\t#[doc(hidden)]\n\t\t/// `gotham_restful` implementation detail\n\t\t#[allow(non_camel_case_types)]\n\t\t#fun_vis struct #ident;\n\n\t\t#[allow(non_upper_case_globals)]\n\t\tstatic #dummy_ident: () = {\n\t\t\timpl #tr8 for #ident {\n\t\t\t\tfn http_method() -> ::gotham_restful::gotham::hyper::Method {\n\t\t\t\t\t#http_method\n\t\t\t\t}\n\n\t\t\t\tfn uri() -> ::std::borrow::Cow<'static, ::core::primitive::str> {\n\t\t\t\t\t{ #uri }.into()\n\t\t\t\t}\n\n\t\t\t\t#operation_verb\n\n\t\t\t\t#output_typedef\n\n\t\t\t\tfn has_placeholders() -> ::core::primitive::bool {\n\t\t\t\t\t#has_placeholders\n\t\t\t\t}\n\t\t\t\t#placeholder_typedef\n\n\t\t\t\tfn needs_params() -> ::core::primitive::bool {\n\t\t\t\t\t#needs_params\n\t\t\t\t}\n\t\t\t\t#params_typedef\n\n\t\t\t\tfn needs_body() -> ::core::primitive::bool {\n\t\t\t\t\t#needs_body\n\t\t\t\t}\n\t\t\t\t#body_typedef\n\n\t\t\t\tfn handle<'a>(\n\t\t\t\t\tstate: &'a mut ::gotham_restful::gotham::state::State,\n\t\t\t\t\tplaceholders: Self::Placeholders,\n\t\t\t\t\tparams: Self::Params,\n\t\t\t\t\tbody: ::core::option::Option<Self::Body>\n\t\t\t\t) -> ::gotham_restful::private::BoxFuture<'a, Self::Output> {\n\t\t\t\t\t#handle_content\n\t\t\t\t}\n\n\t\t\t\t#operation_id\n\t\t\t\t#description\n\t\t\t\t#wants_auth\n\t\t\t}\n\t\t};\n\t};\n\tif debug {\n\t\teprintln!(\"{}\", code);\n\t}\n\tOk(code)\n}\n\npub fn expand_endpoint(ty: EndpointType, attrs: AttributeArgs, fun: ItemFn) -> Result<TokenStream> {\n\tlet endpoint_type = match expand_endpoint_type(ty, attrs, &fun) {\n\t\tOk(code) => code,\n\t\tErr(err) => err.to_compile_error()\n\t};\n\tOk(quote! {\n\t\t#fun\n\t\t#endpoint_type\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","from_body.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::{format_ident, quote};\nuse std::cmp::min;\nuse syn::{spanned::Spanned, Data, DeriveInput, Error, Field, Fields, Ident, Result, Type};\n\nstruct ParsedFields {\n\tfields: Vec<(Ident, Type)>,\n\tnamed: bool\n}\n\nimpl ParsedFields {\n\tfn from_named<I>(fields: I) -> Self\n\twhere\n\t\tI: Iterator<Item = Field>\n\t{\n\t\tlet fields = fields.map(|field| (field.ident.unwrap(), field.ty)).collect();\n\t\tSelf { fields, named: true }\n\t}\n\n\tfn from_unnamed<I>(fields: I) -> Self\n\twhere\n\t\tI: Iterator<Item = Field>\n\t{\n\t\tlet fields = fields\n\t\t\t.enumerate()\n\t\t\t.map(|(i, field)| (format_ident!(\"arg{}\", i), field.ty))\n\t\t\t.collect();\n\t\tSelf { fields, named: false }\n\t}\n\n\tfn from_unit() -> Self {\n\t\tSelf {\n\t\t\tfields: Vec::new(),\n\t\t\tnamed: false\n\t\t}\n\t}\n}\n\npub fn expand_from_body(input: DeriveInput) -> Result<TokenStream> {\n\tlet ident = input.ident;\n\tlet generics = input.generics;\n\n\tlet strukt = match input.data {\n\t\tData::Enum(inum) => Err(inum.enum_token.span()),\n\t\tData::Struct(strukt) => Ok(strukt),\n\t\tData::Union(uni) => Err(uni.union_token.span())\n\t}\n\t.map_err(|span| Error::new(span, \"#[derive(FromBody)] only works for structs\"))?;\n\n\tlet fields = match strukt.fields {\n\t\tFields::Named(named) => ParsedFields::from_named(named.named.into_iter()),\n\t\tFields::Unnamed(unnamed) => ParsedFields::from_unnamed(unnamed.unnamed.into_iter()),\n\t\tFields::Unit => ParsedFields::from_unit()\n\t};\n\n\tlet mut where_clause = quote!();\n\tlet mut block = quote!();\n\tlet mut body_ident = format_ident!(\"_body\");\n\tlet mut type_ident = format_ident!(\"_type\");\n\n\tif let Some(body_field) = fields.fields.get(0) {\n\t\tbody_ident = body_field.0.clone();\n\t\tlet body_ty = &body_field.1;\n\t\twhere_clause = quote! {\n\t\t\t#where_clause\n\t\t\t#body_ty: for<'a> From<&'a [u8]>,\n\t\t};\n\t\tblock = quote! {\n\t\t\t#block\n\t\t\tlet #body_ident: &[u8] = &#body_ident;\n\t\t\tlet #body_ident: #body_ty = #body_ident.into();\n\t\t};\n\t}\n\n\tif let Some(type_field) = fields.fields.get(1) {\n\t\ttype_ident = type_field.0.clone();\n\t\tlet type_ty = &type_field.1;\n\t\twhere_clause = quote! {\n\t\t\t#where_clause\n\t\t\t#type_ty: From<::gotham_restful::Mime>,\n\t\t};\n\t\tblock = quote! {\n\t\t\t#block\n\t\t\tlet #type_ident: #type_ty = #type_ident.into();\n\t\t};\n\t}\n\n\tfor field in &fields.fields[min(2, fields.fields.len())..] {\n\t\tlet field_ident = &field.0;\n\t\tlet field_ty = &field.1;\n\t\twhere_clause = quote! {\n\t\t\t#where_clause\n\t\t\t#field_ty: ::std::default::Default,\n\t\t};\n\t\tblock = quote! {\n\t\t\t#block\n\t\t\tlet #field_ident: #field_ty = Default::default();\n\t\t};\n\t}\n\n\tlet field_names: Vec<&Ident> = fields.fields.iter().map(|field| &field.0).collect();\n\tlet ctor = if fields.named {\n\t\tquote!(Self { #(#field_names),* })\n\t} else {\n\t\tquote!(Self ( #(#field_names),* ))\n\t};\n\n\tOk(quote! {\n\t\timpl #generics ::gotham_restful::FromBody for #ident #generics\n\t\twhere #where_clause\n\t\t{\n\t\t\ttype Err = ::std::convert::Infallible;\n\n\t\t\tfn from_body(\n\t\t\t\t#body_ident: ::gotham_restful::gotham::hyper::body::Bytes,\n\t\t\t\t#type_ident: ::gotham_restful::Mime\n\t\t\t) -> ::std::result::Result<Self, ::std::convert::Infallible>\n\t\t\t{\n\t\t\t\t#block\n\t\t\t\t::std::result::Result::Ok(#ctor)\n\t\t\t}\n\t\t}\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse syn::{parse_macro_input, parse_macro_input::ParseMacroInput, DeriveInput, Result};\n\nmod util;\n\nmod endpoint;\nuse endpoint::{expand_endpoint, EndpointType};\n\nmod from_body;\nuse from_body::expand_from_body;\n\nmod request_body;\nuse request_body::expand_request_body;\n\nmod resource;\nuse resource::expand_resource;\n\nmod resource_error;\nuse resource_error::expand_resource_error;\n\nmod private_openapi_trait;\nuse private_openapi_trait::expand_private_openapi_trait;\n\n#[inline]\nfn print_tokens(tokens: TokenStream2) -> TokenStream {\n\t// eprintln!(\"{}\", tokens);\n\ttokens.into()\n}\n\n#[inline]\nfn expand_derive<F>(input: TokenStream, expand: F) -> TokenStream\nwhere\n\tF: FnOnce(DeriveInput) -> Result<TokenStream2>\n{\n\tprint_tokens(expand(parse_macro_input!(input)).unwrap_or_else(|err| err.to_compile_error()))\n}\n\n#[inline]\nfn expand_macro<F, A, I>(attrs: TokenStream, item: TokenStream, expand: F) -> TokenStream\nwhere\n\tF: FnOnce(A, I) -> Result<TokenStream2>,\n\tA: ParseMacroInput,\n\tI: ParseMacroInput\n{\n\tprint_tokens(expand(parse_macro_input!(attrs), parse_macro_input!(item)).unwrap_or_else(|err| err.to_compile_error()))\n}\n\n#[proc_macro_derive(FromBody)]\npub fn derive_from_body(input: TokenStream) -> TokenStream {\n\texpand_derive(input, expand_from_body)\n}\n\n#[proc_macro_derive(RequestBody, attributes(supported_types))]\npub fn derive_request_body(input: TokenStream) -> TokenStream {\n\texpand_derive(input, expand_request_body)\n}\n\n#[proc_macro_derive(Resource, attributes(resource))]\npub fn derive_resource(input: TokenStream) -> TokenStream {\n\texpand_derive(input, expand_resource)\n}\n\n#[proc_macro_derive(ResourceError, attributes(display, from, status))]\npub fn derive_resource_error(input: TokenStream) -> TokenStream {\n\texpand_derive(input, expand_resource_error)\n}\n\n#[proc_macro_attribute]\npub fn endpoint(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::custom(), attr, item))\n}\n\n#[proc_macro_attribute]\npub fn read_all(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::ReadAll, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn read(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::Read, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn search(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::Search, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn create(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::Create, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn update_all(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::UpdateAll, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn update(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::Update, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn delete_all(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::DeleteAll, attr, item))\n}\n\n#[proc_macro_attribute]\npub fn delete(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, |attr, item| expand_endpoint(EndpointType::Delete, attr, item))\n}\n\n/// PRIVATE MACRO - DO NOT USE\n#[doc(hidden)]\n#[proc_macro_attribute]\npub fn _private_openapi_trait(attr: TokenStream, item: TokenStream) -> TokenStream {\n\texpand_macro(attr, item, expand_private_openapi_trait)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","private_openapi_trait.rs"],"content":"use crate::util::{remove_parens, CollectToResult};\nuse proc_macro2::{Span, TokenStream};\nuse quote::{quote, ToTokens};\nuse syn::{\n\tparse::Parse, spanned::Spanned, Attribute, AttributeArgs, Error, ItemTrait, LitStr, Meta, NestedMeta, PredicateType,\n\tResult, TraitItem, WherePredicate\n};\n\nstruct TraitItemAttrs {\n\topenapi_only: bool,\n\topenapi_bound: Vec<PredicateType>,\n\tnon_openapi_bound: Vec<PredicateType>,\n\tother_attrs: Vec<Attribute>\n}\n\nimpl TraitItemAttrs {\n\tfn parse(attrs: Vec<Attribute>) -> Result<Self> {\n\t\tlet mut openapi_only = false;\n\t\tlet mut openapi_bound = Vec::new();\n\t\tlet mut non_openapi_bound = Vec::new();\n\t\tlet mut other = Vec::new();\n\n\t\tfor attr in attrs {\n\t\t\tif attr.path.is_ident(\"openapi_only\") {\n\t\t\t\topenapi_only = true;\n\t\t\t} else if attr.path.is_ident(\"openapi_bound\") {\n\t\t\t\tlet attr_arg: LitStr = syn::parse2(remove_parens(attr.tokens))?;\n\t\t\t\tlet predicate = attr_arg.parse_with(WherePredicate::parse)?;\n\t\t\t\topenapi_bound.push(match predicate {\n\t\t\t\t\tWherePredicate::Type(ty) => ty,\n\t\t\t\t\t_ => return Err(Error::new(predicate.span(), \"Expected type bound\"))\n\t\t\t\t});\n\t\t\t} else if attr.path.is_ident(\"non_openapi_bound\") {\n\t\t\t\tlet attr_arg: LitStr = syn::parse2(remove_parens(attr.tokens))?;\n\t\t\t\tlet predicate = attr_arg.parse_with(WherePredicate::parse)?;\n\t\t\t\tnon_openapi_bound.push(match predicate {\n\t\t\t\t\tWherePredicate::Type(ty) => ty,\n\t\t\t\t\t_ => return Err(Error::new(predicate.span(), \"Expected type bound\"))\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tother.push(attr);\n\t\t\t}\n\t\t}\n\n\t\tOk(Self {\n\t\t\topenapi_only,\n\t\t\topenapi_bound,\n\t\t\tnon_openapi_bound,\n\t\t\tother_attrs: other\n\t\t})\n\t}\n}\n\npub(crate) fn expand_private_openapi_trait(mut attrs: AttributeArgs, tr8: ItemTrait) -> Result<TokenStream> {\n\tlet tr8_attrs = &tr8.attrs;\n\tlet vis = &tr8.vis;\n\tlet ident = &tr8.ident;\n\tlet generics = &tr8.generics;\n\tlet colon_token = &tr8.colon_token;\n\tlet supertraits = &tr8.supertraits;\n\n\tif attrs.len() != 1 {\n\t\treturn Err(Error::new(\n\t\t\tSpan::call_site(),\n\t\t\t\"Expected one argument. Example: #[_private_openapi_trait(OpenapiTraitName)]\"\n\t\t));\n\t}\n\tlet openapi_ident = match attrs.remove(0) {\n\t\tNestedMeta::Meta(Meta::Path(path)) => path,\n\t\tp => {\n\t\t\treturn Err(Error::new(\n\t\t\t\tp.span(),\n\t\t\t\t\"Expected name of the Resource struct this method belongs to\"\n\t\t\t))\n\t\t},\n\t};\n\n\tlet orig_trait = {\n\t\tlet items = tr8\n\t\t\t.items\n\t\t\t.clone()\n\t\t\t.into_iter()\n\t\t\t.map(|item| {\n\t\t\t\tOk(match item {\n\t\t\t\t\tTraitItem::Method(mut method) => {\n\t\t\t\t\t\tlet attrs = TraitItemAttrs::parse(method.attrs)?;\n\t\t\t\t\t\tmethod.attrs = attrs.other_attrs;\n\t\t\t\t\t\tfor bound in attrs.non_openapi_bound {\n\t\t\t\t\t\t\t// we compare two incompatible types using their `Display` implementation\n\t\t\t\t\t\t\t// this triggers a false positive in clippy\n\t\t\t\t\t\t\t#[cfg_attr(feature = \"cargo-clippy\", allow(clippy::cmp_owned))]\n\t\t\t\t\t\t\tmethod\n\t\t\t\t\t\t\t\t.sig\n\t\t\t\t\t\t\t\t.generics\n\t\t\t\t\t\t\t\t.type_params_mut()\n\t\t\t\t\t\t\t\t.filter(|param| param.ident.to_string() == bound.bounded_ty.to_token_stream().to_string())\n\t\t\t\t\t\t\t\t.for_each(|param| param.bounds.extend(bound.bounds.clone()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif attrs.openapi_only {\n\t\t\t\t\t\t\tNone\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSome(TraitItem::Method(method))\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tTraitItem::Type(mut ty) => {\n\t\t\t\t\t\tlet attrs = TraitItemAttrs::parse(ty.attrs)?;\n\t\t\t\t\t\tty.attrs = attrs.other_attrs;\n\t\t\t\t\t\tSome(TraitItem::Type(ty))\n\t\t\t\t\t},\n\t\t\t\t\titem => Some(item)\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect_to_result()?;\n\t\tquote! {\n\t\t\t#(#tr8_attrs)*\n\t\t\t#vis trait #ident #generics #colon_token #supertraits {\n\t\t\t\t#(#items)*\n\t\t\t}\n\t\t}\n\t};\n\n\tlet openapi_trait = if !cfg!(feature = \"openapi\") {\n\t\tNone\n\t} else {\n\t\tlet items = tr8\n\t\t\t.items\n\t\t\t.clone()\n\t\t\t.into_iter()\n\t\t\t.map(|item| {\n\t\t\t\tOk(match item {\n\t\t\t\t\tTraitItem::Method(mut method) => {\n\t\t\t\t\t\tlet attrs = TraitItemAttrs::parse(method.attrs)?;\n\t\t\t\t\t\tmethod.attrs = attrs.other_attrs;\n\t\t\t\t\t\tfor bound in attrs.openapi_bound {\n\t\t\t\t\t\t\t// we compare two incompatible types using their `Display` implementation\n\t\t\t\t\t\t\t// this triggers a false positive in clippy\n\t\t\t\t\t\t\t#[cfg_attr(feature = \"cargo-clippy\", allow(clippy::cmp_owned))]\n\t\t\t\t\t\t\tmethod\n\t\t\t\t\t\t\t\t.sig\n\t\t\t\t\t\t\t\t.generics\n\t\t\t\t\t\t\t\t.type_params_mut()\n\t\t\t\t\t\t\t\t.filter(|param| param.ident.to_string() == bound.bounded_ty.to_token_stream().to_string())\n\t\t\t\t\t\t\t\t.for_each(|param| param.bounds.extend(bound.bounds.clone()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTraitItem::Method(method)\n\t\t\t\t\t},\n\t\t\t\t\tTraitItem::Type(mut ty) => {\n\t\t\t\t\t\tlet attrs = TraitItemAttrs::parse(ty.attrs)?;\n\t\t\t\t\t\tty.attrs = attrs.other_attrs;\n\t\t\t\t\t\tfor bound in attrs.openapi_bound {\n\t\t\t\t\t\t\tty.bounds.extend(bound.bounds.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTraitItem::Type(ty)\n\t\t\t\t\t},\n\t\t\t\t\titem => item\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect_to_result()?;\n\t\tSome(quote! {\n\t\t\t#(#tr8_attrs)*\n\t\t\t#vis trait #openapi_ident #generics #colon_token #supertraits {\n\t\t\t\t#(#items)*\n\t\t\t}\n\t\t})\n\t};\n\n\tOk(quote! {\n\t\t#orig_trait\n\t\t#openapi_trait\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","request_body.rs"],"content":"use crate::util::CollectToResult;\nuse proc_macro2::{Ident, TokenStream};\nuse quote::quote;\nuse std::iter;\nuse syn::{\n\tparse::{Parse, ParseStream},\n\tpunctuated::Punctuated,\n\tspanned::Spanned,\n\tDeriveInput, Error, Generics, Path, Result, Token\n};\n\nstruct MimeList(Punctuated<Path, Token![,]>);\n\nimpl Parse for MimeList {\n\tfn parse(input: ParseStream<'_>) -> Result<Self> {\n\t\tlet list = Punctuated::parse_separated_nonempty(&input)?;\n\t\tOk(Self(list))\n\t}\n}\n\n#[cfg(not(feature = \"openapi\"))]\nfn impl_openapi_type(_ident: &Ident, _generics: &Generics) -> TokenStream {\n\tquote!()\n}\n\n#[cfg(feature = \"openapi\")]\nfn impl_openapi_type(ident: &Ident, generics: &Generics) -> TokenStream {\n\tlet openapi = quote!(::gotham_restful::private::openapi);\n\tquote! {\n\t\timpl #generics ::gotham_restful::private::OpenapiType for #ident #generics {\n\t\t\tfn schema() -> ::gotham_restful::private::OpenapiSchema {\n\t\t\t\t::gotham_restful::private::OpenapiSchema::new(\n\t\t\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t\t\t#openapi::Type::String(\n\t\t\t\t\t\t\t#openapi::StringType {\n\t\t\t\t\t\t\t\tformat: #openapi::VariantOrUnknownOrEmpty::Item(\n\t\t\t\t\t\t\t\t\t#openapi::StringFormat::Binary\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n}\n\npub fn expand_request_body(input: DeriveInput) -> Result<TokenStream> {\n\tlet ident = input.ident;\n\tlet generics = input.generics;\n\n\tlet types = input\n\t\t.attrs\n\t\t.into_iter()\n\t\t.filter(|attr| {\n\t\t\tattr.path.segments.iter().last().map(|segment| segment.ident.to_string()) == Some(\"supported_types\".to_string())\n\t\t})\n\t\t.flat_map(|attr| {\n\t\t\tlet span = attr.span();\n\t\t\tattr.parse_args::<MimeList>()\n\t\t\t\t.map(|list| Box::new(list.0.into_iter().map(Ok)) as Box<dyn Iterator<Item = Result<Path>>>)\n\t\t\t\t.unwrap_or_else(|mut err| {\n\t\t\t\t\terr.combine(Error::new(\n\t\t\t\t\t\tspan,\n\t\t\t\t\t\t\"Hint: Types list should look like #[supported_types(TEXT_PLAIN, APPLICATION_JSON)]\"\n\t\t\t\t\t));\n\t\t\t\t\tBox::new(iter::once(Err(err)))\n\t\t\t\t})\n\t\t})\n\t\t.collect_to_result()?;\n\n\tlet types = match types {\n\t\tref types if types.is_empty() => quote!(None),\n\t\ttypes => quote!(Some(vec![#(#types),*]))\n\t};\n\n\tlet impl_openapi_type = impl_openapi_type(&ident, &generics);\n\n\tOk(quote! {\n\t\timpl #generics ::gotham_restful::RequestBody for #ident #generics\n\t\twhere #ident #generics : ::gotham_restful::FromBody\n\t\t{\n\t\t\tfn supported_types() -> ::core::option::Option<::std::vec::Vec<::gotham_restful::Mime>> {\n\t\t\t\t#types\n\t\t\t}\n\t\t}\n\n\t\t#impl_openapi_type\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","resource.rs"],"content":"use crate::{endpoint::endpoint_ident, util::CollectToResult};\nuse proc_macro2::{Ident, TokenStream};\nuse quote::quote;\nuse std::iter;\nuse syn::{\n\tparenthesized,\n\tparse::{Parse, ParseStream},\n\tpunctuated::Punctuated,\n\tDeriveInput, Result, Token\n};\n\nstruct MethodList(Punctuated<Ident, Token![,]>);\n\nimpl Parse for MethodList {\n\tfn parse(input: ParseStream<'_>) -> Result<Self> {\n\t\tlet content;\n\t\tlet _paren = parenthesized!(content in input);\n\t\tlet list = Punctuated::parse_separated_nonempty(&content)?;\n\t\tOk(Self(list))\n\t}\n}\n\npub fn expand_resource(input: DeriveInput) -> Result<TokenStream> {\n\tlet ident = input.ident;\n\n\tlet methods = input\n\t\t.attrs\n\t\t.into_iter()\n\t\t.filter(|attr| attr.path.is_ident(\"resource\"))\n\t\t.map(|attr| syn::parse2(attr.tokens).map(|m: MethodList| m.0.into_iter()))\n\t\t.flat_map(|list| match list {\n\t\t\tOk(iter) => Box::new(iter.map(|method| {\n\t\t\t\tlet ident = endpoint_ident(&method);\n\t\t\t\tOk(quote!(route.endpoint::<#ident>();))\n\t\t\t})) as Box<dyn Iterator<Item = Result<TokenStream>>>,\n\t\t\tErr(err) => Box::new(iter::once(Err(err)))\n\t\t})\n\t\t.collect_to_result()?;\n\n\tlet non_openapi_impl = quote! {\n\t\timpl ::gotham_restful::Resource for #ident {\n\t\t\tfn setup<D: ::gotham_restful::DrawResourceRoutes>(mut route: D) {\n\t\t\t\t#(#methods)*\n\t\t\t}\n\t\t}\n\t};\n\tlet openapi_impl = if !cfg!(feature = \"openapi\") {\n\t\tNone\n\t} else {\n\t\tSome(quote! {\n\t\t\timpl ::gotham_restful::ResourceWithSchema for #ident {\n\t\t\t\tfn setup<D: ::gotham_restful::DrawResourceRoutesWithSchema>(mut route: D) {\n\t\t\t\t\t#(#methods)*\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t};\n\tOk(quote! {\n\t\t#non_openapi_impl\n\t\t#openapi_impl\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","resource_error.rs"],"content":"use crate::util::{remove_parens, CollectToResult};\nuse proc_macro2::{Ident, TokenStream};\nuse quote::{format_ident, quote};\nuse std::iter;\nuse syn::{\n\tspanned::Spanned, Attribute, Data, DeriveInput, Error, Fields, GenericParam, LitStr, Path, PathSegment, Result, Type,\n\tVariant\n};\n\nstruct ErrorVariantField {\n\tattrs: Vec<Attribute>,\n\tident: Ident,\n\tty: Type\n}\n\nstruct ErrorVariant {\n\tident: Ident,\n\tstatus: Option<Path>,\n\tis_named: bool,\n\tfields: Vec<ErrorVariantField>,\n\tfrom_ty: Option<(usize, Type)>,\n\tdisplay: Option<LitStr>\n}\n\nfn process_variant(variant: Variant) -> Result<ErrorVariant> {\n\tlet status =\n\t\tmatch variant.attrs.iter().find(|attr| {\n\t\t\tattr.path.segments.iter().last().map(|segment| segment.ident.to_string()) == Some(\"status\".to_string())\n\t\t}) {\n\t\t\tSome(attr) => Some(syn::parse2(remove_parens(attr.tokens.clone()))?),\n\t\t\tNone => None\n\t\t};\n\n\tlet mut is_named = false;\n\tlet mut fields = Vec::new();\n\tmatch variant.fields {\n\t\tFields::Named(named) => {\n\t\t\tis_named = true;\n\t\t\tfor field in named.named {\n\t\t\t\tlet span = field.span();\n\t\t\t\tfields.push(ErrorVariantField {\n\t\t\t\t\tattrs: field.attrs,\n\t\t\t\t\tident: field\n\t\t\t\t\t\t.ident\n\t\t\t\t\t\t.ok_or_else(|| Error::new(span, \"Missing ident for this enum variant field\"))?,\n\t\t\t\t\tty: field.ty\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tFields::Unnamed(unnamed) => {\n\t\t\tfor (i, field) in unnamed.unnamed.into_iter().enumerate() {\n\t\t\t\tfields.push(ErrorVariantField {\n\t\t\t\t\tattrs: field.attrs,\n\t\t\t\t\tident: format_ident!(\"arg{}\", i),\n\t\t\t\t\tty: field.ty\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t\tFields::Unit => {}\n\t}\n\n\tlet from_ty = fields\n\t\t.iter()\n\t\t.enumerate()\n\t\t.find(|(_, field)| {\n\t\t\tfield\n\t\t\t\t.attrs\n\t\t\t\t.iter()\n\t\t\t\t.any(|attr| attr.path.segments.last().map(|segment| segment.ident.to_string()) == Some(\"from\".to_string()))\n\t\t})\n\t\t.map(|(i, field)| (i, field.ty.clone()));\n\n\tlet display = match variant.attrs.iter().find(|attr| {\n\t\tattr.path.segments.iter().last().map(|segment| segment.ident.to_string()) == Some(\"display\".to_string())\n\t}) {\n\t\tSome(attr) => Some(syn::parse2(remove_parens(attr.tokens.clone()))?),\n\t\tNone => None\n\t};\n\n\tOk(ErrorVariant {\n\t\tident: variant.ident,\n\t\tstatus,\n\t\tis_named,\n\t\tfields,\n\t\tfrom_ty,\n\t\tdisplay\n\t})\n}\n\nfn path_segment(name: &str) -> PathSegment {\n\tPathSegment {\n\t\tident: format_ident!(\"{}\", name),\n\t\targuments: Default::default()\n\t}\n}\n\nimpl ErrorVariant {\n\tfn fields_pat(&self) -> TokenStream {\n\t\tlet mut fields = self.fields.iter().map(|field| &field.ident).peekable();\n\t\tif fields.peek().is_none() {\n\t\t\tquote!()\n\t\t} else if self.is_named {\n\t\t\tquote!( { #( #fields ),* } )\n\t\t} else {\n\t\t\tquote!( ( #( #fields ),* ) )\n\t\t}\n\t}\n\n\tfn to_display_match_arm(&self, formatter_ident: &Ident, enum_ident: &Ident) -> Result<TokenStream> {\n\t\tlet ident = &self.ident;\n\t\tlet display = self\n\t\t\t.display\n\t\t\t.as_ref()\n\t\t\t.ok_or_else(|| Error::new(self.ident.span(), \"Missing display string for this variant\"))?;\n\n\t\t// lets find all required format parameters\n\t\tlet display_str = display.value();\n\t\tlet mut params: Vec<&str> = Vec::new();\n\t\tlet len = display_str.len();\n\t\tlet mut start = len;\n\t\tlet mut iter = display_str.chars().enumerate().peekable();\n\t\twhile let Some((i, c)) = iter.next() {\n\t\t\t// we found a new opening brace\n\t\t\tif start == len && c == '{' {\n\t\t\t\tstart = i + 1;\n\t\t\t}\n\t\t\t// we found a duplicate opening brace\n\t\t\telse if start == i && c == '{' {\n\t\t\t\tstart = len;\n\t\t\t}\n\t\t\t// we found a closing brace\n\t\t\telse if start < i && c == '}' {\n\t\t\t\tmatch iter.peek() {\n\t\t\t\t\tSome((_, '}')) => {\n\t\t\t\t\t\treturn Err(Error::new(\n\t\t\t\t\t\t\tdisplay.span(),\n\t\t\t\t\t\t\t\"Error parsing format string: curly braces not allowed inside parameter name\"\n\t\t\t\t\t\t))\n\t\t\t\t\t},\n\t\t\t\t\t_ => params.push(&display_str[start..i])\n\t\t\t\t};\n\t\t\t\tstart = len;\n\t\t\t}\n\t\t\t// we found a closing brace without content\n\t\t\telse if start == i && c == '}' {\n\t\t\t\treturn Err(Error::new(\n\t\t\t\t\tdisplay.span(),\n\t\t\t\t\t\"Error parsing format string: parameter name must not be empty\"\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t\tif start != len {\n\t\t\treturn Err(Error::new(\n\t\t\t\tdisplay.span(),\n\t\t\t\t\"Error parsing format string: Unmatched opening brace\"\n\t\t\t));\n\t\t}\n\t\tlet params = params\n\t\t\t.into_iter()\n\t\t\t.map(|name| format_ident!(\"{}{}\", if self.is_named { \"\" } else { \"arg\" }, name));\n\n\t\tlet fields_pat = self.fields_pat();\n\t\tOk(quote! {\n\t\t\t#enum_ident::#ident #fields_pat => ::std::write!(#formatter_ident, #display #(, #params = #params)*)\n\t\t})\n\t}\n\n\tfn status(&self) -> Option<TokenStream> {\n\t\tself.status.as_ref().map(|status| {\n\t\t\t// the status might be relative to StatusCode, so let's fix that\n\t\t\tif status.leading_colon.is_none() && status.segments.len() < 2 {\n\t\t\t\tlet status_ident = status.segments.first().cloned().unwrap_or_else(|| path_segment(\"OK\"));\n\t\t\t\tquote!(::gotham_restful::gotham::hyper::StatusCode::#status_ident)\n\t\t\t} else {\n\t\t\t\tquote!(::gotham_restful::gotham::hyper::StatusCode::from(#status))\n\t\t\t}\n\t\t})\n\t}\n\n\tfn into_match_arm(self, enum_ident: &Ident) -> Result<TokenStream> {\n\t\tlet ident = &self.ident;\n\t\tlet fields_pat = self.fields_pat();\n\t\tlet status = self.status();\n\n\t\t// the response will come directly from the from_ty if present\n\t\tlet res = match (self.from_ty, status) {\n\t\t\t(Some((from_index, _)), None) => {\n\t\t\t\tlet from_field = &self.fields[from_index].ident;\n\t\t\t\tquote!(#from_field.into_response_error())\n\t\t\t},\n\t\t\t(Some(_), Some(_)) => return Err(Error::new(ident.span(), \"When #[from] is used, #[status] must not be used!\")),\n\t\t\t(None, Some(status)) => quote!(::std::result::Result::Ok(::gotham_restful::Response::new(\n\t\t\t\t#status,\n\t\t\t\t::gotham_restful::gotham::hyper::Body::empty(),\n\t\t\t\t::core::option::Option::None\n\t\t\t))),\n\t\t\t(None, None) => return Err(Error::new(ident.span(), \"Missing #[status(code)] for this variant\"))\n\t\t};\n\n\t\tOk(quote! {\n\t\t\t#enum_ident::#ident #fields_pat => #res\n\t\t})\n\t}\n\n\tfn were(&self) -> Option<TokenStream> {\n\t\tself.from_ty.as_ref().map(|(_, ty)| quote!( #ty : ::std::error::Error ))\n\t}\n}\n\npub fn expand_resource_error(input: DeriveInput) -> Result<TokenStream> {\n\tlet ident = input.ident;\n\tlet generics = input.generics;\n\n\tlet inum = match input.data {\n\t\tData::Enum(inum) => Ok(inum),\n\t\tData::Struct(strukt) => Err(strukt.struct_token.span()),\n\t\tData::Union(uni) => Err(uni.union_token.span())\n\t}\n\t.map_err(|span| Error::new(span, \"#[derive(ResourceError)] only works for enums\"))?;\n\tlet variants = inum.variants.into_iter().map(process_variant).collect_to_result()?;\n\n\tlet display_impl = if variants.iter().any(|v| v.display.is_none()) {\n\t\tNone // TODO issue warning if display is present on some but not all\n\t} else {\n\t\tlet were = generics.params.iter().filter_map(|param| match param {\n\t\t\tGenericParam::Type(ty) => {\n\t\t\t\tlet ident = &ty.ident;\n\t\t\t\tSome(quote!(#ident : ::std::fmt::Display))\n\t\t\t},\n\t\t\t_ => None\n\t\t});\n\t\tlet formatter_ident = format_ident!(\"resource_error_display_formatter\");\n\t\tlet match_arms = variants\n\t\t\t.iter()\n\t\t\t.map(|v| v.to_display_match_arm(&formatter_ident, &ident))\n\t\t\t.collect_to_result()?;\n\t\tSome(quote! {\n\t\t\timpl #generics ::std::fmt::Display for #ident #generics\n\t\t\twhere #( #were ),*\n\t\t\t{\n\t\t\t\tfn fmt(&self, #formatter_ident: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n\t\t\t\t\tmatch self {\n\t\t\t\t\t\t#( #match_arms ),*\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t};\n\n\tlet mut from_impls: Vec<TokenStream> = Vec::new();\n\n\tfor var in &variants {\n\t\tlet var_ident = &var.ident;\n\t\tlet (from_index, from_ty) = match var.from_ty.as_ref() {\n\t\t\tSome(f) => f,\n\t\t\tNone => continue\n\t\t};\n\t\tlet from_ident = &var.fields[*from_index].ident;\n\n\t\tlet fields_pat = var.fields_pat();\n\t\tlet fields_where = var\n\t\t\t.fields\n\t\t\t.iter()\n\t\t\t.enumerate()\n\t\t\t.filter(|(i, _)| i != from_index)\n\t\t\t.map(|(_, field)| {\n\t\t\t\tlet ty = &field.ty;\n\t\t\t\tquote!( #ty : Default )\n\t\t\t})\n\t\t\t.chain(iter::once(quote!( #from_ty : ::std::error::Error )));\n\t\tlet fields_let = var\n\t\t\t.fields\n\t\t\t.iter()\n\t\t\t.enumerate()\n\t\t\t.filter(|(i, _)| i != from_index)\n\t\t\t.map(|(_, field)| {\n\t\t\t\tlet id = &field.ident;\n\t\t\t\tlet ty = &field.ty;\n\t\t\t\tquote!( let #id : #ty = Default::default(); )\n\t\t\t});\n\n\t\tfrom_impls.push(quote! {\n\t\t\timpl #generics ::std::convert::From<#from_ty> for #ident #generics\n\t\t\twhere #( #fields_where ),*\n\t\t\t{\n\t\t\t\tfn from(#from_ident: #from_ty) -> Self {\n\t\t\t\t\t#( #fields_let )*\n\t\t\t\t\tSelf::#var_ident #fields_pat\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tlet status_codes = if cfg!(feature = \"openapi\") {\n\t\tlet codes = variants.iter().map(|v| match v.status() {\n\t\t\tSome(code) => quote!(status_codes.push(#code);),\n\t\t\tNone => {\n\t\t\t\t// we would've errored before if from_ty was not set\n\t\t\t\tlet from_ty = &v.from_ty.as_ref().unwrap().1;\n\t\t\t\tquote!(status_codes.extend(<#from_ty as ::gotham_restful::IntoResponseError>::status_codes());)\n\t\t\t}\n\t\t});\n\t\tSome(quote! {\n\t\t\tfn status_codes() -> ::std::vec::Vec<::gotham_restful::gotham::hyper::StatusCode> {\n\t\t\t\tlet mut status_codes = <::std::vec::Vec<::gotham_restful::gotham::hyper::StatusCode>>::new();\n\t\t\t\t#(#codes)*\n\t\t\t\tstatus_codes\n\t\t\t}\n\t\t})\n\t} else {\n\t\tNone\n\t};\n\n\tlet schema = if cfg!(feature = \"openapi\") {\n\t\tlet codes = variants.iter().map(|v| match v.status() {\n\t\t\tSome(code) => quote! {\n\t\t\t\t#code => <::gotham_restful::NoContent as ::gotham_restful::ResponseSchema>::schema(\n\t\t\t\t\t::gotham_restful::gotham::hyper::StatusCode::NO_CONTENT\n\t\t\t\t)\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\t// we would've errored before if from_ty was not set\n\t\t\t\tlet from_ty = &v.from_ty.as_ref().unwrap().1;\n\t\t\t\tquote! {\n\t\t\t\t\tcode if <#from_ty as ::gotham_restful::IntoResponseError>::status_codes().contains(&code) => {\n\t\t\t\t\t\t<#from_ty as ::gotham_restful::IntoResponseError>::schema(code)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tSome(quote! {\n\t\t\tfn schema(code: ::gotham_restful::gotham::hyper::StatusCode) -> ::gotham_restful::private::OpenapiSchema {\n\t\t\t\tmatch code {\n\t\t\t\t\t#(#codes,)*\n\t\t\t\t\tcode => panic!(\"Invalid status code {}\", code)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t} else {\n\t\tNone\n\t};\n\n\tlet were = variants.iter().filter_map(|variant| variant.were()).collect::<Vec<_>>();\n\tlet variants = variants\n\t\t.into_iter()\n\t\t.map(|variant| variant.into_match_arm(&ident))\n\t\t.collect_to_result()?;\n\n\tOk(quote! {\n\t\t#display_impl\n\n\t\timpl #generics ::gotham_restful::IntoResponseError for #ident #generics\n\t\twhere #( #were ),*\n\t\t{\n\t\t\ttype Err = ::gotham_restful::private::serde_json::Error;\n\n\t\t\tfn into_response_error(self) -> ::std::result::Result<::gotham_restful::Response, Self::Err>\n\t\t\t{\n\t\t\t\tmatch self {\n\t\t\t\t\t#( #variants ),*\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#status_codes\n\t\t\t#schema\n\t\t}\n\n\t\t#( #from_impls )*\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","derive","src","util.rs"],"content":"use proc_macro2::{Delimiter, TokenStream, TokenTree};\nuse std::iter;\nuse syn::{Error, Lit, LitBool, LitStr, Result};\n\npub(crate) trait CollectToResult {\n\ttype Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Self::Item>>;\n}\n\nimpl<Item, I> CollectToResult for I\nwhere\n\tI: Iterator<Item = Result<Item>>\n{\n\ttype Item = Item;\n\n\tfn collect_to_result(self) -> Result<Vec<Item>> {\n\t\tself.fold(Ok(Vec::new()), |res, code| match (code, res) {\n\t\t\t(Ok(code), Ok(mut codes)) => {\n\t\t\t\tcodes.push(code);\n\t\t\t\tOk(codes)\n\t\t\t},\n\t\t\t(Ok(_), Err(errors)) => Err(errors),\n\t\t\t(Err(err), Ok(_)) => Err(err),\n\t\t\t(Err(err), Err(mut errors)) => {\n\t\t\t\terrors.combine(err);\n\t\t\t\tErr(errors)\n\t\t\t}\n\t\t})\n\t}\n}\n\npub(crate) trait ExpectLit {\n\tfn expect_bool(self) -> Result<LitBool>;\n\tfn expect_str(self) -> Result<LitStr>;\n}\n\nimpl ExpectLit for Lit {\n\tfn expect_bool(self) -> Result<LitBool> {\n\t\tmatch self {\n\t\t\tSelf::Bool(bool) => Ok(bool),\n\t\t\t_ => Err(Error::new(self.span(), \"Expected boolean literal\"))\n\t\t}\n\t}\n\n\tfn expect_str(self) -> Result<LitStr> {\n\t\tmatch self {\n\t\t\tSelf::Str(str) => Ok(str),\n\t\t\t_ => Err(Error::new(self.span(), \"Expected string literal\"))\n\t\t}\n\t}\n}\n\npub(crate) fn remove_parens(input: TokenStream) -> TokenStream {\n\tlet iter = input.into_iter().flat_map(|tt| {\n\t\tif let TokenTree::Group(group) = &tt {\n\t\t\tif group.delimiter() == Delimiter::Parenthesis {\n\t\t\t\treturn Box::new(group.stream().into_iter()) as Box<dyn Iterator<Item = TokenTree>>;\n\t\t\t}\n\t\t}\n\t\tBox::new(iter::once(tt))\n\t});\n\titer.collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","auth.rs"],"content":"use crate::{AuthError, Forbidden};\n\nuse cookie::CookieJar;\nuse futures_util::{\n\tfuture,\n\tfuture::{FutureExt, TryFutureExt}\n};\nuse gotham::{\n\tanyhow,\n\thandler::HandlerFuture,\n\thyper::header::{HeaderMap, HeaderName, AUTHORIZATION},\n\tmiddleware::{cookie::CookieParser, Middleware, NewMiddleware},\n\tstate::{FromState, State}\n};\nuse jsonwebtoken::{errors::ErrorKind, DecodingKey};\nuse serde::de::DeserializeOwned;\nuse std::{marker::PhantomData, panic::RefUnwindSafe, pin::Pin};\n\npub type AuthValidation = jsonwebtoken::Validation;\n\n/// The authentication status returned by the auth middleware for each request.\n#[derive(Debug, StateData)]\npub enum AuthStatus<T: Send + 'static> {\n\t/// The auth status is unknown.\n\tUnknown,\n\t/// The request has been performed without any kind of authentication.\n\tUnauthenticated,\n\t/// The request has been performed with an invalid authentication.\n\tInvalid,\n\t/// The request has been performed with an expired authentication.\n\tExpired,\n\t/// The request has been performed with a valid authentication.\n\tAuthenticated(T)\n}\n\nimpl<T> Clone for AuthStatus<T>\nwhere\n\tT: Clone + Send + 'static\n{\n\tfn clone(&self) -> Self {\n\t\tmatch self {\n\t\t\tSelf::Unknown => Self::Unknown,\n\t\t\tSelf::Unauthenticated => Self::Unauthenticated,\n\t\t\tSelf::Invalid => Self::Invalid,\n\t\t\tSelf::Expired => Self::Expired,\n\t\t\tSelf::Authenticated(data) => Self::Authenticated(data.clone())\n\t\t}\n\t}\n}\n\nimpl<T> Copy for AuthStatus<T> where T: Copy + Send + 'static {}\n\nimpl<T: Send + 'static> AuthStatus<T> {\n\tpub fn ok(self) -> Result<T, AuthError> {\n\t\tmatch self {\n\t\t\tSelf::Authenticated(data) => Ok(data),\n\t\t\t_ => Err(Forbidden)\n\t\t}\n\t}\n}\n\n/// The source of the authentication token in the request.\n#[derive(Clone, Debug, StateData)]\npub enum AuthSource {\n\t/// Take the token from a cookie with the given name.\n\tCookie(String),\n\t/// Take the token from a header with the given name.\n\tHeader(HeaderName),\n\t/// Take the token from the HTTP Authorization header. This is different from `Header(\"Authorization\")`\n\t/// as it will follow the `scheme param` format from the HTTP specification. The `scheme` will\n\t/// be discarded, so its value doesn't matter.\n\tAuthorizationHeader\n}\n\n/**\nThis trait will help the auth middleware to determine the validity of an authentication token.\n\nA very basic implementation could look like this:\n\n```\n# use gotham_restful::{AuthHandler, gotham::state::State};\n#\nconst SECRET : &'static [u8; 32] = b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\";\n\nstruct CustomAuthHandler;\nimpl<T> AuthHandler<T> for CustomAuthHandler {\n\tfn jwt_secret<F : FnOnce() -> Option<T>>(&self, _state : &mut State, _decode_data : F) -> Option<Vec<u8>> {\n\t\tSome(SECRET.to_vec())\n\t}\n}\n```\n*/\npub trait AuthHandler<Data> {\n\t/// Return the SHA256-HMAC secret used to verify the JWT token.\n\tfn jwt_secret<F: FnOnce() -> Option<Data>>(&self, state: &mut State, decode_data: F) -> Option<Vec<u8>>;\n}\n\n/// An [AuthHandler] returning always the same secret. See [AuthMiddleware] for a usage example.\n#[derive(Clone, Debug)]\npub struct StaticAuthHandler {\n\tsecret: Vec<u8>\n}\n\nimpl StaticAuthHandler {\n\tpub fn from_vec(secret: Vec<u8>) -> Self {\n\t\tSelf { secret }\n\t}\n\n\tpub fn from_array(secret: &[u8]) -> Self {\n\t\tSelf::from_vec(secret.to_vec())\n\t}\n}\n\nimpl<T> AuthHandler<T> for StaticAuthHandler {\n\tfn jwt_secret<F: FnOnce() -> Option<T>>(&self, _state: &mut State, _decode_data: F) -> Option<Vec<u8>> {\n\t\tSome(self.secret.clone())\n\t}\n}\n\n/**\nThis is the auth middleware. To use it, first make sure you have the `auth` feature enabled. Then\nsimply add it to your pipeline and request it inside your handler:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::{router::builder::*, pipeline::{new_pipeline, single::single_pipeline}, state::State};\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n#\n#[derive(Resource)]\n#[resource(read_all)]\nstruct AuthResource;\n\n#[derive(Debug, Deserialize, Clone)]\nstruct AuthData {\n\tsub: String,\n\texp: u64\n}\n\n#[read_all]\nfn read_all(auth : &AuthStatus<AuthData>) -> Success<String> {\n\tformat!(\"{:?}\", auth).into()\n}\n\nfn main() {\n\tlet auth: AuthMiddleware<AuthData, _> = AuthMiddleware::new(\n\t\tAuthSource::AuthorizationHeader,\n\t\tAuthValidation::default(),\n\t\tStaticAuthHandler::from_array(b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\")\n\t);\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(auth).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\troute.resource::<AuthResource>(\"auth\");\n\t}));\n}\n```\n*/\n#[derive(Debug)]\npub struct AuthMiddleware<Data, Handler> {\n\tsource: AuthSource,\n\tvalidation: AuthValidation,\n\thandler: Handler,\n\t_data: PhantomData<Data>\n}\n\nimpl<Data, Handler> Clone for AuthMiddleware<Data, Handler>\nwhere\n\tHandler: Clone\n{\n\tfn clone(&self) -> Self {\n\t\tSelf {\n\t\t\tsource: self.source.clone(),\n\t\t\tvalidation: self.validation.clone(),\n\t\t\thandler: self.handler.clone(),\n\t\t\t_data: self._data\n\t\t}\n\t}\n}\n\nimpl<Data, Handler> AuthMiddleware<Data, Handler>\nwhere\n\tData: DeserializeOwned + Send,\n\tHandler: AuthHandler<Data> + Default\n{\n\tpub fn from_source(source: AuthSource) -> Self {\n\t\tSelf {\n\t\t\tsource,\n\t\t\tvalidation: Default::default(),\n\t\t\thandler: Default::default(),\n\t\t\t_data: Default::default()\n\t\t}\n\t}\n}\n\nimpl<Data, Handler> AuthMiddleware<Data, Handler>\nwhere\n\tData: DeserializeOwned + Send,\n\tHandler: AuthHandler<Data>\n{\n\tpub fn new(source: AuthSource, validation: AuthValidation, handler: Handler) -> Self {\n\t\tSelf {\n\t\t\tsource,\n\t\t\tvalidation,\n\t\t\thandler,\n\t\t\t_data: Default::default()\n\t\t}\n\t}\n\n\tfn auth_status(&self, state: &mut State) -> AuthStatus<Data> {\n\t\t// extract the provided token, if any\n\t\tlet token = match &self.source {\n\t\t\tAuthSource::Cookie(name) => CookieJar::try_borrow_from(&state)\n\t\t\t\t.map(|jar| jar.get(&name).map(|cookie| cookie.value().to_owned()))\n\t\t\t\t.unwrap_or_else(|| {\n\t\t\t\t\tCookieParser::from_state(&state)\n\t\t\t\t\t\t.get(&name)\n\t\t\t\t\t\t.map(|cookie| cookie.value().to_owned())\n\t\t\t\t}),\n\t\t\tAuthSource::Header(name) => HeaderMap::try_borrow_from(&state)\n\t\t\t\t.and_then(|map| map.get(name))\n\t\t\t\t.and_then(|header| header.to_str().ok())\n\t\t\t\t.map(|value| value.to_owned()),\n\t\t\tAuthSource::AuthorizationHeader => HeaderMap::try_borrow_from(&state)\n\t\t\t\t.and_then(|map| map.get(AUTHORIZATION))\n\t\t\t\t.and_then(|header| header.to_str().ok())\n\t\t\t\t.and_then(|value| value.split_whitespace().nth(1))\n\t\t\t\t.map(|value| value.to_owned())\n\t\t};\n\n\t\t// unauthed if no token\n\t\tlet token = match token {\n\t\t\tSome(token) => token,\n\t\t\tNone => return AuthStatus::Unauthenticated\n\t\t};\n\n\t\t// get the secret from the handler, possibly decoding claims ourselves\n\t\tlet secret = self.handler.jwt_secret(state, || {\n\t\t\tlet b64 = token.split('.').nth(1)?;\n\t\t\tlet raw = base64::decode_config(b64, base64::URL_SAFE_NO_PAD).ok()?;\n\t\t\tserde_json::from_slice(&raw).ok()?\n\t\t});\n\n\t\t// unknown if no secret\n\t\tlet secret = match secret {\n\t\t\tSome(secret) => secret,\n\t\t\tNone => return AuthStatus::Unknown\n\t\t};\n\n\t\t// validate the token\n\t\tlet data: Data = match jsonwebtoken::decode(&token, &DecodingKey::from_secret(&secret), &self.validation) {\n\t\t\tOk(data) => data.claims,\n\t\t\tErr(e) => match e.into_kind() {\n\t\t\t\tErrorKind::ExpiredSignature => return AuthStatus::Expired,\n\t\t\t\t_ => return AuthStatus::Invalid\n\t\t\t}\n\t\t};\n\n\t\t// we found a valid token\n\t\tAuthStatus::Authenticated(data)\n\t}\n}\n\nimpl<Data, Handler> Middleware for AuthMiddleware<Data, Handler>\nwhere\n\tData: DeserializeOwned + Send + 'static,\n\tHandler: AuthHandler<Data>\n{\n\tfn call<Chain>(self, mut state: State, chain: Chain) -> Pin<Box<HandlerFuture>>\n\twhere\n\t\tChain: FnOnce(State) -> Pin<Box<HandlerFuture>>\n\t{\n\t\t// put the source in our state, required for e.g. openapi\n\t\tstate.put(self.source.clone());\n\n\t\t// put the status in our state\n\t\tlet status = self.auth_status(&mut state);\n\t\tstate.put(status);\n\n\t\t// call the rest of the chain\n\t\tchain(state).and_then(|(state, res)| future::ok((state, res))).boxed()\n\t}\n}\n\nimpl<Data, Handler> NewMiddleware for AuthMiddleware<Data, Handler>\nwhere\n\tSelf: Clone + Middleware + Sync + RefUnwindSafe\n{\n\ttype Instance = Self;\n\n\tfn new_middleware(&self) -> anyhow::Result<Self> {\n\t\tlet c: Self = self.clone();\n\t\tOk(c)\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse cookie::Cookie;\n\tuse gotham::hyper::header::COOKIE;\n\tuse std::fmt::Debug;\n\n\t// 256-bit random string\n\tconst JWT_SECRET: &'static [u8; 32] = b\"Lyzsfnta0cdxyF0T9y6VGxp3jpgoMUuW\";\n\n\t// some known tokens\n\tconst VALID_TOKEN : &'static str = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJtc3JkMCIsInN1YiI6ImdvdGhhbS1yZXN0ZnVsIiwiaWF0IjoxNTc3ODM2ODAwLCJleHAiOjQxMDI0NDQ4MDB9.8h8Ax-nnykqEQ62t7CxmM3ja6NzUQ4L0MLOOzddjLKk\";\n\tconst EXPIRED_TOKEN : &'static str = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJtc3JkMCIsInN1YiI6ImdvdGhhbS1yZXN0ZnVsIiwiaWF0IjoxNTc3ODM2ODAwLCJleHAiOjE1Nzc4MzcxMDB9.eV1snaGLYrJ7qUoMk74OvBY3WUU9M0Je5HTU2xtX1v0\";\n\tconst INVALID_TOKEN : &'static str = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJtc3JkMCIsInN1YiI6ImdvdGhhbS1yZXN0ZnVsIiwiaWF0IjoxNTc3ODM2ODAwLCJleHAiOjQxMDI0NDQ4MDB9\";\n\n\t#[derive(Debug, Deserialize, PartialEq)]\n\tstruct TestData {\n\t\tiss: String,\n\t\tsub: String,\n\t\tiat: u64,\n\t\texp: u64\n\t}\n\n\timpl Default for TestData {\n\t\tfn default() -> Self {\n\t\t\tSelf {\n\t\t\t\tiss: \"msrd0\".to_owned(),\n\t\t\t\tsub: \"gotham-restful\".to_owned(),\n\t\t\t\tiat: 1577836800,\n\t\t\t\texp: 4102444800\n\t\t\t}\n\t\t}\n\t}\n\n\t#[derive(Default)]\n\tstruct NoneAuthHandler;\n\timpl<T> AuthHandler<T> for NoneAuthHandler {\n\t\tfn jwt_secret<F: FnOnce() -> Option<T>>(&self, _state: &mut State, _decode_data: F) -> Option<Vec<u8>> {\n\t\t\tNone\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_none_secret() {\n\t\tlet middleware = <AuthMiddleware<TestData, NoneAuthHandler>>::from_source(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(AUTHORIZATION, format!(\"Bearer {}\", VALID_TOKEN).parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tmiddleware.auth_status(&mut state);\n\t\t});\n\t}\n\n\t#[derive(Default)]\n\tstruct TestAssertingHandler;\n\timpl<T> AuthHandler<T> for TestAssertingHandler\n\twhere\n\t\tT: Debug + Default + PartialEq\n\t{\n\t\tfn jwt_secret<F: FnOnce() -> Option<T>>(&self, _state: &mut State, decode_data: F) -> Option<Vec<u8>> {\n\t\t\tassert_eq!(decode_data(), Some(T::default()));\n\t\t\tSome(JWT_SECRET.to_vec())\n\t\t}\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_decode_data() {\n\t\tlet middleware = <AuthMiddleware<TestData, TestAssertingHandler>>::from_source(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(AUTHORIZATION, format!(\"Bearer {}\", VALID_TOKEN).parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tmiddleware.auth_status(&mut state);\n\t\t});\n\t}\n\n\tfn new_middleware<T>(source: AuthSource) -> AuthMiddleware<T, StaticAuthHandler>\n\twhere\n\t\tT: DeserializeOwned + Send\n\t{\n\t\tAuthMiddleware::new(source, Default::default(), StaticAuthHandler::from_array(JWT_SECRET))\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_no_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Unauthenticated => {},\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Unauthenticated, got {:?}\", status)\n\t\t\t};\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_expired_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(AUTHORIZATION, format!(\"Bearer {}\", EXPIRED_TOKEN).parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Expired => {},\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Expired, got {:?}\", status)\n\t\t\t};\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_invalid_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(AUTHORIZATION, format!(\"Bearer {}\", INVALID_TOKEN).parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Invalid => {},\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Invalid, got {:?}\", status)\n\t\t\t};\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_auth_header_token() {\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::AuthorizationHeader);\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(AUTHORIZATION, format!(\"Bearer {}\", VALID_TOKEN).parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {:?}\", status)\n\t\t\t};\n\t\t})\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_header_token() {\n\t\tlet header_name = \"x-znoiprwmvfexju\";\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::Header(HeaderName::from_static(header_name)));\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(header_name, VALID_TOKEN.parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {:?}\", status)\n\t\t\t};\n\t\t})\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_cookie_token() {\n\t\tlet cookie_name = \"znoiprwmvfexju\";\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::Cookie(cookie_name.to_owned()));\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut jar = CookieJar::new();\n\t\t\tjar.add_original(Cookie::new(cookie_name, VALID_TOKEN));\n\t\t\tstate.put(jar);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {:?}\", status)\n\t\t\t};\n\t\t})\n\t}\n\n\t#[test]\n\tfn test_auth_middleware_cookie_no_jar() {\n\t\tlet cookie_name = \"znoiprwmvfexju\";\n\t\tlet middleware = new_middleware::<TestData>(AuthSource::Cookie(cookie_name.to_owned()));\n\t\tState::with_new(|mut state| {\n\t\t\tlet mut headers = HeaderMap::new();\n\t\t\theaders.insert(COOKIE, format!(\"{}={}\", cookie_name, VALID_TOKEN).parse().unwrap());\n\t\t\tstate.put(headers);\n\t\t\tlet status = middleware.auth_status(&mut state);\n\t\t\tmatch status {\n\t\t\t\tAuthStatus::Authenticated(data) => assert_eq!(data, TestData::default()),\n\t\t\t\t_ => panic!(\"Expected AuthStatus::Authenticated, got {:?}\", status)\n\t\t\t};\n\t\t})\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[2360272],"length":1,"stats":{"Line":2},"fn_name":"from_vec"},{"line":109,"address":[2360336],"length":1,"stats":{"Line":2},"fn_name":"from_array"},{"line":110,"address":[2360359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[3883536,3885968,3883941,3886373,3885893,3883461,3885413,3884924,3883056,3884421,3884016,3882576,3885488,3884496,3885008,3882981],"length":1,"stats":{"Line":1},"fn_name":"call<openapi_specification::AuthData,gotham_restful::auth::StaticAuthHandler,closure-0>"},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":54,"coverable":68},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","cors.rs"],"content":"use gotham::{\n\thandler::HandlerFuture,\n\thelpers::http::response::create_empty_response,\n\thyper::{\n\t\theader::{\n\t\t\tHeaderMap, HeaderName, HeaderValue, ACCESS_CONTROL_ALLOW_CREDENTIALS, ACCESS_CONTROL_ALLOW_HEADERS,\n\t\t\tACCESS_CONTROL_ALLOW_METHODS, ACCESS_CONTROL_ALLOW_ORIGIN, ACCESS_CONTROL_MAX_AGE,\n\t\t\tACCESS_CONTROL_REQUEST_HEADERS, ACCESS_CONTROL_REQUEST_METHOD, ORIGIN, VARY\n\t\t},\n\t\tBody, Method, Response, StatusCode\n\t},\n\tmiddleware::Middleware,\n\tpipeline::chain::PipelineHandleChain,\n\trouter::{\n\t\tbuilder::{DefineSingleRoute, DrawRoutes, ExtendRouteMatcher},\n\t\troute::matcher::AccessControlRequestMethodMatcher\n\t},\n\tstate::{FromState, State}\n};\nuse std::{panic::RefUnwindSafe, pin::Pin};\n\n/**\nSpecify the allowed origins of the request. It is up to the browser to check the validity of the\norigin. This, when sent to the browser, will indicate whether or not the request's origin was\nallowed to make the request.\n*/\n#[derive(Clone, Debug)]\npub enum Origin {\n\t/// Do not send any `Access-Control-Allow-Origin` headers.\n\tNone,\n\t/// Send `Access-Control-Allow-Origin: *`. Note that browser will not send credentials.\n\tStar,\n\t/// Set the `Access-Control-Allow-Origin` header to a single origin.\n\tSingle(String),\n\t/// Copy the `Origin` header into the `Access-Control-Allow-Origin` header.\n\tCopy\n}\n\nimpl Default for Origin {\n\tfn default() -> Self {\n\t\tSelf::None\n\t}\n}\n\nimpl Origin {\n\t/// Get the header value for the `Access-Control-Allow-Origin` header.\n\tfn header_value(&self, state: &State) -> Option<HeaderValue> {\n\t\tmatch self {\n\t\t\tSelf::None => None,\n\t\t\tSelf::Star => Some(\"*\".parse().unwrap()),\n\t\t\tSelf::Single(origin) => Some(origin.parse().unwrap()),\n\t\t\tSelf::Copy => {\n\t\t\t\tlet headers = HeaderMap::borrow_from(state);\n\t\t\t\theaders.get(ORIGIN).map(Clone::clone)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Returns true if the `Vary` header has to include `Origin`.\n\tfn varies(&self) -> bool {\n\t\tmatches!(self, Self::Copy)\n\t}\n}\n\n/**\nSpecify the allowed headers of the request. It is up to the browser to check that only the allowed\nheaders are sent with the request.\n*/\n#[derive(Clone, Debug)]\npub enum Headers {\n\t/// Do not send any `Access-Control-Allow-Headers` headers.\n\tNone,\n\t/// Set the `Access-Control-Allow-Headers` header to the following header list. If empty, this\n\t/// is treated as if it was [None].\n\tList(Vec<HeaderName>),\n\t/// Copy the `Access-Control-Request-Headers` header into the `Access-Control-Allow-Header`\n\t/// header.\n\tCopy\n}\n\nimpl Default for Headers {\n\tfn default() -> Self {\n\t\tSelf::None\n\t}\n}\n\nimpl Headers {\n\t/// Get the header value for the `Access-Control-Allow-Headers` header.\n\tfn header_value(&self, state: &State) -> Option<HeaderValue> {\n\t\tmatch self {\n\t\t\tSelf::None => None,\n\t\t\tSelf::List(list) => Some(list.join(\",\").parse().unwrap()),\n\t\t\tSelf::Copy => {\n\t\t\t\tlet headers = HeaderMap::borrow_from(state);\n\t\t\t\theaders.get(ACCESS_CONTROL_REQUEST_HEADERS).map(Clone::clone)\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Returns true if the `Vary` header has to include `Origin`.\n\tfn varies(&self) -> bool {\n\t\tmatches!(self, Self::Copy)\n\t}\n}\n\n/**\nThis is the configuration that the CORS handler will follow. Its default configuration is basically\nnot to touch any responses, resulting in the browser's default behaviour.\n\nTo change settings, you need to put this type into gotham's [State]:\n\n```rust,no_run\n# use gotham::{router::builder::*, pipeline::{new_pipeline, single::single_pipeline}, state::State};\n# use gotham_restful::{*, cors::Origin};\n# #[cfg_attr(feature = \"cargo-clippy\", allow(clippy::needless_doctest_main))]\nfn main() {\n\tlet cors = CorsConfig {\n\t\torigin: Origin::Star,\n\t\t..Default::default()\n\t};\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(cors).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\t// your routing logic\n\t}));\n}\n```\n\nThis easy approach allows you to have one global cors configuration. If you prefer to have separate\nconfigurations for different scopes, you need to register the middleware inside your routing logic:\n\n```rust,no_run\n# use gotham::{router::builder::*, pipeline::*, pipeline::set::*, state::State};\n# use gotham_restful::{*, cors::Origin};\nlet pipelines = new_pipeline_set();\n\n// The first cors configuration\nlet cors_a = CorsConfig {\n\torigin: Origin::Star,\n\t..Default::default()\n};\nlet (pipelines, chain_a) = pipelines.add(\n\tnew_pipeline().add(cors_a).build()\n);\n\n// The second cors configuration\nlet cors_b = CorsConfig {\n\torigin: Origin::Copy,\n\t..Default::default()\n};\nlet (pipelines, chain_b) = pipelines.add(\n\tnew_pipeline().add(cors_b).build()\n);\n\nlet pipeline_set = finalize_pipeline_set(pipelines);\ngotham::start(\"127.0.0.1:8080\", build_router((), pipeline_set, |route| {\n\t// routing without any cors config\n\troute.with_pipeline_chain((chain_a, ()), |route| {\n\t\t// routing with cors config a\n\t});\n\troute.with_pipeline_chain((chain_b, ()), |route| {\n\t\t// routing with cors config b\n\t});\n}));\n```\n*/\n#[derive(Clone, Debug, Default, NewMiddleware, StateData)]\npub struct CorsConfig {\n\t/// The allowed origins.\n\tpub origin: Origin,\n\t/// The allowed headers.\n\tpub headers: Headers,\n\t/// The amount of seconds that the preflight request can be cached.\n\tpub max_age: u64,\n\t/// Whether or not the request may be made with supplying credentials.\n\tpub credentials: bool\n}\n\nimpl Middleware for CorsConfig {\n\tfn call<Chain>(self, mut state: State, chain: Chain) -> Pin<Box<HandlerFuture>>\n\twhere\n\t\tChain: FnOnce(State) -> Pin<Box<HandlerFuture>>\n\t{\n\t\tstate.put(self);\n\t\tchain(state)\n\t}\n}\n\n/**\nHandle CORS for a non-preflight request. This means manipulating the `res` HTTP headers so that\nthe response is aligned with the `state`'s [CorsConfig].\n\nIf you are using the [Resource](crate::Resource) type (which is the recommended way), you'll never\nhave to call this method. However, if you are writing your own handler method, you might want to\ncall this after your request to add the required CORS headers.\n\nFor further information on CORS, read <https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>.\n*/\npub fn handle_cors(state: &State, res: &mut Response<Body>) {\n\tlet config = CorsConfig::try_borrow_from(state);\n\tif let Some(cfg) = config {\n\t\tlet headers = res.headers_mut();\n\n\t\t// non-preflight requests require the Access-Control-Allow-Origin header\n\t\tif let Some(header) = cfg.origin.header_value(state) {\n\t\t\theaders.insert(ACCESS_CONTROL_ALLOW_ORIGIN, header);\n\t\t}\n\n\t\t// if the origin is copied over, we should tell the browser by specifying the Vary header\n\t\tif cfg.origin.varies() {\n\t\t\tlet vary = headers.get(VARY).map(|vary| format!(\"{},origin\", vary.to_str().unwrap()));\n\t\t\theaders.insert(VARY, vary.as_deref().unwrap_or(\"origin\").parse().unwrap());\n\t\t}\n\n\t\t// if we allow credentials, tell the browser\n\t\tif cfg.credentials {\n\t\t\theaders.insert(ACCESS_CONTROL_ALLOW_CREDENTIALS, HeaderValue::from_static(\"true\"));\n\t\t}\n\t}\n}\n\n/// Add CORS routing for your path. This is required for handling preflight requests.\n///\n/// Example:\n///\n/// ```rust,no_run\n/// # use gotham::{hyper::{Body, Method, Response}, router::builder::*};\n/// # use gotham_restful::*;\n/// build_simple_router(|router| {\n/// \t// The handler that needs preflight handling\n/// \trouter.post(\"/foo\").to(|state| {\n/// \t\tlet mut res : Response<Body> = unimplemented!();\n/// \t\thandle_cors(&state, &mut res);\n/// \t\t(state, res)\n/// \t});\n/// \t// Add preflight handling\n/// \trouter.cors(\"/foo\", Method::POST);\n/// });\n/// ```\npub trait CorsRoute<C, P>\nwhere\n\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\tP: RefUnwindSafe + Send + Sync + 'static\n{\n\t/// Handle a preflight request on `path` for `method`. To configure the behaviour, use\n\t/// [CorsConfig].\n\tfn cors(&mut self, path: &str, method: Method);\n}\n\npub(crate) fn cors_preflight_handler(state: State) -> (State, Response<Body>) {\n\tlet config = CorsConfig::try_borrow_from(&state);\n\n\t// prepare the response\n\tlet mut res = create_empty_response(&state, StatusCode::NO_CONTENT);\n\tlet headers = res.headers_mut();\n\tlet mut vary: Vec<HeaderName> = Vec::new();\n\n\t// copy the request method over to the response\n\tlet method = HeaderMap::borrow_from(&state)\n\t\t.get(ACCESS_CONTROL_REQUEST_METHOD)\n\t\t.unwrap()\n\t\t.clone();\n\theaders.insert(ACCESS_CONTROL_ALLOW_METHODS, method);\n\tvary.push(ACCESS_CONTROL_REQUEST_METHOD);\n\n\tif let Some(cfg) = config {\n\t\t// if we allow any headers, copy them over\n\t\tif let Some(header) = cfg.headers.header_value(&state) {\n\t\t\theaders.insert(ACCESS_CONTROL_ALLOW_HEADERS, header);\n\t\t}\n\n\t\t// if the headers are copied over, we should tell the browser by specifying the Vary header\n\t\tif cfg.headers.varies() {\n\t\t\tvary.push(ACCESS_CONTROL_REQUEST_HEADERS);\n\t\t}\n\n\t\t// set the max age for the preflight cache\n\t\tif let Some(age) = config.map(|cfg| cfg.max_age) {\n\t\t\theaders.insert(ACCESS_CONTROL_MAX_AGE, age.into());\n\t\t}\n\t}\n\n\t// make sure the browser knows that this request was based on the method\n\theaders.insert(VARY, vary.join(\",\").parse().unwrap());\n\n\thandle_cors(&state, &mut res);\n\t(state, res)\n}\n\nimpl<D, C, P> CorsRoute<C, P> for D\nwhere\n\tD: DrawRoutes<C, P>,\n\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\tP: RefUnwindSafe + Send + Sync + 'static\n{\n\tfn cors(&mut self, path: &str, method: Method) {\n\t\tlet matcher = AccessControlRequestMethodMatcher::new(method);\n\t\tself.options(path).extend_route_matcher(matcher).to(cors_preflight_handler);\n\t}\n}\n","traces":[{"line":40,"address":[2360400],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":41,"address":[2360403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[2360416],"length":1,"stats":{"Line":2},"fn_name":"header_value"},{"line":48,"address":[2360712,2360517,2360528,2360599],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[2360459,2360524],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[2360533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[2360609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[2360493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2360714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[2360800],"length":1,"stats":{"Line":2},"fn_name":"varies"},{"line":61,"address":[2360809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[2360848],"length":1,"stats":{"Line":2},"fn_name":"default"},{"line":83,"address":[2360851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[2360864,2361267],"length":1,"stats":{"Line":2},"fn_name":"header_value"},{"line":90,"address":[2360975,2360964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[2360907,2360971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[2361253,2360985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[2360940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[2361177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[2361312],"length":1,"stats":{"Line":2},"fn_name":"varies"},{"line":102,"address":[2361321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[1999056,1998384,1998988,1998652,1998720,1999324],"length":1,"stats":{"Line":4},"fn_name":"call<closure-0>"},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":198,"address":[2362159,2361360],"length":1,"stats":{"Line":6},"fn_name":"handle_cors"},{"line":199,"address":[2361393],"length":1,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[2361412],"length":1,"stats":{"Line":6},"fn_name":null},{"line":201,"address":[2361463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[2361492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[2361570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[2361733,2362187,2361672],"length":1,"stats":{"Line":6},"fn_name":null},{"line":210,"address":[2361743,2361682,2362288,2362326],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}"},{"line":211,"address":[2361757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[2362059,2362135,2362026],"length":1,"stats":{"Line":4},"fn_name":null},{"line":216,"address":[2362061,2362032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[2364337,2362528],"length":1,"stats":{"Line":2},"fn_name":"cors_preflight_handler"},{"line":250,"address":[2362570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[2362648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[2362680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[2362720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[2362747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[2362899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[2363047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[2363119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[2363179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[2363302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[2363459,2364365,2363550],"length":1,"stats":{"Line":5},"fn_name":null},{"line":273,"address":[2363478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[2364640,2363554,2363771,2364649],"length":1,"stats":{"Line":8},"fn_name":"{{closure}}"},{"line":278,"address":[2363647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[2364307,2363773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[2364077],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[2364104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":53,"coverable":58},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","endpoint.rs"],"content":"use crate::{IntoResponse, RequestBody};\nuse futures_util::future::BoxFuture;\nuse gotham::{\n\textractor::{PathExtractor, QueryStringExtractor},\n\thyper::{Body, Method, Response},\n\trouter::response::extender::StaticResponseExtender,\n\tstate::{State, StateData}\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\nuse serde::{Deserialize, Deserializer};\nuse std::borrow::Cow;\n\n/// A no-op extractor that can be used as a default type for [Endpoint::Placeholders] and\n/// [Endpoint::Params].\n#[derive(Debug, Clone, Copy)]\npub struct NoopExtractor;\n\nimpl<'de> Deserialize<'de> for NoopExtractor {\n\tfn deserialize<D: Deserializer<'de>>(_: D) -> Result<Self, D::Error> {\n\t\tOk(Self)\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl OpenapiType for NoopExtractor {\n\tfn schema() -> OpenapiSchema {\n\t\twarn!(\"You're asking for the OpenAPI Schema for gotham_restful::NoopExtractor. This is probably not what you want.\");\n\t\t<() as OpenapiType>::schema()\n\t}\n}\n\nimpl StateData for NoopExtractor {}\n\nimpl StaticResponseExtender for NoopExtractor {\n\ttype ResBody = Body;\n\tfn extend(_: &mut State, _: &mut Response<Body>) {}\n}\n\n// TODO: Specify default types once https://github.com/rust-lang/rust/issues/29661 lands.\n#[_private_openapi_trait(EndpointWithSchema)]\npub trait Endpoint {\n\t/// The HTTP Verb of this endpoint.\n\tfn http_method() -> Method;\n\t/// The URI that this endpoint listens on in gotham's format.\n\tfn uri() -> Cow<'static, str>;\n\n\t/// The verb used for generating an operation id if [Self::operation_id] returns [None].\n\t/// For example `read`, `read_all`, `create`, `update` etc.\n\t#[openapi_only]\n\tfn operation_verb() -> Option<&'static str>;\n\n\t/// The output type that provides the response.\n\t#[openapi_bound(\"Output: crate::ResponseSchema\")]\n\ttype Output: IntoResponse + Send;\n\n\t/// Returns `true` _iff_ the URI contains placeholders. `false` by default.\n\tfn has_placeholders() -> bool {\n\t\tfalse\n\t}\n\t/// The type that parses the URI placeholders. Use [NoopExtractor] if `has_placeholders()`\n\t/// returns `false`.\n\t#[openapi_bound(\"Placeholders: OpenapiType\")]\n\ttype Placeholders: PathExtractor<Body> + Clone + Sync;\n\n\t/// Returns `true` _iff_ the request parameters should be parsed. `false` by default.\n\tfn needs_params() -> bool {\n\t\tfalse\n\t}\n\t/// The type that parses the request parameters. Use [NoopExtractor] if `needs_params()`\n\t/// returns `false`.\n\t#[openapi_bound(\"Params: OpenapiType\")]\n\ttype Params: QueryStringExtractor<Body> + Clone + Sync;\n\n\t/// Returns `true` _iff_ the request body should be parsed. `false` by default.\n\tfn needs_body() -> bool {\n\t\tfalse\n\t}\n\t/// The type to parse the body into. Use `()` if `needs_body()` returns `false`.\n\ttype Body: RequestBody + Send;\n\n\t/// Returns `true` if the request wants to know the auth status of the client. `false` by default.\n\tfn wants_auth() -> bool {\n\t\tfalse\n\t}\n\n\t/// Replace the automatically generated operation id with a custom one. Only relevant for the\n\t/// OpenAPI Specification.\n\t#[openapi_only]\n\tfn operation_id() -> Option<String> {\n\t\tNone\n\t}\n\n\t/// Add a description to the openapi specification. Usually taken from the rustdoc comment\n\t/// when using the proc macro.\n\t#[openapi_only]\n\tfn description() -> Option<String> {\n\t\tNone\n\t}\n\n\t/// The handler for this endpoint.\n\tfn handle(\n\t\tstate: &mut State,\n\t\tplaceholders: Self::Placeholders,\n\t\tparams: Self::Params,\n\t\tbody: Option<Self::Body>\n\t) -> BoxFuture<'_, Self::Output>;\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<E: EndpointWithSchema> Endpoint for E {\n\tfn http_method() -> Method {\n\t\tE::http_method()\n\t}\n\tfn uri() -> Cow<'static, str> {\n\t\tE::uri()\n\t}\n\n\ttype Output = E::Output;\n\n\tfn has_placeholders() -> bool {\n\t\tE::has_placeholders()\n\t}\n\ttype Placeholders = E::Placeholders;\n\n\tfn needs_params() -> bool {\n\t\tE::needs_params()\n\t}\n\ttype Params = E::Params;\n\n\tfn needs_body() -> bool {\n\t\tE::needs_body()\n\t}\n\ttype Body = E::Body;\n\n\tfn wants_auth() -> bool {\n\t\tE::wants_auth()\n\t}\n\n\tfn handle<'a>(\n\t\tstate: &'a mut State,\n\t\tplaceholders: Self::Placeholders,\n\t\tparams: Self::Params,\n\t\tbody: Option<Self::Body>\n\t) -> BoxFuture<'a, Self::Output> {\n\t\tE::handle(state, placeholders, params, body)\n\t}\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":21,"address":[3355545,3355496],"length":1,"stats":{"Line":10},"fn_name":null},{"line":27,"address":[4019616],"length":1,"stats":{"Line":0},"fn_name":"schema"},{"line":28,"address":[4019708,4019630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[2477959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[2217824,2217837,2217842],"length":1,"stats":{"Line":0},"fn_name":"extend"},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[2569584],"length":1,"stats":{"Line":5},"fn_name":"operation_id<custom_request_body::create___gotham_restful_endpoint>"},{"line":91,"address":[2569587],"length":1,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[2569568],"length":1,"stats":{"Line":6},"fn_name":"description<custom_request_body::create___gotham_restful_endpoint>"},{"line":98,"address":[2569571],"length":1,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[2658432],"length":1,"stats":{"Line":29},"fn_name":"http_method<custom_request_body::create___gotham_restful_endpoint>"},{"line":113,"address":[2658440],"length":1,"stats":{"Line":29},"fn_name":null},{"line":115,"address":[2658464],"length":1,"stats":{"Line":29},"fn_name":"uri<custom_request_body::create___gotham_restful_endpoint>"},{"line":116,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":21},"fn_name":null}],"covered":14,"coverable":32},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms, unreachable_pub)]\n#![deny(warnings)]\n#![forbid(unsafe_code)]\n// can we have a lint for spaces in doc comments please?\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n// intra-doc links only fully work when OpenAPI is enabled\n#![cfg_attr(feature = \"openapi\", deny(broken_intra_doc_links))]\n#![cfg_attr(not(feature = \"openapi\"), allow(broken_intra_doc_links))]\n/*!\nThis crate is an extension to the popular [gotham web framework][gotham] for Rust. It allows you to\ncreate resources with assigned endpoints that aim to be a more convenient way of creating handlers\nfor requests.\n\n# Features\n\n - Automatically parse **JSON** request and produce response bodies\n - Allow using **raw** request and response bodies\n - Convenient **macros** to create responses that can be registered with gotham's router\n - Auto-Generate an **OpenAPI** specification for your API\n - Manage **CORS** headers so you don't have to\n - Manage **Authentication** with JWT\n - Integrate diesel connection pools for easy **database** integration\n\n# Safety\n\nThis crate is just as safe as you'd expect from anything written in safe Rust - and\n`#![forbid(unsafe_code)]` ensures that no unsafe was used.\n\n# Endpoints\n\nThere are a set of pre-defined endpoints that should cover the majority of REST APIs. However,\nit is also possible to define your own endpoints.\n\n## Pre-defined Endpoints\n\nAssuming you assign `/foobar` to your resource, the following pre-defined endpoints exist:\n\n| Endpoint Name | Required Arguments | HTTP Verb | HTTP Path      |\n| ------------- | ------------------ | --------- | -------------- |\n| read_all      |                    | GET       | /foobar        |\n| read          | id                 | GET       | /foobar/:id    |\n| search        | query              | GET       | /foobar/search |\n| create        | body               | POST      | /foobar        |\n| update_all    | body               | PUT       | /foobar        |\n| update        | id, body           | PUT       | /foobar/:id    |\n| delete_all    |                    | DELETE    | /foobar        |\n| delete        | id                 | DELETE    | /foobar/:id    |\n\nEach of those endpoints has a macro that creates the neccessary boilerplate for the Resource. A\nsimple example looks like this:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::router::builder::*;\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n/// Our RESTful resource.\n#[derive(Resource)]\n#[resource(read)]\nstruct FooResource;\n\n/// The return type of the foo read endpoint.\n#[derive(Serialize)]\n# #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct Foo {\n\tid: u64\n}\n\n/// The foo read endpoint.\n#[read]\nfn read(id: u64) -> Success<Foo> {\n\tFoo { id }.into()\n}\n# fn main() {\n# \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n# \t\troute.resource::<FooResource>(\"foo\");\n# \t}));\n# }\n```\n\n## Custom Endpoints\n\nDefining custom endpoints is done with the `#[endpoint]` macro. The syntax is similar to that\nof the pre-defined endpoints, but you need to give it more context:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_derive;\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::router::builder::*;\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(custom_endpoint)]\nstruct CustomResource;\n\n/// This type is used to parse path parameters.\n#[derive(Clone, Deserialize, StateData, StaticResponseExtender)]\n# #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct CustomPath {\n\tname: String\n}\n\n#[endpoint(uri = \"custom/:name/read\", method = \"Method::GET\", params = false, body = false)]\nfn custom_endpoint(path: CustomPath) -> Success<String> {\n\tpath.name.into()\n}\n# fn main() {\n# \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n# \t\troute.resource::<CustomResource>(\"custom\");\n# \t}));\n# }\n```\n\n# Arguments\n\nSome endpoints require arguments. Those should be\n * **id** Should be a deserializable json-primitive like [`i64`] or [`String`].\n * **body** Should be any deserializable object, or any type implementing [`RequestBody`].\n * **query** Should be any deserializable object whose variables are json-primitives. It will\n   however not be parsed from json, but from HTTP GET parameters like in `search?id=1`. The\n   type needs to implement [`QueryStringExtractor`](gotham::extractor::QueryStringExtractor).\n\nAdditionally, all handlers may take a reference to gotham's [`State`]. Please note that for async\nhandlers, it needs to be a mutable reference until rustc's lifetime checks across await bounds\nimprove.\n\n# Uploads and Downloads\n\nBy default, every request body is parsed from json, and every respone is converted to json using\n[serde_json]. However, you may also use raw bodies. This is an example where the request body\nis simply returned as the response again, no json parsing involved:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::router::builder::*;\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n#[derive(Resource)]\n#[resource(create)]\nstruct ImageResource;\n\n#[derive(FromBody, RequestBody)]\n#[supported_types(mime::IMAGE_GIF, mime::IMAGE_JPEG, mime::IMAGE_PNG)]\nstruct RawImage {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n\n#[create]\nfn create(body : RawImage) -> Raw<Vec<u8>> {\n\tRaw::new(body.content, body.content_type)\n}\n# fn main() {\n# \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n# \t\troute.resource::<ImageResource>(\"image\");\n# \t}));\n# }\n```\n\n# Custom HTTP Headers\n\nYou can read request headers from the state as you would in any other gotham handler, and specify\ncustom response headers using [Response::header].\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::hyper::header::{ACCEPT, HeaderMap, VARY};\n# use gotham::{router::builder::*, state::State};\n# use gotham_restful::*;\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nasync fn read_all(state: &mut State) -> NoContent {\n\tlet headers: &HeaderMap = state.borrow();\n\tlet accept = &headers[ACCEPT];\n# drop(accept);\n\n\tlet mut res = NoContent::default();\n\tres.header(VARY, \"accept\".parse().unwrap());\n\tres\n}\n# fn main() {\n# \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n# \t\troute.resource::<FooResource>(\"foo\");\n# \t}));\n# }\n```\n\n# Features\n\nTo make life easier for common use-cases, this create offers a few features that might be helpful\nwhen you implement your web server.  The complete feature list is\n - [`auth`](#authentication-feature) Advanced JWT middleware\n - `chrono` openapi support for chrono types\n - `full` enables all features except `without-openapi`\n - [`cors`](#cors-feature) CORS handling for all endpoint handlers\n - [`database`](#database-feature) diesel middleware support\n - `errorlog` log errors returned from endpoint handlers\n - [`openapi`](#openapi-feature) router additions to generate an openapi spec\n - `uuid` openapi support for uuid\n - `without-openapi` (**default**) disables `openapi` support.\n\n## Authentication Feature\n\nIn order to enable authentication support, enable the `auth` feature gate. This allows you to\nregister a middleware that can automatically check for the existence of an JWT authentication\ntoken. Besides being supported by the endpoint macros, it supports to lookup the required JWT secret\nwith the JWT data, hence you can use several JWT secrets and decide on the fly which secret to use.\nNone of this is currently supported by gotham's own JWT middleware.\n\nA simple example that uses only a single secret looks like this:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"auth\")]\n# mod auth_feature_enabled {\n# use gotham::{router::builder::*, pipeline::{new_pipeline, single::single_pipeline}, state::State};\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n#[derive(Resource)]\n#[resource(read)]\nstruct SecretResource;\n\n#[derive(Serialize)]\n# #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct Secret {\n\tid: u64,\n\tintended_for: String\n}\n\n#[derive(Deserialize, Clone)]\nstruct AuthData {\n\tsub: String,\n\texp: u64\n}\n\n#[read]\nfn read(auth: AuthStatus<AuthData>, id: u64) -> AuthSuccess<Secret> {\n\tlet intended_for = auth.ok()?.sub;\n\tOk(Secret { id, intended_for })\n}\n\nfn main() {\n\tlet auth: AuthMiddleware<AuthData, _> = AuthMiddleware::new(\n\t\tAuthSource::AuthorizationHeader,\n\t\tAuthValidation::default(),\n\t\tStaticAuthHandler::from_array(b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\")\n\t);\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(auth).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\troute.resource::<SecretResource>(\"secret\");\n\t}));\n}\n# }\n```\n\n## CORS Feature\n\nThe cors feature allows an easy usage of this web server from other origins. By default, only\nthe `Access-Control-Allow-Methods` header is touched. To change the behaviour, add your desired\nconfiguration as a middleware.\n\nA simple example that allows authentication from every origin (note that `*` always disallows\nauthentication), and every content type, looks like this:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"cors\")]\n# mod cors_feature_enabled {\n# use gotham::{hyper::header::*, router::builder::*, pipeline::{new_pipeline, single::single_pipeline}, state::State};\n# use gotham_restful::{*, cors::*};\n# use serde::{Deserialize, Serialize};\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() {\n\t// your handler\n}\n\nfn main() {\n\tlet cors = CorsConfig {\n\t\torigin: Origin::Copy,\n\t\theaders: Headers::List(vec![CONTENT_TYPE]),\n\t\tmax_age: 0,\n\t\tcredentials: true\n\t};\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(cors).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\troute.resource::<FooResource>(\"foo\");\n\t}));\n}\n# }\n```\n\nThe cors feature can also be used for non-resource handlers. Take a look at [`CorsRoute`]\nfor an example.\n\n## Database Feature\n\nThe database feature allows an easy integration of [diesel] into your handler functions. Please\nnote however that due to the way gotham's diesel middleware implementation, it is not possible\nto run async code while holding a database connection. If you need to combine async and database,\nyou'll need to borrow the connection from the [`State`] yourself and return a boxed future.\n\nA simple non-async example looks like this:\n\n```rust,no_run\n# #[macro_use] extern crate diesel;\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"database\")]\n# mod database_feature_enabled {\n# use diesel::{table, PgConnection, QueryResult, RunQueryDsl};\n# use gotham::{router::builder::*, pipeline::{new_pipeline, single::single_pipeline}, state::State};\n# use gotham_middleware_diesel::DieselMiddleware;\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n# use std::env;\n# table! {\n#   foo (id) {\n#     id -> Int8,\n#     value -> Text,\n#   }\n# }\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[derive(Queryable, Serialize)]\n# #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct Foo {\n\tid: i64,\n\tvalue: String\n}\n\n#[read_all]\nfn read_all(conn: &PgConnection) -> QueryResult<Vec<Foo>> {\n\tfoo::table.load(conn)\n}\n\ntype Repo = gotham_middleware_diesel::Repo<PgConnection>;\n\nfn main() {\n\tlet repo = Repo::new(&env::var(\"DATABASE_URL\").unwrap());\n\tlet diesel = DieselMiddleware::new(repo);\n\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(diesel).build());\n\tgotham::start(\"127.0.0.1:8080\", build_router(chain, pipelines, |route| {\n\t\troute.resource::<FooResource>(\"foo\");\n\t}));\n}\n# }\n```\n\n## OpenAPI Feature\n\nThe OpenAPI feature is probably the most powerful one of this crate. Definitely read this section\ncarefully both as a binary as well as a library author to avoid unwanted suprises.\n\nIn order to automatically create an openapi specification, gotham-restful needs knowledge over\nall routes and the types returned. `serde` does a great job at serialization but doesn't give\nenough type information, so all types used in the router need to implement\n[`OpenapiType`](openapi_type::OpenapiType). This can be derived for almoust any type and there\nshould be no need to implement it manually. A simple example looks like this:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"openapi\")]\n# mod openapi_feature_enabled {\n# use gotham::{router::builder::*, state::State};\n# use gotham_restful::*;\n# use openapi_type::OpenapiType;\n# use serde::{Deserialize, Serialize};\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[derive(OpenapiType, Serialize)]\nstruct Foo {\n\tbar: String\n}\n\n#[read_all]\nfn read_all() -> Success<Foo> {\n\tFoo { bar: \"Hello World\".to_owned() }.into()\n}\n\nfn main() {\n\tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n\t\tlet info = OpenapiInfo {\n\t\t\ttitle: \"My Foo API\".to_owned(),\n\t\t\tversion: \"0.1.0\".to_owned(),\n\t\t\turls: vec![\"https://example.org/foo/api/v1\".to_owned()]\n\t\t};\n\t\troute.with_openapi(info, |mut route| {\n\t\t\troute.resource::<FooResource>(\"foo\");\n\t\t\troute.openapi_spec(\"openapi\");\n\t\t\troute.openapi_doc(\"/\");\n\t\t});\n\t}));\n}\n# }\n```\n\nAbove example adds the resource as before, but adds two other endpoints as well: `/openapi` and `/`.\nThe first one will return the generated openapi specification in JSON format, allowing you to easily\ngenerate clients in different languages without worying to exactly replicate your api in each of those\nlanguages. The second one will return documentation in HTML format, so you can easily view your\napi and share it with other people.\n\nHowever, please note that by default, the `without-openapi` feature of this crate is enabled.\nDisabling it in favour of the `openapi` feature will add additional type bounds and method requirements\nto some of the traits and types in this crate, for example instead of [`Endpoint`] you now have to\nimplement [`EndpointWithSchema`]. This means that some code might only compile on either feature, but not\non both. If you are writing a library that uses gotham-restful, it is strongly recommended to pass both\nfeatures through and conditionally enable the openapi code, like this:\n\n```rust\n# #[macro_use] extern crate gotham_restful;\n# use serde::{Deserialize, Serialize};\n#[derive(Deserialize, Serialize)]\n#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct Foo;\n```\n\n [diesel]: https://diesel.rs/\n [`State`]: gotham::state::State\n*/\n\n#[cfg(all(feature = \"openapi\", feature = \"without-openapi\"))]\ncompile_error!(\"The 'openapi' and 'without-openapi' features cannot be combined\");\n\n#[cfg(all(not(feature = \"openapi\"), not(feature = \"without-openapi\")))]\ncompile_error!(\"Either the 'openapi' or 'without-openapi' feature needs to be enabled\");\n\n// weird proc macro issue\nextern crate self as gotham_restful;\n\n#[macro_use]\nextern crate gotham_derive;\n#[macro_use]\nextern crate gotham_restful_derive;\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate serde;\n\n#[cfg(test)]\n#[macro_use]\nextern crate pretty_assertions;\n\n#[doc(no_inline)]\npub use gotham;\n#[doc(no_inline)]\npub use mime::Mime;\n\npub use gotham_restful_derive::*;\n\n/// Not public API\n#[doc(hidden)]\npub mod private {\n\tpub use crate::routing::PathExtractor as IdPlaceholder;\n\n\tpub use futures_util::future::{BoxFuture, FutureExt};\n\n\tpub use serde_json;\n\n\t#[cfg(feature = \"database\")]\n\tpub use gotham_middleware_diesel::Repo;\n\t#[cfg(feature = \"openapi\")]\n\tpub use openapi_type::{indexmap::IndexMap, openapi, OpenapiSchema, OpenapiType};\n}\n\n#[cfg(feature = \"auth\")]\nmod auth;\n#[cfg(feature = \"auth\")]\npub use auth::{AuthHandler, AuthMiddleware, AuthSource, AuthStatus, AuthValidation, StaticAuthHandler};\n\n#[cfg(feature = \"cors\")]\npub mod cors;\n#[cfg(feature = \"cors\")]\npub use cors::{handle_cors, CorsConfig, CorsRoute};\n\n#[cfg(feature = \"openapi\")]\nmod openapi;\n#[cfg(feature = \"openapi\")]\npub use openapi::{builder::OpenapiInfo, router::GetOpenapi};\n\nmod endpoint;\n#[cfg(feature = \"openapi\")]\npub use endpoint::EndpointWithSchema;\npub use endpoint::{Endpoint, NoopExtractor};\n\nmod response;\npub use response::{\n\tAuthError, AuthError::Forbidden, AuthErrorOrOther, AuthResult, AuthSuccess, IntoResponse, IntoResponseError, NoContent,\n\tRaw, Redirect, Response, Success\n};\n#[cfg(feature = \"openapi\")]\npub use response::{IntoResponseWithSchema, ResponseSchema};\n\nmod routing;\npub use routing::{DrawResourceRoutes, DrawResources};\n#[cfg(feature = \"openapi\")]\npub use routing::{DrawResourceRoutesWithSchema, DrawResourcesWithSchema, WithOpenapi};\n\nmod types;\npub use types::{FromBody, RequestBody, ResponseBody};\n\n/// This trait must be implemented for every resource. It allows you to register the different\n/// endpoints that can be handled by this resource to be registered with the underlying router.\n///\n/// It is not recommended to implement this yourself, just use `#[derive(Resource)]`.\n#[_private_openapi_trait(ResourceWithSchema)]\npub trait Resource {\n\t/// Register all methods handled by this resource with the underlying router.\n\t#[openapi_bound(\"D: crate::DrawResourceRoutesWithSchema\")]\n\t#[non_openapi_bound(\"D: crate::DrawResourceRoutes\")]\n\tfn setup<D>(route: D);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","builder.rs"],"content":"use openapi_type::{\n\tindexmap::IndexMap,\n\topenapi::{\n\t\tself, Components, OpenAPI, PathItem, ReferenceOr,\n\t\tReferenceOr::{Item, Reference},\n\t\tSchema, Server\n\t},\n\tOpenapiSchema\n};\nuse parking_lot::RwLock;\nuse std::sync::Arc;\n\n#[derive(Clone, Debug)]\npub struct OpenapiInfo {\n\tpub title: String,\n\tpub version: String,\n\tpub urls: Vec<String>\n}\n\n#[derive(Clone, Debug)]\npub(crate) struct OpenapiBuilder {\n\tpub(crate) openapi: Arc<RwLock<OpenAPI>>\n}\n\nimpl OpenapiBuilder {\n\tpub(crate) fn new(info: OpenapiInfo) -> Self {\n\t\tSelf {\n\t\t\topenapi: Arc::new(RwLock::new(OpenAPI {\n\t\t\t\topenapi: \"3.0.2\".to_string(),\n\t\t\t\tinfo: openapi::Info {\n\t\t\t\t\ttitle: info.title,\n\t\t\t\t\tversion: info.version,\n\t\t\t\t\t..Default::default()\n\t\t\t\t},\n\t\t\t\tservers: info\n\t\t\t\t\t.urls\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|url| Server {\n\t\t\t\t\t\turl,\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t})\n\t\t\t\t\t.collect(),\n\t\t\t\t..Default::default()\n\t\t\t}))\n\t\t}\n\t}\n\n\t/// Remove path from the OpenAPI spec, or return an empty one if not included. This is handy if you need to\n\t/// modify the path and add it back after the modification\n\tpub(crate) fn remove_path(&mut self, path: &str) -> PathItem {\n\t\tlet mut openapi = self.openapi.write();\n\t\tmatch openapi.paths.swap_remove(path) {\n\t\t\tSome(Item(item)) => item,\n\t\t\t_ => PathItem::default()\n\t\t}\n\t}\n\n\tpub(crate) fn add_path<Path: ToString>(&mut self, path: Path, item: PathItem) {\n\t\tlet mut openapi = self.openapi.write();\n\t\topenapi.paths.insert(path.to_string(), Item(item));\n\t}\n\n\tfn add_schema_impl(&mut self, name: String, mut schema: OpenapiSchema) {\n\t\tself.add_schema_dependencies(&mut schema.dependencies);\n\n\t\tlet mut openapi = self.openapi.write();\n\t\tmatch &mut openapi.components {\n\t\t\tSome(comp) => {\n\t\t\t\tcomp.schemas.insert(name, Item(schema.into_schema()));\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\tlet mut comp = Components::default();\n\t\t\t\tcomp.schemas.insert(name, Item(schema.into_schema()));\n\t\t\t\topenapi.components = Some(comp);\n\t\t\t}\n\t\t};\n\t}\n\n\tfn add_schema_dependencies(&mut self, dependencies: &mut IndexMap<String, OpenapiSchema>) {\n\t\tlet keys: Vec<String> = dependencies.keys().map(|k| k.to_string()).collect();\n\t\tfor dep in keys {\n\t\t\tlet dep_schema = dependencies.swap_remove(&dep);\n\t\t\tif let Some(dep_schema) = dep_schema {\n\t\t\t\tself.add_schema_impl(dep, dep_schema);\n\t\t\t}\n\t\t}\n\t}\n\n\tpub(crate) fn add_schema(&mut self, mut schema: OpenapiSchema) -> ReferenceOr<Schema> {\n\t\tmatch schema.name.clone() {\n\t\t\tSome(name) => {\n\t\t\t\tlet reference = Reference {\n\t\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t\t};\n\t\t\t\tself.add_schema_impl(name, schema);\n\t\t\t\treference\n\t\t\t},\n\t\t\tNone => {\n\t\t\t\tself.add_schema_dependencies(&mut schema.dependencies);\n\t\t\t\tItem(schema.into_schema())\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[cfg(test)]\n#[allow(dead_code)]\nmod test {\n\tuse super::*;\n\tuse openapi_type::OpenapiType;\n\n\t#[derive(OpenapiType)]\n\tstruct Message {\n\t\tmsg: String\n\t}\n\n\t#[derive(OpenapiType)]\n\tstruct Messages {\n\t\tmsgs: Vec<Message>\n\t}\n\n\tfn info() -> OpenapiInfo {\n\t\tOpenapiInfo {\n\t\t\ttitle: \"TEST CASE\".to_owned(),\n\t\t\tversion: \"1.2.3\".to_owned(),\n\t\t\turls: vec![\"http://localhost:1234\".to_owned(), \"https://example.org\".to_owned()]\n\t\t}\n\t}\n\n\tfn openapi(builder: OpenapiBuilder) -> OpenAPI {\n\t\tArc::try_unwrap(builder.openapi).unwrap().into_inner()\n\t}\n\n\t#[test]\n\tfn new_builder() {\n\t\tlet info = info();\n\t\tlet builder = OpenapiBuilder::new(info.clone());\n\t\tlet openapi = openapi(builder);\n\n\t\tassert_eq!(info.title, openapi.info.title);\n\t\tassert_eq!(info.version, openapi.info.version);\n\t\tassert_eq!(info.urls.len(), openapi.servers.len());\n\t}\n\n\t#[test]\n\tfn add_schema() {\n\t\tlet mut builder = OpenapiBuilder::new(info());\n\t\tbuilder.add_schema(<Option<Messages>>::schema());\n\t\tlet openapi = openapi(builder);\n\n\t\tassert_eq!(\n\t\t\topenapi.components.clone().unwrap_or_default().schemas[\"Message\"],\n\t\t\tReferenceOr::Item(Message::schema().into_schema())\n\t\t);\n\t\tassert_eq!(\n\t\t\topenapi.components.clone().unwrap_or_default().schemas[\"Messages\"],\n\t\t\tReferenceOr::Item(Messages::schema().into_schema())\n\t\t);\n\t}\n}\n","traces":[{"line":26,"address":[2471520,2472846],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":28,"address":[2212103,2211458],"length":1,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[2213680,2214023],"length":1,"stats":{"Line":2},"fn_name":"remove_path"},{"line":51,"address":[2213750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[2473897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[2474011,2473966],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[2474322,2474001],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2475415,2474400],"length":1,"stats":{"Line":2},"fn_name":"add_schema_impl"},{"line":64,"address":[2474455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2474538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[2214466,2214541,2215349,2214792],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[2214501,2214561],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[2214569,2215432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[2214531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[2474955,2475529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[2475363,2475435,2475192,2475513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2476610,2475856],"length":1,"stats":{"Line":3},"fn_name":"add_schema_dependencies"},{"line":80,"address":[2476899,2476864,2475902],"length":1,"stats":{"Line":7},"fn_name":"{{closure}}"},{"line":81,"address":[2475989,2476583,2476185],"length":1,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[2476344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[2476379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[2476485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[2476928,2477586],"length":1,"stats":{"Line":3},"fn_name":"add_schema"},{"line":90,"address":[2477452,2476974,2477061],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[2477014,2477063],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[2477096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[2477327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[2477426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[2477044],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[2477459],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":33,"coverable":35},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","handler","mod.rs"],"content":"#![cfg_attr(not(feature = \"auth\"), allow(unused_imports))]\nuse super::SECURITY_NAME;\nuse either::Either;\nuse futures_util::{future, future::FutureExt};\nuse gotham::{\n\tanyhow,\n\thandler::{Handler, HandlerError, HandlerFuture, NewHandler},\n\thelpers::http::response::{create_empty_response, create_response},\n\thyper::{\n\t\theader::{\n\t\t\tHeaderMap, HeaderValue, CACHE_CONTROL, CONTENT_SECURITY_POLICY, ETAG, IF_NONE_MATCH, REFERRER_POLICY,\n\t\t\tX_CONTENT_TYPE_OPTIONS\n\t\t},\n\t\tBody, Response, StatusCode\n\t},\n\tstate::State\n};\nuse mime::{APPLICATION_JSON, TEXT_HTML_UTF_8, TEXT_PLAIN_UTF_8};\nuse openapi_type::{\n\tindexmap::IndexMap,\n\topenapi::{APIKeyLocation, OpenAPI, ReferenceOr, SecurityScheme}\n};\nuse parking_lot::RwLock;\nuse sha2::{Digest, Sha256};\nuse std::{io::Write, iter, panic::RefUnwindSafe, pin::Pin, sync::Arc};\n\n#[cfg(feature = \"auth\")]\nfn get_security(state: &State) -> IndexMap<String, ReferenceOr<SecurityScheme>> {\n\tuse crate::AuthSource;\n\tuse gotham::state::FromState;\n\n\tlet source = match AuthSource::try_borrow_from(state) {\n\t\tSome(source) => source,\n\t\tNone => return Default::default()\n\t};\n\n\tlet security_scheme = match source {\n\t\tAuthSource::Cookie(name) => SecurityScheme::APIKey {\n\t\t\tlocation: APIKeyLocation::Cookie,\n\t\t\tname: name.to_string()\n\t\t},\n\t\tAuthSource::Header(name) => SecurityScheme::APIKey {\n\t\t\tlocation: APIKeyLocation::Header,\n\t\t\tname: name.to_string()\n\t\t},\n\t\tAuthSource::AuthorizationHeader => SecurityScheme::HTTP {\n\t\t\tscheme: \"bearer\".to_owned(),\n\t\t\tbearer_format: Some(\"JWT\".to_owned())\n\t\t}\n\t};\n\n\tlet mut security_schemes: IndexMap<String, ReferenceOr<SecurityScheme>> = Default::default();\n\tsecurity_schemes.insert(SECURITY_NAME.to_owned(), ReferenceOr::Item(security_scheme));\n\n\tsecurity_schemes\n}\n\n#[cfg(not(feature = \"auth\"))]\nfn get_security(_state: &State) -> IndexMap<String, ReferenceOr<SecurityScheme>> {\n\tDefault::default()\n}\n\nfn openapi_string(state: &State, openapi: &Arc<RwLock<OpenAPI>>) -> Result<String, serde_json::Error> {\n\tlet openapi = openapi.read();\n\n\tlet mut openapi = openapi.clone();\n\tlet security_schemes = get_security(state);\n\tlet mut components = openapi.components.unwrap_or_default();\n\tcomponents.security_schemes = security_schemes;\n\topenapi.components = Some(components);\n\n\tserde_json::to_string(&openapi)\n}\n\nfn create_openapi_response(state: &State, openapi: &Arc<RwLock<OpenAPI>>) -> Response<Body> {\n\tmatch openapi_string(state, openapi) {\n\t\tOk(body) => {\n\t\t\tlet mut res = create_response(state, StatusCode::OK, APPLICATION_JSON, body);\n\t\t\tlet headers = res.headers_mut();\n\t\t\theaders.insert(X_CONTENT_TYPE_OPTIONS, HeaderValue::from_static(\"nosniff\"));\n\t\t\tres\n\t\t},\n\t\tErr(e) => {\n\t\t\terror!(\"Unable to handle OpenAPI request due to error: {}\", e);\n\t\t\tcreate_response(state, StatusCode::INTERNAL_SERVER_ERROR, TEXT_PLAIN_UTF_8, \"\")\n\t\t}\n\t}\n}\n\n#[derive(Clone)]\npub(crate) struct OpenapiSpecHandler {\n\topenapi: Arc<RwLock<OpenAPI>>\n}\n\n// safety: the handler only ever aquires a read lock, so this usage of\n// RwLock is, in fact, unwind safe\nimpl RefUnwindSafe for OpenapiSpecHandler {}\n\nimpl OpenapiSpecHandler {\n\tpub(crate) fn new(openapi: Arc<RwLock<OpenAPI>>) -> Self {\n\t\tSelf { openapi }\n\t}\n}\n\nimpl NewHandler for OpenapiSpecHandler {\n\ttype Instance = Self;\n\n\tfn new_handler(&self) -> anyhow::Result<Self> {\n\t\tOk(self.clone())\n\t}\n}\n\nimpl Handler for OpenapiSpecHandler {\n\tfn handle(self, mut state: State) -> Pin<Box<HandlerFuture>> {\n\t\tlet res = create_openapi_response(&mut state, &self.openapi);\n\t\tfuture::ok((state, res)).boxed()\n\t}\n}\n\n#[derive(Clone)]\npub(crate) struct OpenapiDocHandler {\n\topenapi: Arc<RwLock<OpenAPI>>\n}\n\n// safety: the handler only ever aquires a read lock, so this usage of\n// RwLock is, in fact, unwind safe\nimpl RefUnwindSafe for OpenapiDocHandler {}\n\nimpl OpenapiDocHandler {\n\tpub(crate) fn new(openapi: Arc<RwLock<OpenAPI>>) -> Self {\n\t\tSelf { openapi }\n\t}\n}\n\nimpl NewHandler for OpenapiDocHandler {\n\ttype Instance = Self;\n\n\tfn new_handler(&self) -> anyhow::Result<Self> {\n\t\tOk(self.clone())\n\t}\n}\n\nfn redoc_handler(state: &State, openapi: &Arc<RwLock<OpenAPI>>) -> Result<Response<Body>, HandlerError> {\n\tlet spec = openapi_string(state, openapi)?;\n\tlet encoded_spec = spec\n\t\t.chars()\n\t\t.flat_map(|c| match c {\n\t\t\t'&' => Either::Left(\"&amp;\".chars()),\n\t\t\t'<' => Either::Left(\"&lt;\".chars()),\n\t\t\t'>' => Either::Left(\"&gt;\".chars()),\n\t\t\tc => Either::Right(iter::once(c))\n\t\t})\n\t\t.collect::<String>();\n\n\tlet script = include_str!(\"script.min.js\");\n\tlet mut script_hash = Sha256::new();\n\tscript_hash.update(&script);\n\tlet script_hash = base64::encode(script_hash.finalize());\n\n\tlet mut buf = Vec::<u8>::new();\n\twrite!(\n\t\tbuf,\n\t\tr#\"<!DOCTYPE HTML><html><head><meta charset=\"utf-8\"/><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"/></head>\"#\n\t)?;\n\twrite!(\n\t\tbuf,\n\t\tr#\"<body style=\"margin:0\"><div id=\"spec\" style=\"display:none\">{}</div><div id=\"redoc\"></div><script>{}</script></body></html>\"#,\n\t\tencoded_spec, script\n\t)?;\n\n\tlet mut etag = Sha256::new();\n\tetag.update(&buf);\n\tlet etag = format!(\"\\\"{}\\\"\", base64::encode(etag.finalize()));\n\n\tif state\n\t\t.borrow::<HeaderMap>()\n\t\t.get(IF_NONE_MATCH)\n\t\t.map_or(false, |header| header.as_bytes() == etag.as_bytes())\n\t{\n\t\tlet res = create_empty_response(&state, StatusCode::NOT_MODIFIED);\n\t\treturn Ok(res);\n\t}\n\n\tlet mut res = create_response(state, StatusCode::OK, TEXT_HTML_UTF_8, buf);\n\tlet headers = res.headers_mut();\n\theaders.insert(CACHE_CONTROL, HeaderValue::from_static(\"public,max-age=2592000\"));\n\theaders.insert(\n\t\tCONTENT_SECURITY_POLICY,\n\t\tformat!(\n\t\t\t\"default-src 'none';base-uri 'none';script-src 'unsafe-inline' https://cdn.jsdelivr.net 'sha256-{}' 'strict-dynamic';style-src 'unsafe-inline' https://fonts.googleapis.com;font-src https://fonts.gstatic.com;connect-src 'self';img-src blob: data:\",\n\t\t\tscript_hash\n\t\t).parse().unwrap()\n\t);\n\theaders.insert(ETAG, etag.parse().unwrap());\n\theaders.insert(REFERRER_POLICY, HeaderValue::from_static(\"no-referrer\"));\n\theaders.insert(X_CONTENT_TYPE_OPTIONS, HeaderValue::from_static(\"nosniff\"));\n\tOk(res)\n}\n\nimpl Handler for OpenapiDocHandler {\n\tfn handle(self, state: State) -> Pin<Box<HandlerFuture>> {\n\t\tmatch redoc_handler(&state, &self.openapi) {\n\t\t\tOk(res) => future::ok((state, res)).boxed(),\n\t\t\tErr(err) => future::err((state, err)).boxed()\n\t\t}\n\t}\n}\n","traces":[{"line":28,"address":[2364672,2365509],"length":1,"stats":{"Line":2},"fn_name":"get_security"},{"line":32,"address":[2364710,2364765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[2364767,2364729],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[2364754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[2364958,2365065,2364855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[2364882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[2364988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[2364825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[2365070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[2365239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2365258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[2365440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[2366101,2365632],"length":1,"stats":{"Line":2},"fn_name":"openapi_string"},{"line":64,"address":[2365689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[2365748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[2365810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2365825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[2366116,2365908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[2366243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[2366370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[2368081,2367088],"length":1,"stats":{"Line":2},"fn_name":"create_openapi_response"},{"line":76,"address":[2367126,2367541,2367204],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[2367206,2367136],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[2367239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[2367346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2367386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[2367523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[2367148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[2367161,2367546,2367632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[2367893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[2368144],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":108,"address":[2368176],"length":1,"stats":{"Line":2},"fn_name":"new_handler"},{"line":109,"address":[2368185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[2368240,2368553],"length":1,"stats":{"Line":2},"fn_name":"handle"},{"line":115,"address":[2368283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[2368257,2368295],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[2368624],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":138,"address":[2368656],"length":1,"stats":{"Line":0},"fn_name":"new_handler"},{"line":139,"address":[2368665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[2368720,2372745],"length":1,"stats":{"Line":0},"fn_name":"redoc_handler"},{"line":144,"address":[2368759,2368928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[2369022,2368899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[2373211,2373328,2373272,2373072],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":148,"address":[2373155,2373099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[2373216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[2373274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[2373339,2373136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[2369113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2369140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[2369159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[2369186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[2369352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[2369745,2369371,2369852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[2369911,2370397,2369641,2370290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[2370271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[2370416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2372671,2370443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[2370957,2370832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[2373392,2370949,2373360],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":180,"address":[2370994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[2371251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[2371029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[2371319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[2371359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[2371782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[2371499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[2371909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[2372100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[2372232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[2372406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[2373472,2374101],"length":1,"stats":{"Line":0},"fn_name":"handle"},{"line":202,"address":[2373489,2373709,2373986,2374043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[2373711,2373522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[2373988,2373543],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":30,"coverable":74},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","mod.rs"],"content":"const SECURITY_NAME: &str = \"authToken\";\n\npub(crate) mod builder;\npub(crate) mod handler;\npub(crate) mod operation;\npub(crate) mod router;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","operation.rs"],"content":"use super::SECURITY_NAME;\nuse crate::{response::OrAllTypes, EndpointWithSchema, IntoResponse, RequestBody};\nuse gotham::hyper::StatusCode;\nuse mime::Mime;\nuse openapi_type::{\n\tindexmap::IndexMap,\n\topenapi::{\n\t\tMediaType, Operation, Parameter, ParameterData, ParameterSchemaOrContent, ReferenceOr, ReferenceOr::Item,\n\t\tRequestBody as OARequestBody, Response, Responses, Schema, SchemaKind, StatusCode as OAStatusCode, Type\n\t},\n\tOpenapiSchema\n};\nuse std::collections::HashMap;\n\nfn new_parameter_data(name: String, required: bool, schema: ReferenceOr<Box<Schema>>) -> ParameterData {\n\tParameterData {\n\t\tname,\n\t\tdescription: None,\n\t\trequired,\n\t\tdeprecated: None,\n\t\tformat: ParameterSchemaOrContent::Schema(schema.unbox()),\n\t\texample: None,\n\t\texamples: Default::default(),\n\t\textensions: Default::default()\n\t}\n}\n\n#[derive(Default)]\nstruct OperationParams {\n\tpath_params: Option<OpenapiSchema>,\n\tquery_params: Option<OpenapiSchema>\n}\n\nimpl OperationParams {\n\tfn add_path_params(path_params: Option<OpenapiSchema>, params: &mut Vec<ReferenceOr<Parameter>>) {\n\t\tlet path_params = match path_params {\n\t\t\tSome(pp) => pp.schema,\n\t\t\tNone => return\n\t\t};\n\t\tlet path_params = match path_params {\n\t\t\tSchemaKind::Type(Type::Object(ty)) => ty,\n\t\t\t_ => panic!(\"Path Parameters needs to be a plain struct\")\n\t\t};\n\t\tfor (name, schema) in path_params.properties {\n\t\t\tlet required = path_params.required.contains(&name);\n\t\t\tparams.push(Item(Parameter::Path {\n\t\t\t\tparameter_data: new_parameter_data(name, required, schema),\n\t\t\t\tstyle: Default::default()\n\t\t\t}))\n\t\t}\n\t}\n\n\tfn add_query_params(query_params: Option<OpenapiSchema>, params: &mut Vec<ReferenceOr<Parameter>>) {\n\t\tlet query_params = match query_params {\n\t\t\tSome(qp) => qp.schema,\n\t\t\tNone => return\n\t\t};\n\t\tlet query_params = match query_params {\n\t\t\tSchemaKind::Type(Type::Object(ty)) => ty,\n\t\t\t_ => panic!(\"Query Parameters needs to be a plain struct\")\n\t\t};\n\t\tfor (name, schema) in query_params.properties {\n\t\t\tlet required = query_params.required.contains(&name);\n\t\t\tparams.push(Item(Parameter::Query {\n\t\t\t\tparameter_data: new_parameter_data(name, required, schema),\n\t\t\t\tallow_reserved: false,\n\t\t\t\tstyle: Default::default(),\n\t\t\t\tallow_empty_value: None\n\t\t\t}))\n\t\t}\n\t}\n\n\tfn into_params(self) -> Vec<ReferenceOr<Parameter>> {\n\t\tlet mut params: Vec<ReferenceOr<Parameter>> = Vec::new();\n\t\tSelf::add_path_params(self.path_params, &mut params);\n\t\tSelf::add_query_params(self.query_params, &mut params);\n\t\tparams\n\t}\n}\n\npub(crate) struct OperationDescription {\n\toperation_id: Option<String>,\n\tdescription: Option<String>,\n\n\taccepted_types: Option<Vec<Mime>>,\n\tresponses: HashMap<StatusCode, ReferenceOr<Schema>>,\n\tparams: OperationParams,\n\tbody_schema: Option<ReferenceOr<Schema>>,\n\tsupported_types: Option<Vec<Mime>>,\n\trequires_auth: bool\n}\n\nimpl OperationDescription {\n\t/// Create a new operation description for the given endpoint type and schema. If the endpoint\n\t/// does not specify an operation id, the path is used to generate one.\n\tpub(crate) fn new<E: EndpointWithSchema>(responses: HashMap<StatusCode, ReferenceOr<Schema>>, path: &str) -> Self {\n\t\tlet operation_id = E::operation_id().or_else(|| {\n\t\t\tE::operation_verb().map(|verb| format!(\"{}_{}\", verb, path.replace(\"/\", \"_\").trim_start_matches('_')))\n\t\t});\n\t\tSelf {\n\t\t\toperation_id,\n\t\t\tdescription: E::description(),\n\n\t\t\taccepted_types: E::Output::accepted_types(),\n\t\t\tresponses,\n\t\t\tparams: Default::default(),\n\t\t\tbody_schema: None,\n\t\t\tsupported_types: None,\n\t\t\trequires_auth: E::wants_auth()\n\t\t}\n\t}\n\n\tpub(crate) fn set_path_params(&mut self, params: OpenapiSchema) {\n\t\tself.params.path_params = Some(params);\n\t}\n\n\tpub(crate) fn set_query_params(&mut self, params: OpenapiSchema) {\n\t\tself.params.query_params = Some(params);\n\t}\n\n\tpub(crate) fn set_body<Body: RequestBody>(&mut self, schema: ReferenceOr<Schema>) {\n\t\tself.body_schema = Some(schema);\n\t\tself.supported_types = Body::supported_types();\n\t}\n\n\tfn schema_to_content(types: Vec<Mime>, schema: ReferenceOr<Schema>) -> IndexMap<String, MediaType> {\n\t\tlet mut content: IndexMap<String, MediaType> = IndexMap::new();\n\t\tfor ty in types {\n\t\t\tcontent.insert(ty.to_string(), MediaType {\n\t\t\t\tschema: Some(schema.clone()),\n\t\t\t\t..Default::default()\n\t\t\t});\n\t\t}\n\t\tcontent\n\t}\n\n\tpub(crate) fn into_operation(self) -> Operation {\n\t\t// this is unfortunately neccessary to prevent rust from complaining about partially moving self\n\t\tlet (operation_id, description, accepted_types, responses, params, body_schema, supported_types, requires_auth) = (\n\t\t\tself.operation_id,\n\t\t\tself.description,\n\t\t\tself.accepted_types,\n\t\t\tself.responses,\n\t\t\tself.params,\n\t\t\tself.body_schema,\n\t\t\tself.supported_types,\n\t\t\tself.requires_auth\n\t\t);\n\n\t\tlet responses: IndexMap<OAStatusCode, ReferenceOr<Response>> = responses\n\t\t\t.into_iter()\n\t\t\t.map(|(code, schema)| {\n\t\t\t\tlet content = Self::schema_to_content(accepted_types.clone().or_all_types(), schema);\n\t\t\t\t(\n\t\t\t\t\tOAStatusCode::Code(code.as_u16()),\n\t\t\t\t\tItem(Response {\n\t\t\t\t\t\tdescription: code.canonical_reason().map(|d| d.to_string()).unwrap_or_default(),\n\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t})\n\t\t\t.collect();\n\n\t\tlet request_body = body_schema.map(|schema| {\n\t\t\tItem(OARequestBody {\n\t\t\t\tcontent: Self::schema_to_content(supported_types.or_all_types(), schema),\n\t\t\t\trequired: true,\n\t\t\t\t..Default::default()\n\t\t\t})\n\t\t});\n\n\t\tlet mut security = Vec::new();\n\t\tif requires_auth {\n\t\t\tlet mut sec = IndexMap::new();\n\t\t\tsec.insert(SECURITY_NAME.to_owned(), Vec::new());\n\t\t\tsecurity.push(sec);\n\t\t}\n\n\t\tOperation {\n\t\t\ttags: Vec::new(),\n\t\t\toperation_id,\n\t\t\tdescription,\n\t\t\tparameters: params.into_params(),\n\t\t\trequest_body,\n\t\t\tresponses: Responses {\n\t\t\t\tdefault: None,\n\t\t\t\tresponses\n\t\t\t},\n\t\t\tdeprecated: false,\n\t\t\tsecurity,\n\t\t\t..Default::default()\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse crate::{NoContent, Raw, ResponseSchema};\n\n\t#[test]\n\tfn no_content_schema_to_content() {\n\t\tlet types = NoContent::accepted_types();\n\t\tlet schema = <NoContent as ResponseSchema>::schema(StatusCode::NO_CONTENT);\n\t\tlet content = OperationDescription::schema_to_content(types.or_all_types(), Item(schema.into_schema()));\n\t\tassert!(content.is_empty());\n\t}\n\n\t#[test]\n\tfn raw_schema_to_content() {\n\t\tlet types = Raw::<&str>::accepted_types();\n\t\tlet schema = <Raw<&str> as ResponseSchema>::schema(StatusCode::OK);\n\t\tlet content = OperationDescription::schema_to_content(types.or_all_types(), Item(schema.into_schema()));\n\t\tassert_eq!(content.len(), 1);\n\t\tlet json = serde_json::to_string(&content.values().nth(0).unwrap()).unwrap();\n\t\tassert_eq!(json, r#\"{\"schema\":{\"type\":\"string\",\"format\":\"binary\"}}\"#);\n\t}\n}\n","traces":[{"line":15,"address":[2374689,2374192],"length":1,"stats":{"Line":1},"fn_name":"new_parameter_data"},{"line":21,"address":[2374267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[2374361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[2374380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[2374784,2376565],"length":1,"stats":{"Line":2},"fn_name":"add_path_params"},{"line":36,"address":[2374815,2374888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[2374925,2374855,2376140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[2376123,2374979,2375020],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[2376031,2375095,2375355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[2375661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[2375881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[2375747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[2375864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[2378581,2376784],"length":1,"stats":{"Line":2},"fn_name":"add_query_params"},{"line":54,"address":[2376888,2376815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[2376855,2376925,2378156],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[2378139,2376979,2377020],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[2377355,2378047,2377095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[2377661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[2377881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[2377747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[2377864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2379012,2378800],"length":1,"stats":{"Line":2},"fn_name":"into_params"},{"line":74,"address":[2378825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[2378873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[2378927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":113,"address":[2379261,2379136],"length":1,"stats":{"Line":1},"fn_name":"set_path_params"},{"line":114,"address":[2379190,2379281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[2379344,2379475],"length":1,"stats":{"Line":1},"fn_name":"set_query_params"},{"line":118,"address":[2379398,2379495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[2380704,2379552],"length":1,"stats":{"Line":3},"fn_name":"schema_to_content"},{"line":127,"address":[2379591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[2379798,2380591,2379631],"length":1,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[2380200,2380329],"length":1,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[2380232],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[2380289],"length":1,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[2381040,2383780],"length":1,"stats":{"Line":2},"fn_name":"into_operation"},{"line":139,"address":[2381406,2381068],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[2381156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[2381179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[2381203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[2381227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[2381263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[2381314],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[2381366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[2381396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[2381930,2382029],"length":1,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[2382021,2385880,2384955,2384912],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":153,"address":[2385015],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[2385145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[2385374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[2384864,2385183,2384886],"length":1,"stats":{"Line":6},"fn_name":"{{closure}}"},{"line":158,"address":[2385271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[2385367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[2382099,2386112,2386538],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":166,"address":[2386289,2386137],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[2386153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[2386277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[2382222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[2382245,2382278],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[2382259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[2382283,2384199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[2382424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[2382547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[2382646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[2382878],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":76,"coverable":85},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","openapi","router.rs"],"content":"use super::{\n\tbuilder::OpenapiBuilder,\n\thandler::{OpenapiDocHandler, OpenapiSpecHandler},\n\toperation::OperationDescription\n};\nuse crate::{routing::*, EndpointWithSchema, ResourceWithSchema, ResponseSchema};\nuse gotham::{\n\thyper::{Method, StatusCode},\n\tpipeline::chain::PipelineHandleChain,\n\trouter::builder::*\n};\nuse lazy_regex::regex_replace_all;\nuse openapi_type::OpenapiType;\nuse std::{collections::HashMap, panic::RefUnwindSafe};\n\n/// This trait adds the `openapi_spec` and `openapi_doc` method to an OpenAPI-aware router.\npub trait GetOpenapi {\n\t/// Register a GET route to `path` that returns the OpenAPI specification in JSON format.\n\tfn openapi_spec(&mut self, path: &str);\n\n\t/// Register a GET route to `path` that returns the OpenAPI documentation in HTML format.\n\tfn openapi_doc(&mut self, path: &str);\n}\n\n#[derive(Debug)]\npub struct OpenapiRouter<'a, D> {\n\tpub(crate) router: &'a mut D,\n\tpub(crate) scope: Option<&'a str>,\n\tpub(crate) openapi_builder: &'a mut OpenapiBuilder\n}\n\nmacro_rules! implOpenapiRouter {\n\t($implType:ident) => {\n\t\timpl<'a, 'b, C, P> OpenapiRouter<'a, $implType<'b, C, P>>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tpub fn scope<F>(&mut self, path: &str, callback: F)\n\t\t\twhere\n\t\t\t\tF: FnOnce(&mut OpenapiRouter<'_, ScopeBuilder<'_, C, P>>)\n\t\t\t{\n\t\t\t\tlet mut openapi_builder = self.openapi_builder.clone();\n\t\t\t\tlet new_scope = self.scope.map(|scope| format!(\"{}/{}\", scope, path).replace(\"//\", \"/\"));\n\t\t\t\tself.router.scope(path, |router| {\n\t\t\t\t\tlet mut router = OpenapiRouter {\n\t\t\t\t\t\trouter,\n\t\t\t\t\t\tscope: Some(new_scope.as_ref().map(String::as_ref).unwrap_or(path)),\n\t\t\t\t\t\topenapi_builder: &mut openapi_builder\n\t\t\t\t\t};\n\t\t\t\t\tcallback(&mut router);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, 'b, C, P> GetOpenapi for OpenapiRouter<'a, $implType<'b, C, P>>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn openapi_spec(&mut self, path: &str) {\n\t\t\t\tself.router\n\t\t\t\t\t.get(path)\n\t\t\t\t\t.to_new_handler(OpenapiSpecHandler::new(self.openapi_builder.openapi.clone()));\n\t\t\t}\n\n\t\t\tfn openapi_doc(&mut self, path: &str) {\n\t\t\t\tself.router\n\t\t\t\t\t.get(path)\n\t\t\t\t\t.to_new_handler(OpenapiDocHandler::new(self.openapi_builder.openapi.clone()));\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, 'b, C, P> DrawResourcesWithSchema for OpenapiRouter<'a, $implType<'b, C, P>>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn resource<R: ResourceWithSchema>(&mut self, mut path: &str) {\n\t\t\t\tif path.starts_with('/') {\n\t\t\t\t\tpath = &path[1..];\n\t\t\t\t}\n\t\t\t\tR::setup((self, path));\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, 'b, C, P> DrawResourceRoutesWithSchema for (&mut OpenapiRouter<'a, $implType<'b, C, P>>, &str)\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn endpoint<E: EndpointWithSchema + 'static>(&mut self) {\n\t\t\t\tlet mut responses: HashMap<StatusCode, _> = HashMap::new();\n\t\t\t\tfor code in E::Output::status_codes() {\n\t\t\t\t\tresponses.insert(code, (self.0).openapi_builder.add_schema(E::Output::schema(code)));\n\t\t\t\t}\n\t\t\t\tlet mut path = format!(\"{}/{}\", self.0.scope.unwrap_or_default(), self.1);\n\t\t\t\tlet mut descr = OperationDescription::new::<E>(responses, &path);\n\t\t\t\tif E::has_placeholders() {\n\t\t\t\t\tdescr.set_path_params(E::Placeholders::schema());\n\t\t\t\t}\n\t\t\t\tif E::needs_params() {\n\t\t\t\t\tdescr.set_query_params(E::Params::schema());\n\t\t\t\t}\n\t\t\t\tif E::needs_body() {\n\t\t\t\t\tlet body_schema = (self.0).openapi_builder.add_schema(E::Body::schema());\n\t\t\t\t\tdescr.set_body::<E::Body>(body_schema);\n\t\t\t\t}\n\n\t\t\t\tlet uri: &str = &E::uri();\n\t\t\t\tlet uri = regex_replace_all!(r#\"(^|/):([^/]+)(/|$)\"#, uri, |_, prefix, name, suffix| {\n\t\t\t\t\tformat!(\"{}{{{}}}{}\", prefix, name, suffix)\n\t\t\t\t});\n\t\t\t\tif !uri.is_empty() {\n\t\t\t\t\tpath = format!(\"{}/{}\", path, uri);\n\t\t\t\t}\n\n\t\t\t\tlet op = descr.into_operation();\n\t\t\t\tlet mut item = (self.0).openapi_builder.remove_path(&path);\n\t\t\t\tmatch E::http_method() {\n\t\t\t\t\tMethod::GET => item.get = Some(op),\n\t\t\t\t\tMethod::PUT => item.put = Some(op),\n\t\t\t\t\tMethod::POST => item.post = Some(op),\n\t\t\t\t\tMethod::DELETE => item.delete = Some(op),\n\t\t\t\t\tMethod::OPTIONS => item.options = Some(op),\n\t\t\t\t\tMethod::HEAD => item.head = Some(op),\n\t\t\t\t\tMethod::PATCH => item.patch = Some(op),\n\t\t\t\t\tMethod::TRACE => item.trace = Some(op),\n\t\t\t\t\tmethod => warn!(\"Ignoring unsupported method '{}' in OpenAPI Specification\", method)\n\t\t\t\t};\n\t\t\t\t(self.0).openapi_builder.add_path(path, item);\n\n\t\t\t\t(&mut *(self.0).router, self.1).endpoint::<E>()\n\t\t\t}\n\t\t}\n\t};\n}\n\nimplOpenapiRouter!(RouterBuilder);\nimplOpenapiRouter!(ScopeBuilder);\n","traces":[{"line":39,"address":[3316416,3317456,3316651,3317691],"length":1,"stats":{"Line":2},"fn_name":"scope<(),(),closure-0>"},{"line":43,"address":[3317485,3316445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[3316488,3316736,3316771,3317776,3317528,3317811],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}<(),(),closure-0>"},{"line":45,"address":[3317567,3317405,3316527,3318445,3318208,3317168],"length":1,"stats":{"Line":4},"fn_name":"{{closure}}<(),(),closure-0>"},{"line":46,"address":[3318233,3318380,3317340,3317193],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[3318243,3317203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[3317336,3318376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[3317370,3318410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[3583337,3583200],"length":1,"stats":{"Line":2},"fn_name":"openapi_spec<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()),(gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ())>"},{"line":62,"address":[3583310,3583230],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[3583258,3583327,3583349],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[3583392,3583744,3583568],"length":1,"stats":{"Line":5},"fn_name":"resource<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()),(gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()),openapi_specification::ImageResource>"},{"line":80,"address":[3583416,3583499,3583675,3583768,3583851,3583592],"length":1,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[3583627,3583686,3583451,3583510,3583803,3583862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[3583877,3583701,3583525],"length":1,"stats":{"Line":5},"fn_name":null},{"line":92,"address":[3598198,3625120,3618880,3629434,3600144,3610702,3604450,3616942,3593888,3623182,3612640,3606400],"length":1,"stats":{"Line":8},"fn_name":"endpoint<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()),(gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()),openapi_specification::custom_read_with___gotham_restful_endpoint>"},{"line":93,"address":[3612669,3606429,3600173,3618909,3593917,3625149],"length":1,"stats":{"Line":8},"fn_name":null},{"line":94,"address":[3612995,3600503,3619414,3625662,3600314,3594058,3600686,3613174,3606578,3606934,3594247,3625479,3619235,3619058,3625290,3606755,3612818,3594430],"length":1,"stats":{"Line":16},"fn_name":null},{"line":95,"address":[3613045,3619285,3594297,3600553,3625529,3606805],"length":1,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[3606947,3594443,3619427,3600699,3613187,3625675],"length":1,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[3599579,3624563,3594881,3626113,3601137,3630815,3612083,3613625,3605831,3618323,3619865,3607385],"length":1,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[3607626,3601301,3601345,3613862,3620102,3626277,3601374,3620073,3595089,3595118,3607549,3607597,3595045,3613833,3613789,3626325,3626354,3620029],"length":1,"stats":{"Line":16},"fn_name":null},{"line":100,"address":[3607578,3595082,3601338,3595091,3607599,3601347,3613826,3613835,3620066,3620075,3626327,3626306],"length":1,"stats":{"Line":8},"fn_name":null},{"line":102,"address":[3595197,3613941,3601424,3607672,3607701,3620104,3626433,3626404,3620181,3601376,3620152,3626356,3613864,3601453,3607628,3595120,3613912,3595168],"length":1,"stats":{"Line":16},"fn_name":null},{"line":103,"address":[3613914,3620154,3601426,3607665,3607674,3626385,3626406,3595149,3620133,3601405,3595170,3613893],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[3595270,3601522,3601455,3595199,3607872,3626435,3595368,3626506,3613943,3620352,3620254,3607774,3626604,3614112,3601620,3607703,3620183,3614014],"length":1,"stats":{"Line":16},"fn_name":null},{"line":106,"address":[3595280,3601532,3607784,3613980,3601492,3626472,3614024,3595236,3626516,3620264,3620220,3607740],"length":1,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[3620327,3601595,3595343,3614087,3626579,3607847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[3601630,3607882,3614122,3620362,3595378,3626614],"length":1,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[2087452,2087708,2087919,2087663,2087440,2087696],"length":1,"stats":{"Line":58},"fn_name":"{{closure}}"},{"line":112,"address":[3636141,3635645,3635117,3636733,3637165,3634557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[3595749,3614493,3620533,3595549,3620733,3629566,3598330,3608053,3601801,3608253,3614293,3617074,3623314,3626785,3610834,3604582,3602001,3626985],"length":1,"stats":{"Line":16},"fn_name":null},{"line":115,"address":[3610717,3598213,3608298,3616957,3629449,3595794,3627030,3614538,3601897,3604465,3626881,3614389,3608149,3595645,3602046,3620629,3623197,3620778],"length":1,"stats":{"Line":10},"fn_name":null},{"line":118,"address":[3621002,3614762,3596018,3608522,3627254,3602270],"length":1,"stats":{"Line":8},"fn_name":null},{"line":119,"address":[3596107,3608611,3602359,3614851,3621091,3627343],"length":1,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[3604844,3629828,3623668,3630104,3629920,3621267,3608787,3630012,3599046,3598868,3617790,3630282,3611464,3623576,3605298,3611188,3604660,3604936,3605028,3629644,3611096,3617704,3605212,3617428,3611550,3611280,3598500,3617520,3630196,3623760,3596283,3602535,3598776,3617244,3629736,3598960,3598684,3611004,3623392,3598408,3598592,3605120,3615027,3617336,3611372,3617612,3623484,3623852,3610912,3604752,3617152,3623944,3624030,3627519],"length":1,"stats":{"Line":16},"fn_name":null},{"line":121,"address":[3621414,3629571,3615174,3598335,3596430,3604587,3623319,3617079,3615034,3621274,3602682,3596290,3602542,3610839,3608934,3627666,3608794,3627526],"length":1,"stats":{"Line":14},"fn_name":null},{"line":122,"address":[3610917,3623397,3621532,3602800,3627784,3604665,3615292,3598413,3609052,3596548,3617157,3629649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[3611009,3629741,3604757,3609170,3617249,3602918,3615410,3623489,3598505,3596666,3621650,3627902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[3609288,3621768,3623581,3617341,3604849,3598597,3596784,3615528,3603036,3611101,3629833,3628020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[3617433,3628138,3609406,3596902,3598689,3615646,3623673,3629925,3604941,3603154,3611193,3621886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[3598781,3623765,3605033,3622004,3630017,3611285,3609524,3597020,3603272,3615764,3617525,3628256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[3622104,3603372,3615864,3623857,3609624,3628356,3630109,3597120,3598873,3605125,3611377,3617617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[3615964,3603472,3598962,3617706,3622204,3609724,3623946,3597220,3605214,3611466,3628456,3630198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[3604361,3608848,3621328,3610613,3616150,3616853,3615088,3622390,3623093,3628642,3597406,3609824,3616064,3602596,3627580,3622304,3629345,3598109,3603572,3603658,3597320,3609910,3628556,3596344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[3597702,3622686,3616446,3610206,3628938,3603954],"length":1,"stats":{"Line":8},"fn_name":null},{"line":133,"address":[3610396,3629128,3616636,3597892,3604144,3622876],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":41,"coverable":47},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","auth_result.rs"],"content":"use gotham_restful_derive::ResourceError;\n\n/**\nThis is an error type that always yields a _403 Forbidden_ response. This type is best used in\ncombination with [AuthSuccess] or [AuthResult].\n*/\n#[derive(Debug, Clone, Copy, ResourceError)]\npub enum AuthError {\n\t#[status(FORBIDDEN)]\n\t#[display(\"Forbidden\")]\n\tForbidden\n}\n\n/**\nThis return type can be used to wrap any type implementing [IntoResponse](crate::IntoResponse)\nthat can only be returned if the client is authenticated. Otherwise, an empty _403 Forbidden_\nresponse will be issued.\n\nUse can look something like this (assuming the `auth` feature is enabled):\n\n```rust\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"auth\")]\n# mod auth_feature_enabled {\n# use gotham::state::State;\n# use gotham_restful::*;\n# use serde::Deserialize;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n# #[derive(Clone, Deserialize)]\n# struct MyAuthData { exp : u64 }\n#\n#[read_all]\nfn read_all(auth : AuthStatus<MyAuthData>) -> AuthSuccess<NoContent> {\n\tlet auth_data = match auth {\n\t\tAuthStatus::Authenticated(data) => data,\n\t\t_ => return Err(Forbidden)\n\t};\n\t// do something\n\tOk(NoContent::default())\n}\n# }\n```\n*/\npub type AuthSuccess<T> = Result<T, AuthError>;\n\n/**\nThis is an error type that either yields a _403 Forbidden_ respone if produced from an authentication\nerror, or delegates to another error type. This type is best used with [AuthResult].\n*/\n#[derive(Debug, ResourceError)]\npub enum AuthErrorOrOther<E> {\n\t#[status(FORBIDDEN)]\n\t#[display(\"Forbidden\")]\n\tForbidden,\n\t#[status(INTERNAL_SERVER_ERROR)]\n\t#[display(\"{0}\")]\n\tOther(E)\n}\n\nimpl<E> From<AuthError> for AuthErrorOrOther<E> {\n\tfn from(err: AuthError) -> Self {\n\t\tmatch err {\n\t\t\tAuthError::Forbidden => Self::Forbidden\n\t\t}\n\t}\n}\n\nmod private {\n\tuse gotham::handler::HandlerError;\n\tpub trait Sealed {}\n\timpl<E: Into<HandlerError>> Sealed for E {}\n}\n\nimpl<E, F> From<F> for AuthErrorOrOther<E>\nwhere\n\t// TODO https://github.com/msrd0/gotham_restful/issues/20\n\tF: private::Sealed + Into<E>\n{\n\tfn from(err: F) -> Self {\n\t\tSelf::Other(err.into())\n\t}\n}\n\n/**\nThis return type can be used to wrap any type implementing [IntoResponse](crate::IntoResponse)\nthat can only be returned if the client is authenticated. Otherwise, an empty _403 Forbidden_\nresponse will be issued.\n\nUse can look something like this (assuming the `auth` feature is enabled):\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# #[cfg(feature = \"auth\")]\n# mod auth_feature_enabled {\n# use gotham::state::State;\n# use gotham_restful::*;\n# use serde::Deserialize;\n# use std::io;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n# #[derive(Clone, Deserialize)]\n# struct MyAuthData { exp : u64 }\n#\n#[read_all]\nfn read_all(auth : AuthStatus<MyAuthData>) -> AuthResult<NoContent, io::Error> {\n\tlet auth_data = match auth {\n\t\tAuthStatus::Authenticated(data) => data,\n\t\t_ => Err(Forbidden)?\n\t};\n\t// do something\n\tOk(NoContent::default().into())\n}\n# }\n*/\npub type AuthResult<T, E> = Result<T, AuthErrorOrOther<E>>;\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","mod.rs"],"content":"use futures_util::future::{self, BoxFuture, FutureExt};\nuse gotham::{\n\thandler::HandlerError,\n\thyper::{\n\t\theader::{HeaderMap, HeaderName, HeaderValue},\n\t\tBody, StatusCode\n\t}\n};\nuse mime::{Mime, APPLICATION_JSON, STAR_STAR};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\nuse serde::Serialize;\nuse std::{\n\tconvert::Infallible,\n\tfmt::{Debug, Display},\n\tfuture::Future,\n\tpin::Pin\n};\n\nmod auth_result;\n#[allow(unreachable_pub)]\npub use auth_result::{AuthError, AuthErrorOrOther, AuthResult, AuthSuccess};\n\nmod no_content;\n#[allow(unreachable_pub)]\npub use no_content::NoContent;\n\nmod raw;\n#[allow(unreachable_pub)]\npub use raw::Raw;\n\nmod redirect;\n#[allow(unreachable_pub)]\npub use redirect::Redirect;\n\nmod result;\n#[allow(unreachable_pub)]\npub use result::IntoResponseError;\n\nmod success;\n#[allow(unreachable_pub)]\npub use success::Success;\n\npub(crate) trait OrAllTypes {\n\tfn or_all_types(self) -> Vec<Mime>;\n}\n\nimpl OrAllTypes for Option<Vec<Mime>> {\n\tfn or_all_types(self) -> Vec<Mime> {\n\t\tself.unwrap_or_else(|| vec![STAR_STAR])\n\t}\n}\n\n/// A response, used to create the final gotham response from.\n#[derive(Debug)]\npub struct Response {\n\tpub(crate) status: StatusCode,\n\tpub(crate) body: Body,\n\tpub(crate) mime: Option<Mime>,\n\tpub(crate) headers: HeaderMap\n}\n\nimpl Response {\n\t/// Create a new [Response] from raw data.\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn new<B: Into<Body>>(status: StatusCode, body: B, mime: Option<Mime>) -> Self {\n\t\tSelf {\n\t\t\tstatus,\n\t\t\tbody: body.into(),\n\t\t\tmime,\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Create a [Response] with mime type json from already serialized data.\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn json<B: Into<Body>>(status: StatusCode, body: B) -> Self {\n\t\tSelf {\n\t\t\tstatus,\n\t\t\tbody: body.into(),\n\t\t\tmime: Some(APPLICATION_JSON),\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Create a _204 No Content_ [Response].\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn no_content() -> Self {\n\t\tSelf {\n\t\t\tstatus: StatusCode::NO_CONTENT,\n\t\t\tbody: Body::empty(),\n\t\t\tmime: None,\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Create an empty _403 Forbidden_ [Response].\n\t#[must_use = \"Creating a response is pointless if you don't use it\"]\n\tpub fn forbidden() -> Self {\n\t\tSelf {\n\t\t\tstatus: StatusCode::FORBIDDEN,\n\t\t\tbody: Body::empty(),\n\t\t\tmime: None,\n\t\t\theaders: Default::default()\n\t\t}\n\t}\n\n\t/// Return the status code of this [Response].\n\tpub fn status(&self) -> StatusCode {\n\t\tself.status\n\t}\n\n\t/// Return the mime type of this [Response].\n\tpub fn mime(&self) -> Option<&Mime> {\n\t\tself.mime.as_ref()\n\t}\n\n\t/// Add an HTTP header to the [Response].\n\tpub fn header(&mut self, name: HeaderName, value: HeaderValue) {\n\t\tself.headers.insert(name, value);\n\t}\n\n\tpub(crate) fn with_headers(mut self, headers: HeaderMap) -> Self {\n\t\tself.headers = headers;\n\t\tself\n\t}\n\n\t#[cfg(test)]\n\tpub(crate) fn full_body(mut self) -> Result<Vec<u8>, <Body as gotham::hyper::body::HttpBody>::Error> {\n\t\tuse futures_executor::block_on;\n\t\tuse gotham::hyper::body::to_bytes;\n\n\t\tlet bytes: &[u8] = &block_on(to_bytes(&mut self.body))?;\n\t\tOk(bytes.to_vec())\n\t}\n}\n\nimpl IntoResponse for Response {\n\ttype Err = Infallible;\n\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>> {\n\t\tfuture::ok(self).boxed()\n\t}\n}\n\n/// This trait needs to be implemented by every type returned from an endpoint to\n/// to provide the response.\npub trait IntoResponse {\n\ttype Err: Into<HandlerError> + Send + Sync + 'static;\n\n\t/// Turn this into a response that can be returned to the browser. This api will likely\n\t/// change in the future.\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>>;\n\n\t/// Return a list of supported mime types.\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tNone\n\t}\n}\n\n/// Additional details for [IntoResponse] to be used with an OpenAPI-aware router.\n#[cfg(feature = \"openapi\")]\npub trait ResponseSchema {\n\t/// All status codes returned by this response. Returns `[StatusCode::OK]` by default.\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::OK]\n\t}\n\n\t/// Return the schema of the response for the given status code. The code may\n\t/// only be one that was previously returned by [Self::status_codes]. The\n\t/// implementation should panic if that is not the case.\n\tfn schema(code: StatusCode) -> OpenapiSchema;\n}\n\n#[cfg(feature = \"openapi\")]\nmod private {\n\tpub trait Sealed {}\n}\n\n/// A trait provided to convert a resource's result to json, and provide an OpenAPI schema to the\n/// router. This trait is implemented for all types that implement [IntoResponse] and\n/// [ResponseSchema].\n#[cfg(feature = \"openapi\")]\npub trait IntoResponseWithSchema: IntoResponse + ResponseSchema + private::Sealed {}\n\n#[cfg(feature = \"openapi\")]\nimpl<R: IntoResponse + ResponseSchema> private::Sealed for R {}\n\n#[cfg(feature = \"openapi\")]\nimpl<R: IntoResponse + ResponseSchema> IntoResponseWithSchema for R {}\n\n/// The default json returned on an 500 Internal Server Error.\n#[derive(Debug, Serialize)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\npub(crate) struct ResourceError {\n\t/// This is always `true` and can be used to detect an error response without looking at the\n\t/// HTTP status code.\n\terror: bool,\n\t/// The error message.\n\tmessage: String\n}\n\nimpl<T: ToString> From<T> for ResourceError {\n\tfn from(message: T) -> Self {\n\t\tSelf {\n\t\t\terror: true,\n\t\t\tmessage: message.to_string()\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"errorlog\")]\nfn errorlog<E: Display>(e: E) {\n\terror!(\"The handler encountered an error: {}\", e);\n}\n\n#[cfg(not(feature = \"errorlog\"))]\nfn errorlog<E>(_e: E) {}\n\nfn handle_error<E>(e: E) -> Pin<Box<dyn Future<Output = Result<Response, E::Err>> + Send>>\nwhere\n\tE: Display + IntoResponseError\n{\n\tlet msg = e.to_string();\n\tlet res = e.into_response_error();\n\tmatch &res {\n\t\tOk(res) if res.status.is_server_error() => errorlog(msg),\n\t\tErr(err) => {\n\t\t\terrorlog(msg);\n\t\t\terrorlog(&err);\n\t\t},\n\t\t_ => {}\n\t};\n\tfuture::ready(res).boxed()\n}\n\nimpl<Res> IntoResponse for Pin<Box<dyn Future<Output = Res> + Send>>\nwhere\n\tRes: IntoResponse + 'static\n{\n\ttype Err = Res::Err;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, Self::Err>> + Send>> {\n\t\tself.then(IntoResponse::into_response).boxed()\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tRes::accepted_types()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<Res> ResponseSchema for Pin<Box<dyn Future<Output = Res> + Send>>\nwhere\n\tRes: ResponseSchema\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tRes::status_codes()\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tRes::schema(code)\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Deserialize, Serialize)]\n\t#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n\tstruct Msg {\n\t\tmsg: String\n\t}\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn result_from_future() {\n\t\tlet nc = NoContent::default();\n\t\tlet res = block_on(nc.into_response()).unwrap();\n\n\t\tlet fut_nc = async move { NoContent::default() }.boxed();\n\t\tlet fut_res = block_on(fut_nc.into_response()).unwrap();\n\n\t\tassert_eq!(res.status, fut_res.status);\n\t\tassert_eq!(res.mime, fut_res.mime);\n\t\tassert_eq!(res.full_body().unwrap(), fut_res.full_body().unwrap());\n\t}\n}\n","traces":[{"line":49,"address":[2525952],"length":1,"stats":{"Line":3},"fn_name":"or_all_types"},{"line":50,"address":[2525964],"length":1,"stats":{"Line":9},"fn_name":null},{"line":66,"address":[2312731,2312400],"length":1,"stats":{"Line":8},"fn_name":"new<hyper::body::body::Body>"},{"line":69,"address":[2312453],"length":1,"stats":{"Line":9},"fn_name":null},{"line":71,"address":[2312583],"length":1,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[1851568,1851863],"length":1,"stats":{"Line":2},"fn_name":"json<alloc::string::String>"},{"line":80,"address":[1851600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[1851642],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[1851726],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[2312816,2312989],"length":1,"stats":{"Line":2},"fn_name":"no_content"},{"line":91,"address":[2312833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[2312852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[2313040,2313213],"length":1,"stats":{"Line":0},"fn_name":"forbidden"},{"line":102,"address":[2313057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[2313076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[2313264],"length":1,"stats":{"Line":1},"fn_name":"status"},{"line":110,"address":[2313269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[2313280],"length":1,"stats":{"Line":1},"fn_name":"mime"},{"line":115,"address":[2313289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[2313328],"length":1,"stats":{"Line":2},"fn_name":"header"},{"line":120,"address":[2313348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[2313440,2313544],"length":1,"stats":{"Line":2},"fn_name":"with_headers"},{"line":124,"address":[2313604,2313564,2313473],"length":1,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[2313636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[2313696],"length":1,"stats":{"Line":0},"fn_name":"into_response"},{"line":142,"address":[2313706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[2313792],"length":1,"stats":{"Line":6},"fn_name":"accepted_types<gotham_restful::response::Response>"},{"line":157,"address":[2313795],"length":1,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":204,"address":[1852192,1852311],"length":1,"stats":{"Line":2},"fn_name":"from<std::io::error::Error>"},{"line":207,"address":[1852238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[2403984,2404766,2404384,2404344],"length":1,"stats":{"Line":1},"fn_name":"errorlog<&&serde_json::error::Error>"},{"line":214,"address":[2404110,2403996,2404396,2404510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[2406736,2405456,2407196,2406096,2405916,2405276,2406556,2404816],"length":1,"stats":{"Line":1},"fn_name":"handle_error<gotham_restful::response::no_content::test::MsgError>"},{"line":224,"address":[2406145,2406785,2405505,2404865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[2405520,2406160,2404880,2406800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[2405578,2404938,2405139,2406218,2406858,2406419,2405779,2407059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[2405548,2406863,2405370,2406650,2406223,2404908,2406010,2404943,2405583,2406188,2406828,2407290],"length":1,"stats":{"Line":3},"fn_name":null},{"line":228,"address":[2405702,2406982,2406342,2405062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[2405075,2406355,2405715,2406995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[2406412,2405772,2405132,2407052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[2406743,2407061,2406103,2405781,2404823,2405463,2405141,2406421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":36,"coverable":51},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","no_content.rs"],"content":"use super::{handle_error, IntoResponse};\n#[cfg(feature = \"openapi\")]\nuse crate::ResponseSchema;\nuse crate::{IntoResponseError, Response};\nuse futures_util::{future, future::FutureExt};\nuse gotham::hyper::header::{HeaderMap, HeaderValue, IntoHeaderName};\n#[cfg(feature = \"openapi\")]\nuse gotham::hyper::StatusCode;\nuse mime::Mime;\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\nuse std::{fmt::Display, future::Future, pin::Pin};\n\n/**\nThis is the return type of a resource that doesn't actually return something. It will result\nin a _204 No Content_ answer by default. You don't need to use this type directly if using\nthe function attributes:\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# mod doc_tests_are_broken {\n# use gotham::state::State;\n# use gotham_restful::*;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n#[read_all]\nfn read_all() {\n\t// do something\n}\n# }\n```\n*/\n#[derive(Clone, Debug, Default)]\npub struct NoContent {\n\theaders: HeaderMap\n}\n\nimpl From<()> for NoContent {\n\tfn from(_: ()) -> Self {\n\t\tSelf::default()\n\t}\n}\n\nimpl NoContent {\n\t/// Set a custom HTTP header. If a header with this name was set before, its value is being updated.\n\tpub fn header<K: IntoHeaderName>(&mut self, name: K, value: HeaderValue) {\n\t\tself.headers.insert(name, value);\n\t}\n\n\t/// Allow manipulating HTTP headers.\n\tpub fn headers_mut(&mut self) -> &mut HeaderMap {\n\t\t&mut self.headers\n\t}\n}\n\nimpl IntoResponse for NoContent {\n\t// TODO this shouldn't be a serde_json::Error\n\ttype Err = serde_json::Error; // just for easier handling of `Result<NoContent, E>`\n\n\t/// This will always be a _204 No Content_ together with an empty string.\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, Self::Err>> + Send>> {\n\t\tfuture::ok(Response::no_content().with_headers(self.headers)).boxed()\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tSome(Vec::new())\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl ResponseSchema for NoContent {\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::NO_CONTENT]\n\t}\n\n\t/// Returns the schema of the `()` type.\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::NO_CONTENT);\n\t\t<()>::schema()\n\t}\n}\n\nimpl<E> IntoResponse for Result<NoContent, E>\nwhere\n\tE: Display + IntoResponseError<Err = serde_json::Error>\n{\n\ttype Err = serde_json::Error;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, serde_json::Error>> + Send>> {\n\t\tmatch self {\n\t\t\tOk(nc) => nc.into_response(),\n\t\t\tErr(e) => handle_error(e)\n\t\t}\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tNoContent::accepted_types()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<E> ResponseSchema for Result<NoContent, E>\nwhere\n\tE: Display + IntoResponseError<Err = serde_json::Error>\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::NO_CONTENT);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::NO_CONTENT => <NoContent as ResponseSchema>::schema(StatusCode::NO_CONTENT),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse gotham::hyper::{header::ACCESS_CONTROL_ALLOW_ORIGIN, StatusCode};\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn no_content_has_empty_response() {\n\t\tlet no_content = NoContent::default();\n\t\tlet res = block_on(no_content.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::NO_CONTENT);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(NoContent::status_codes(), vec![StatusCode::NO_CONTENT]);\n\t}\n\n\t#[test]\n\tfn no_content_result() {\n\t\tlet no_content: Result<NoContent, MsgError> = Ok(NoContent::default());\n\t\tlet res = block_on(no_content.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::NO_CONTENT);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Result<NoContent, MsgError>>::status_codes(), vec![\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tStatusCode::NO_CONTENT\n\t\t]);\n\t}\n\n\t#[test]\n\tfn no_content_custom_headers() {\n\t\tlet mut no_content = NoContent::default();\n\t\tno_content.header(ACCESS_CONTROL_ALLOW_ORIGIN, HeaderValue::from_static(\"*\"));\n\t\tlet res = block_on(no_content.into_response()).expect(\"didn't expect error response\");\n\t\tlet cors = res.headers.get(ACCESS_CONTROL_ALLOW_ORIGIN);\n\t\tassert_eq!(cors.map(|value| value.to_str().unwrap()), Some(\"*\"));\n\t}\n}\n","traces":[{"line":42,"address":[2059216],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":43,"address":[2059228],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[2059248],"length":1,"stats":{"Line":1},"fn_name":"header<http::header::name::HeaderName>"},{"line":50,"address":[2059273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[2059360],"length":1,"stats":{"Line":0},"fn_name":"headers_mut"},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[2525344,2525584],"length":1,"stats":{"Line":2},"fn_name":"into_response"},{"line":65,"address":[2059388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[2059664],"length":1,"stats":{"Line":4},"fn_name":"accepted_types"},{"line":69,"address":[2059677],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[2525712],"length":1,"stats":{"Line":2},"fn_name":"status_codes"},{"line":76,"address":[2059742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[2525776],"length":1,"stats":{"Line":2},"fn_name":"schema"},{"line":82,"address":[2525931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[2217856],"length":1,"stats":{"Line":1},"fn_name":"into_response<gotham_restful::response::no_content::test::MsgError>"},{"line":93,"address":[2218013,2217903,2217991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":28},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","raw.rs"],"content":"use super::{handle_error, IntoResponse, IntoResponseError};\nuse crate::{types::ResourceType, FromBody, RequestBody, Response};\n#[cfg(feature = \"openapi\")]\nuse crate::{IntoResponseWithSchema, ResponseSchema};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\n\nuse futures_core::future::Future;\nuse futures_util::{future, future::FutureExt};\nuse gotham::hyper::{\n\tbody::{Body, Bytes},\n\tStatusCode\n};\nuse mime::Mime;\n#[cfg(feature = \"openapi\")]\nuse openapi_type::openapi::{SchemaKind, StringFormat, StringType, Type, VariantOrUnknownOrEmpty};\nuse serde_json::error::Error as SerdeJsonError;\nuse std::{convert::Infallible, fmt::Display, pin::Pin};\n\n/**\nThis type can be used both as a raw request body, as well as as a raw response. However, all types\nof request bodies are accepted by this type. It is therefore recommended to derive your own type\nfrom [RequestBody] and only use this when you need to return a raw response. This is a usage\nexample that simply returns its body:\n\n```rust,no_run\n# #[macro_use] extern crate gotham_restful_derive;\n# use gotham::router::builder::*;\n# use gotham_restful::*;\n#[derive(Resource)]\n#[resource(create)]\nstruct ImageResource;\n\n#[create]\nfn create(body : Raw<Vec<u8>>) -> Raw<Vec<u8>> {\n\tbody\n}\n# fn main() {\n# \tgotham::start(\"127.0.0.1:8080\", build_simple_router(|route| {\n# \t\troute.resource::<ImageResource>(\"img\");\n# \t}));\n# }\n```\n*/\n#[derive(Debug)]\npub struct Raw<T> {\n\tpub raw: T,\n\tpub mime: Mime\n}\n\nimpl<T> Raw<T> {\n\tpub fn new(raw: T, mime: Mime) -> Self {\n\t\tSelf { raw, mime }\n\t}\n}\n\nimpl<T, U> AsMut<U> for Raw<T>\nwhere\n\tT: AsMut<U>\n{\n\tfn as_mut(&mut self) -> &mut U {\n\t\tself.raw.as_mut()\n\t}\n}\n\nimpl<T, U> AsRef<U> for Raw<T>\nwhere\n\tT: AsRef<U>\n{\n\tfn as_ref(&self) -> &U {\n\t\tself.raw.as_ref()\n\t}\n}\n\nimpl<T: Clone> Clone for Raw<T> {\n\tfn clone(&self) -> Self {\n\t\tSelf {\n\t\t\traw: self.raw.clone(),\n\t\t\tmime: self.mime.clone()\n\t\t}\n\t}\n}\n\nimpl<T: for<'a> From<&'a [u8]>> FromBody for Raw<T> {\n\ttype Err = Infallible;\n\n\tfn from_body(body: Bytes, mime: Mime) -> Result<Self, Self::Err> {\n\t\tOk(Self::new(body.as_ref().into(), mime))\n\t}\n}\n\nimpl<T> RequestBody for Raw<T> where Raw<T>: FromBody + ResourceType {}\n\n#[cfg(feature = \"openapi\")]\nimpl<T> OpenapiType for Raw<T> {\n\tfn schema() -> OpenapiSchema {\n\t\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\t\tformat: VariantOrUnknownOrEmpty::Item(StringFormat::Binary),\n\t\t\t..Default::default()\n\t\t})))\n\t}\n}\n\nimpl<T: Into<Body>> IntoResponse for Raw<T>\nwhere\n\tSelf: Send\n{\n\ttype Err = SerdeJsonError; // just for easier handling of `Result<Raw<T>, E>`\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, SerdeJsonError>> + Send>> {\n\t\tfuture::ok(Response::new(StatusCode::OK, self.raw, Some(self.mime))).boxed()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<T: Into<Body>> ResponseSchema for Raw<T>\nwhere\n\tSelf: Send\n{\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::OK);\n\t\t<Self as OpenapiType>::schema()\n\t}\n}\n\nimpl<T, E> IntoResponse for Result<Raw<T>, E>\nwhere\n\tRaw<T>: IntoResponse,\n\tE: Display + IntoResponseError<Err = <Raw<T> as IntoResponse>::Err>\n{\n\ttype Err = E::Err;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, E::Err>> + Send>> {\n\t\tmatch self {\n\t\t\tOk(raw) => raw.into_response(),\n\t\t\tErr(e) => handle_error(e)\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<T, E> ResponseSchema for Result<Raw<T>, E>\nwhere\n\tRaw<T>: IntoResponseWithSchema,\n\tE: Display + IntoResponseError<Err = <Raw<T> as IntoResponse>::Err>\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::OK);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::OK => <Raw<T> as ResponseSchema>::schema(StatusCode::OK),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse mime::TEXT_PLAIN;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn raw_response() {\n\t\tlet msg = \"Test\";\n\t\tlet raw = Raw::new(msg, TEXT_PLAIN);\n\t\tlet res = block_on(raw.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(TEXT_PLAIN));\n\t\tassert_eq!(res.full_body().unwrap(), msg.as_bytes());\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Raw<String>>::status_codes(), vec![StatusCode::OK]);\n\t}\n\n\t#[test]\n\tfn raw_result() {\n\t\tlet msg = \"Test\";\n\t\tlet raw: Result<Raw<_>, MsgError> = Ok(Raw::new(msg, TEXT_PLAIN));\n\t\tlet res = block_on(raw.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(TEXT_PLAIN));\n\t\tassert_eq!(res.full_body().unwrap(), msg.as_bytes());\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Result<Raw<String>, MsgError>>::status_codes(), vec![\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tStatusCode::OK\n\t\t]);\n\t}\n}\n","traces":[{"line":52,"address":[3056144],"length":1,"stats":{"Line":7},"fn_name":"new<alloc::vec::Vec<u8, alloc::alloc::Global>>"},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[2398926],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":111,"address":[2399402],"length":1,"stats":{"Line":5},"fn_name":null},{"line":120,"address":[2399568],"length":1,"stats":{"Line":3},"fn_name":"schema<&str>"},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[2218175,2218285,2218263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":30},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","redirect.rs"],"content":"use super::{handle_error, IntoResponse};\nuse crate::{IntoResponseError, Response};\n#[cfg(feature = \"openapi\")]\nuse crate::{NoContent, ResponseSchema};\nuse futures_util::future::{BoxFuture, FutureExt, TryFutureExt};\nuse gotham::hyper::{\n\theader::{InvalidHeaderValue, LOCATION},\n\tBody, StatusCode\n};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiSchema;\nuse std::{\n\terror::Error as StdError,\n\tfmt::{Debug, Display}\n};\nuse thiserror::Error;\n\n/**\nThis is the return type of a resource that only returns a redirect. It will result\nin a _303 See Other_ answer, meaning the redirect will always result in a GET request\non the target.\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# mod doc_tests_are_broken {\n# use gotham::state::State;\n# use gotham_restful::*;\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n#[read_all]\nfn read_all() -> Redirect {\n\tRedirect {\n\t\tto: \"http://localhost:8080/cool/new/location\".to_owned()\n\t}\n}\n# }\n```\n*/\n#[derive(Clone, Debug, Default)]\npub struct Redirect {\n\tpub to: String\n}\n\nimpl IntoResponse for Redirect {\n\ttype Err = InvalidHeaderValue;\n\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>> {\n\t\tasync move {\n\t\t\tlet mut res = Response::new(StatusCode::SEE_OTHER, Body::empty(), None);\n\t\t\tres.header(LOCATION, self.to.parse()?);\n\t\t\tOk(res)\n\t\t}\n\t\t.boxed()\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl ResponseSchema for Redirect {\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::SEE_OTHER]\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::SEE_OTHER);\n\t\t<NoContent as ResponseSchema>::schema(StatusCode::NO_CONTENT)\n\t}\n}\n\n// private type due to parent mod\n#[derive(Debug, Error)]\npub enum RedirectError<E: StdError + 'static> {\n\t#[error(\"{0}\")]\n\tInvalidLocation(#[from] InvalidHeaderValue),\n\t#[error(\"{0}\")]\n\tOther(#[source] E)\n}\n\n#[allow(ambiguous_associated_items)] // an enum variant is not a type. never.\nimpl<E> IntoResponse for Result<Redirect, E>\nwhere\n\tE: Display + IntoResponseError,\n\t<E as IntoResponseError>::Err: StdError + Sync\n{\n\ttype Err = RedirectError<<E as IntoResponseError>::Err>;\n\n\tfn into_response(self) -> BoxFuture<'static, Result<Response, Self::Err>> {\n\t\tmatch self {\n\t\t\tOk(nc) => nc.into_response().map_err(Into::into).boxed(),\n\t\t\tErr(e) => handle_error(e).map_err(RedirectError::Other).boxed()\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<E> ResponseSchema for Result<Redirect, E>\nwhere\n\tE: Display + IntoResponseError,\n\t<E as IntoResponseError>::Err: StdError + Sync\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::SEE_OTHER);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::SEE_OTHER => <Redirect as ResponseSchema>::schema(StatusCode::SEE_OTHER),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse futures_executor::block_on;\n\tuse gotham::hyper::StatusCode;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn redirect_response() {\n\t\tlet redir = Redirect {\n\t\t\tto: \"http://localhost/foo\".to_owned()\n\t\t};\n\t\tlet res = block_on(redir.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::SEE_OTHER);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(\n\t\t\tres.headers.get(LOCATION).map(|hdr| hdr.to_str().unwrap()),\n\t\t\tSome(\"http://localhost/foo\")\n\t\t);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(Redirect::status_codes(), vec![StatusCode::SEE_OTHER]);\n\t}\n\n\t#[test]\n\tfn redirect_result() {\n\t\tlet redir: Result<Redirect, MsgError> = Ok(Redirect {\n\t\t\tto: \"http://localhost/foo\".to_owned()\n\t\t});\n\t\tlet res = block_on(redir.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::SEE_OTHER);\n\t\tassert_eq!(res.mime, None);\n\t\tassert_eq!(\n\t\t\tres.headers.get(LOCATION).map(|hdr| hdr.to_str().unwrap()),\n\t\t\tSome(\"http://localhost/foo\")\n\t\t);\n\t\tassert_eq!(res.full_body().unwrap(), &[] as &[u8]);\n\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Result<Redirect, MsgError>>::status_codes(), vec![\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tStatusCode::SEE_OTHER\n\t\t]);\n\t}\n}\n","traces":[{"line":50,"address":[2419760],"length":1,"stats":{"Line":1},"fn_name":"into_response"},{"line":51,"address":[4596107,4596155,4595472,4595380,4595515],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":52,"address":[2362770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[3961888,3962343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[3962255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[2363504],"length":1,"stats":{"Line":1},"fn_name":"status_codes"},{"line":63,"address":[3962606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[3962656],"length":1,"stats":{"Line":0},"fn_name":"schema"},{"line":68,"address":[3962811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[2218643,2218428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":21},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","result.rs"],"content":"use super::{handle_error, IntoResponse, ResourceError};\n#[cfg(feature = \"openapi\")]\nuse crate::ResponseSchema;\nuse crate::{Response, ResponseBody, Success};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::{OpenapiSchema, OpenapiType};\n\nuse futures_core::future::Future;\nuse gotham::hyper::StatusCode;\nuse mime::{Mime, APPLICATION_JSON};\nuse std::{error::Error, fmt::Display, pin::Pin};\n\npub trait IntoResponseError {\n\ttype Err: Display + Send + 'static;\n\n\tfn into_response_error(self) -> Result<Response, Self::Err>;\n\n\t#[cfg(feature = \"openapi\")]\n\tfn status_codes() -> Vec<StatusCode>;\n\n\t#[cfg(feature = \"openapi\")]\n\tfn schema(code: StatusCode) -> OpenapiSchema;\n}\n\nimpl<E: Error> IntoResponseError for E {\n\ttype Err = serde_json::Error;\n\n\tfn into_response_error(self) -> Result<Response, Self::Err> {\n\t\tlet err: ResourceError = self.into();\n\t\tOk(Response::json(\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tserde_json::to_string(&err)?\n\t\t))\n\t}\n\n\t#[cfg(feature = \"openapi\")]\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tvec![StatusCode::INTERNAL_SERVER_ERROR]\n\t}\n\n\t#[cfg(feature = \"openapi\")]\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::INTERNAL_SERVER_ERROR);\n\t\tResourceError::schema()\n\t}\n}\n\nimpl<R, E> IntoResponse for Result<R, E>\nwhere\n\tR: ResponseBody,\n\tE: Display + IntoResponseError<Err = serde_json::Error>\n{\n\ttype Err = E::Err;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, E::Err>> + Send>> {\n\t\tmatch self {\n\t\t\tOk(r) => Success::from(r).into_response(),\n\t\t\tErr(e) => handle_error(e)\n\t\t}\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tSome(vec![APPLICATION_JSON])\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<R, E> ResponseSchema for Result<R, E>\nwhere\n\tR: ResponseBody,\n\tE: Display + IntoResponseError<Err = serde_json::Error>\n{\n\tfn status_codes() -> Vec<StatusCode> {\n\t\tlet mut status_codes = E::status_codes();\n\t\tstatus_codes.push(StatusCode::OK);\n\t\tstatus_codes\n\t}\n\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tmatch code {\n\t\t\tStatusCode::OK => R::schema(),\n\t\t\tcode => E::schema(code)\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse crate::response::OrAllTypes;\n\tuse futures_executor::block_on;\n\tuse thiserror::Error;\n\n\t#[derive(Debug, Default, Deserialize, Serialize)]\n\t#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n\tstruct Msg {\n\t\tmsg: String\n\t}\n\n\t#[derive(Debug, Default, Error)]\n\t#[error(\"An Error\")]\n\tstruct MsgError;\n\n\t#[test]\n\tfn result_ok() {\n\t\tlet ok: Result<Msg, MsgError> = Ok(Msg::default());\n\t\tlet res = block_on(ok.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(APPLICATION_JSON));\n\t\tassert_eq!(res.full_body().unwrap(), br#\"{\"msg\":\"\"}\"#);\n\t}\n\n\t#[test]\n\tfn result_err() {\n\t\tlet err: Result<Msg, MsgError> = Err(MsgError::default());\n\t\tlet res = block_on(err.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::INTERNAL_SERVER_ERROR);\n\t\tassert_eq!(res.mime, Some(APPLICATION_JSON));\n\t\tassert_eq!(\n\t\t\tres.full_body().unwrap(),\n\t\t\tformat!(r#\"{{\"error\":true,\"message\":\"{}\"}}\"#, MsgError::default()).as_bytes()\n\t\t);\n\t}\n\n\t#[test]\n\tfn success_accepts_json() {\n\t\tassert!(<Result<Msg, MsgError>>::accepted_types()\n\t\t\t.or_all_types()\n\t\t\t.contains(&APPLICATION_JSON))\n\t}\n}\n","traces":[{"line":28,"address":[2494160,2494489],"length":1,"stats":{"Line":2},"fn_name":"into_response_error<gotham_restful::response::no_content::test::MsgError>"},{"line":29,"address":[2534945],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[2494333,2494409],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[2534968,2535108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[1857104],"length":1,"stats":{"Line":3},"fn_name":"status_codes<std::io::error::Error>"},{"line":38,"address":[2535342],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[2218832],"length":1,"stats":{"Line":2},"fn_name":"into_response<gotham_restful::response::result::test::Msg,gotham_restful::response::result::test::MsgError>"},{"line":56,"address":[2218880,2219030,2219008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":18,"coverable":23},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","response","success.rs"],"content":"use super::IntoResponse;\n#[cfg(feature = \"openapi\")]\nuse crate::ResponseSchema;\nuse crate::{Response, ResponseBody};\nuse futures_util::future::{self, FutureExt};\nuse gotham::hyper::{\n\theader::{HeaderMap, HeaderValue, IntoHeaderName},\n\tStatusCode\n};\nuse mime::{Mime, APPLICATION_JSON};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiSchema;\nuse std::{fmt::Debug, future::Future, pin::Pin};\n\n/**\nThis can be returned from a resource when there is no cause of an error.\n\nUsage example:\n\n```\n# #[macro_use] extern crate gotham_restful_derive;\n# mod doc_tests_are_broken {\n# use gotham::state::State;\n# use gotham_restful::*;\n# use serde::{Deserialize, Serialize};\n#\n# #[derive(Resource)]\n# #[resource(read_all)]\n# struct MyResource;\n#\n#[derive(Deserialize, Serialize)]\n# #[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\nstruct MyResponse {\n\tmessage: &'static str\n}\n\n#[read_all]\nfn read_all() -> Success<MyResponse> {\n\tlet res = MyResponse { message: \"I'm always happy\" };\n\tres.into()\n}\n# }\n```\n*/\n#[derive(Clone, Debug, Default)]\npub struct Success<T> {\n\tvalue: T,\n\theaders: HeaderMap\n}\n\nimpl<T> From<T> for Success<T> {\n\tfn from(t: T) -> Self {\n\t\tSelf {\n\t\t\tvalue: t,\n\t\t\theaders: HeaderMap::new()\n\t\t}\n\t}\n}\n\nimpl<T> Success<T> {\n\t/// Set a custom HTTP header. If a header with this name was set before, its value is being updated.\n\tpub fn header<K: IntoHeaderName>(&mut self, name: K, value: HeaderValue) {\n\t\tself.headers.insert(name, value);\n\t}\n\n\t/// Allow manipulating HTTP headers.\n\tpub fn headers_mut(&mut self) -> &mut HeaderMap {\n\t\t&mut self.headers\n\t}\n}\n\nimpl<T: ResponseBody> IntoResponse for Success<T> {\n\ttype Err = serde_json::Error;\n\n\tfn into_response(self) -> Pin<Box<dyn Future<Output = Result<Response, Self::Err>> + Send>> {\n\t\tlet res =\n\t\t\tserde_json::to_string(&self.value).map(|body| Response::json(StatusCode::OK, body).with_headers(self.headers));\n\t\tfuture::ready(res).boxed()\n\t}\n\n\tfn accepted_types() -> Option<Vec<Mime>> {\n\t\tSome(vec![APPLICATION_JSON])\n\t}\n}\n\n#[cfg(feature = \"openapi\")]\nimpl<T: ResponseBody> ResponseSchema for Success<T> {\n\tfn schema(code: StatusCode) -> OpenapiSchema {\n\t\tassert_eq!(code, StatusCode::OK);\n\t\tT::schema()\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\tuse crate::response::OrAllTypes;\n\tuse futures_executor::block_on;\n\tuse gotham::hyper::header::ACCESS_CONTROL_ALLOW_ORIGIN;\n\n\t#[derive(Debug, Default, Serialize)]\n\t#[cfg_attr(feature = \"openapi\", derive(openapi_type::OpenapiType))]\n\tstruct Msg {\n\t\tmsg: String\n\t}\n\n\t#[test]\n\tfn success_always_successfull() {\n\t\tlet success: Success<Msg> = Msg::default().into();\n\t\tlet res = block_on(success.into_response()).expect(\"didn't expect error response\");\n\t\tassert_eq!(res.status, StatusCode::OK);\n\t\tassert_eq!(res.mime, Some(APPLICATION_JSON));\n\t\tassert_eq!(res.full_body().unwrap(), br#\"{\"msg\":\"\"}\"#);\n\t\t#[cfg(feature = \"openapi\")]\n\t\tassert_eq!(<Success<Msg>>::status_codes(), vec![StatusCode::OK]);\n\t}\n\n\t#[test]\n\tfn success_custom_headers() {\n\t\tlet mut success: Success<Msg> = Msg::default().into();\n\t\tsuccess.header(ACCESS_CONTROL_ALLOW_ORIGIN, HeaderValue::from_static(\"*\"));\n\t\tlet res = block_on(success.into_response()).expect(\"didn't expect error response\");\n\t\tlet cors = res.headers.get(ACCESS_CONTROL_ALLOW_ORIGIN);\n\t\tassert_eq!(cors.map(|value| value.to_str().unwrap()), Some(\"*\"));\n\t}\n\n\t#[test]\n\tfn success_accepts_json() {\n\t\tassert!(<Success<Msg>>::accepted_types().or_all_types().contains(&APPLICATION_JSON))\n\t}\n}\n","traces":[{"line":52,"address":[2923248,2923392,2923513,2923342],"length":1,"stats":{"Line":3},"fn_name":"from<openapi_specification::Secret>"},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[2923552,2923829,2923904,2924189],"length":1,"stats":{"Line":2},"fn_name":"into_response<openapi_specification::Secret>"},{"line":76,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":14},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","routing.rs"],"content":"#[cfg(feature = \"openapi\")]\nuse crate::openapi::{\n\tbuilder::{OpenapiBuilder, OpenapiInfo},\n\trouter::OpenapiRouter\n};\nuse crate::{response::ResourceError, Endpoint, FromBody, IntoResponse, Resource, Response};\n#[cfg(feature = \"cors\")]\nuse gotham::router::route::matcher::AccessControlRequestMethodMatcher;\nuse gotham::{\n\thandler::HandlerError,\n\thelpers::http::response::{create_empty_response, create_response},\n\thyper::{body::to_bytes, header::CONTENT_TYPE, Body, HeaderMap, Method, StatusCode},\n\tpipeline::chain::PipelineHandleChain,\n\trouter::{\n\t\tbuilder::{DefineSingleRoute, DrawRoutes, RouterBuilder, ScopeBuilder},\n\t\tnon_match::RouteNonMatch,\n\t\troute::matcher::{AcceptHeaderRouteMatcher, ContentTypeHeaderRouteMatcher, RouteMatcher}\n\t},\n\tstate::{FromState, State}\n};\nuse mime::{Mime, APPLICATION_JSON};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse std::{any::TypeId, panic::RefUnwindSafe};\n\n/// Allow us to extract an id from a path.\n#[derive(Clone, Copy, Debug, Deserialize, StateData, StaticResponseExtender)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\npub struct PathExtractor<ID: RefUnwindSafe + Send + 'static> {\n\tpub id: ID\n}\n\n/// This trait adds the `with_openapi` method to gotham's routing. It turns the default\n/// router into one that will only allow RESTful resources, but record them and generate\n/// an OpenAPI specification on request.\n#[cfg(feature = \"openapi\")]\npub trait WithOpenapi<D> {\n\tfn with_openapi<F>(&mut self, info: OpenapiInfo, block: F)\n\twhere\n\t\tF: FnOnce(OpenapiRouter<'_, D>);\n}\n\n/// This trait adds the `resource` method to gotham's routing. It allows you to register\n/// any RESTful [Resource] with a path.\n#[_private_openapi_trait(DrawResourcesWithSchema)]\npub trait DrawResources {\n\t#[openapi_bound(\"R: crate::ResourceWithSchema\")]\n\t#[non_openapi_bound(\"R: crate::Resource\")]\n\tfn resource<R>(&mut self, path: &str);\n}\n\n/// This trait allows to draw routes within an resource. Use this only inside the\n/// [Resource::setup] method.\n#[_private_openapi_trait(DrawResourceRoutesWithSchema)]\npub trait DrawResourceRoutes {\n\t#[openapi_bound(\"E: crate::EndpointWithSchema\")]\n\t#[non_openapi_bound(\"E: crate::Endpoint\")]\n\tfn endpoint<E: 'static>(&mut self);\n}\n\nfn response_from(res: Response, state: &State) -> gotham::hyper::Response<Body> {\n\tlet mut r = create_empty_response(state, res.status);\n\tlet headers = r.headers_mut();\n\tif let Some(mime) = res.mime {\n\t\theaders.insert(CONTENT_TYPE, mime.as_ref().parse().unwrap());\n\t}\n\tlet mut last_name = None;\n\tfor (name, value) in res.headers {\n\t\tif name.is_some() {\n\t\t\tlast_name = name;\n\t\t}\n\t\t// this unwrap is safe: the first item will always be Some\n\t\tlet name = last_name.clone().unwrap();\n\t\theaders.insert(name, value);\n\t}\n\n\tlet method = Method::borrow_from(state);\n\tif method != Method::HEAD {\n\t\t*r.body_mut() = res.body;\n\t}\n\n\t#[cfg(feature = \"cors\")]\n\tcrate::cors::handle_cors(state, &mut r);\n\n\tr\n}\n\nasync fn endpoint_handler<E: Endpoint>(state: &mut State) -> Result<gotham::hyper::Response<Body>, HandlerError>\nwhere\n\tE: Endpoint,\n\t<E::Output as IntoResponse>::Err: Into<HandlerError>\n{\n\ttrace!(\"entering endpoint_handler\");\n\tlet placeholders = E::Placeholders::take_from(state);\n\t// workaround for E::Placeholders and E::Param being the same type\n\t// when fixed remove `Clone` requirement on endpoint\n\tif TypeId::of::<E::Placeholders>() == TypeId::of::<E::Params>() {\n\t\tstate.put(placeholders.clone());\n\t}\n\tlet params = E::Params::take_from(state);\n\n\tlet body = match E::needs_body() {\n\t\ttrue => {\n\t\t\tlet body = to_bytes(Body::take_from(state)).await?;\n\n\t\t\tlet content_type: Mime = match HeaderMap::borrow_from(state).get(CONTENT_TYPE) {\n\t\t\t\tSome(content_type) => content_type.to_str().unwrap().parse().unwrap(),\n\t\t\t\tNone => {\n\t\t\t\t\tdebug!(\"Missing Content-Type: Returning 415 Response\");\n\t\t\t\t\tlet res = create_empty_response(state, StatusCode::UNSUPPORTED_MEDIA_TYPE);\n\t\t\t\t\treturn Ok(res);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch E::Body::from_body(body, content_type) {\n\t\t\t\tOk(body) => Some(body),\n\t\t\t\tErr(e) => {\n\t\t\t\t\tdebug!(\"Invalid Body: Returning 400 Response\");\n\t\t\t\t\tlet error: ResourceError = e.into();\n\t\t\t\t\tlet json = serde_json::to_string(&error)?;\n\t\t\t\t\tlet res = create_response(state, StatusCode::BAD_REQUEST, APPLICATION_JSON, json);\n\t\t\t\t\treturn Ok(res);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfalse => None\n\t};\n\n\tlet out = E::handle(state, placeholders, params, body).await;\n\tlet res = out.into_response().await.map_err(Into::into)?;\n\tdebug!(\"Returning response {:?}\", res);\n\tOk(response_from(res, state))\n}\n\n#[derive(Clone)]\nstruct MaybeMatchAcceptHeader {\n\tmatcher: Option<AcceptHeaderRouteMatcher>\n}\n\nimpl RouteMatcher for MaybeMatchAcceptHeader {\n\tfn is_match(&self, state: &State) -> Result<(), RouteNonMatch> {\n\t\tmatch &self.matcher {\n\t\t\tSome(matcher) => matcher.is_match(state),\n\t\t\tNone => Ok(())\n\t\t}\n\t}\n}\n\nimpl MaybeMatchAcceptHeader {\n\tfn new(types: Option<Vec<Mime>>) -> Self {\n\t\tlet types = match types {\n\t\t\tSome(types) if types.is_empty() => None,\n\t\t\ttypes => types\n\t\t};\n\t\tSelf {\n\t\t\tmatcher: types.map(AcceptHeaderRouteMatcher::new)\n\t\t}\n\t}\n}\n\nimpl From<Option<Vec<Mime>>> for MaybeMatchAcceptHeader {\n\tfn from(types: Option<Vec<Mime>>) -> Self {\n\t\tSelf::new(types)\n\t}\n}\n\n#[derive(Clone)]\nstruct MaybeMatchContentTypeHeader {\n\tmatcher: Option<ContentTypeHeaderRouteMatcher>\n}\n\nimpl RouteMatcher for MaybeMatchContentTypeHeader {\n\tfn is_match(&self, state: &State) -> Result<(), RouteNonMatch> {\n\t\tmatch &self.matcher {\n\t\t\tSome(matcher) => matcher.is_match(state),\n\t\t\tNone => Ok(())\n\t\t}\n\t}\n}\n\nimpl MaybeMatchContentTypeHeader {\n\tfn new(types: Option<Vec<Mime>>) -> Self {\n\t\tSelf {\n\t\t\tmatcher: types.map(|types| ContentTypeHeaderRouteMatcher::new(types).allow_no_type())\n\t\t}\n\t}\n}\n\nimpl From<Option<Vec<Mime>>> for MaybeMatchContentTypeHeader {\n\tfn from(types: Option<Vec<Mime>>) -> Self {\n\t\tSelf::new(types)\n\t}\n}\n\nmacro_rules! implDrawResourceRoutes {\n\t($implType:ident) => {\n\t\t#[cfg(feature = \"openapi\")]\n\t\timpl<'a, C, P> WithOpenapi<Self> for $implType<'a, C, P>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn with_openapi<F>(&mut self, info: OpenapiInfo, block: F)\n\t\t\twhere\n\t\t\t\tF: FnOnce(OpenapiRouter<'_, $implType<'a, C, P>>)\n\t\t\t{\n\t\t\t\tlet router = OpenapiRouter {\n\t\t\t\t\trouter: self,\n\t\t\t\t\tscope: None,\n\t\t\t\t\topenapi_builder: &mut OpenapiBuilder::new(info)\n\t\t\t\t};\n\t\t\t\tblock(router);\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, C, P> DrawResources for $implType<'a, C, P>\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn resource<R: Resource>(&mut self, mut path: &str) {\n\t\t\t\tif path.starts_with('/') {\n\t\t\t\t\tpath = &path[1..];\n\t\t\t\t}\n\t\t\t\tR::setup((self, path));\n\t\t\t}\n\t\t}\n\n\t\timpl<'a, C, P> DrawResourceRoutes for (&mut $implType<'a, C, P>, &str)\n\t\twhere\n\t\t\tC: PipelineHandleChain<P> + Copy + Send + Sync + 'static,\n\t\t\tP: RefUnwindSafe + Send + Sync + 'static\n\t\t{\n\t\t\tfn endpoint<E: Endpoint + 'static>(&mut self) {\n\t\t\t\tlet uri = format!(\"{}/{}\", self.1, E::uri());\n\t\t\t\tdebug!(\"Registering endpoint for {}\", uri);\n\t\t\t\tself.0.associate(&uri, |assoc| {\n\t\t\t\t\tassoc\n\t\t\t\t\t\t.request(vec![E::http_method()])\n\t\t\t\t\t\t.add_route_matcher(MaybeMatchAcceptHeader::new(E::Output::accepted_types()))\n\t\t\t\t\t\t.with_path_extractor::<E::Placeholders>()\n\t\t\t\t\t\t.with_query_string_extractor::<E::Params>()\n\t\t\t\t\t\t.to_async_borrowing(endpoint_handler::<E>);\n\n\t\t\t\t\t#[cfg(feature = \"cors\")]\n\t\t\t\t\tif E::http_method() != Method::GET {\n\t\t\t\t\t\tassoc\n\t\t\t\t\t\t\t.options()\n\t\t\t\t\t\t\t.add_route_matcher(AccessControlRequestMethodMatcher::new(E::http_method()))\n\t\t\t\t\t\t\t.to(crate::cors::cors_preflight_handler);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n\nimplDrawResourceRoutes!(RouterBuilder);\nimplDrawResourceRoutes!(ScopeBuilder);\n","traces":[{"line":61,"address":[2422928,2420992],"length":1,"stats":{"Line":5},"fn_name":"response_from"},{"line":62,"address":[2060139],"length":1,"stats":{"Line":5},"fn_name":null},{"line":63,"address":[2060265],"length":1,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[2060307],"length":1,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[2421333],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[2421548],"length":1,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[2421793,2422565,2421556],"length":1,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[2423000,2422179,2422292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[2422214,2422943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[2422294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[2422360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[2422575],"length":1,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[2422729,2423086,2422607],"length":1,"stats":{"Line":10},"fn_name":null},{"line":79,"address":[2062341,2062120,2061746,2061828],"length":1,"stats":{"Line":10},"fn_name":null},{"line":83,"address":[2422763],"length":1,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[2422784],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[2563424,2563609],"length":1,"stats":{"Line":42},"fn_name":"endpoint_handler<custom_request_body::create___gotham_restful_endpoint>"},{"line":93,"address":[2563786,2563648],"length":1,"stats":{"Line":42},"fn_name":null},{"line":94,"address":[2563964],"length":1,"stats":{"Line":21},"fn_name":null},{"line":97,"address":[2564127,2563987,2564144],"length":1,"stats":{"Line":42},"fn_name":null},{"line":98,"address":[2564108,2564137],"length":1,"stats":{"Line":26},"fn_name":null},{"line":100,"address":[2564154],"length":1,"stats":{"Line":21},"fn_name":null},{"line":102,"address":[2564218,2565885,2564177],"length":1,"stats":{"Line":42},"fn_name":null},{"line":103,"address":[2564200],"length":1,"stats":{"Line":21},"fn_name":null},{"line":104,"address":[2564231,2564724,2564347,2568806,2569005],"length":1,"stats":{"Line":16},"fn_name":null},{"line":106,"address":[2564698,2564822,2564982],"length":1,"stats":{"Line":16},"fn_name":null},{"line":107,"address":[2564913,2564984],"length":1,"stats":{"Line":16},"fn_name":null},{"line":109,"address":[2564936,2565415,2565320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[2565593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[2565673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[2565805,2565158],"length":1,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[2565745,2565807],"length":1,"stats":{"Line":16},"fn_name":null},{"line":117,"address":[2565751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[2565759,2565890,2565985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[2566155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[2566194,2568751,2566503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[2566328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[2566597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[2564206],"length":1,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[3178497],"length":1,"stats":{"Line":43},"fn_name":null},{"line":130,"address":[3178471],"length":1,"stats":{"Line":42},"fn_name":null},{"line":131,"address":[2568152,2567919,2568066],"length":1,"stats":{"Line":42},"fn_name":null},{"line":132,"address":[2568401],"length":1,"stats":{"Line":21},"fn_name":null},{"line":141,"address":[2423808],"length":1,"stats":{"Line":6},"fn_name":"is_match"},{"line":142,"address":[2423871,2423836],"length":1,"stats":{"Line":12},"fn_name":null},{"line":143,"address":[2423844,2423889],"length":1,"stats":{"Line":6},"fn_name":null},{"line":144,"address":[2423867],"length":1,"stats":{"Line":6},"fn_name":null},{"line":150,"address":[2423920,2424251],"length":1,"stats":{"Line":7},"fn_name":"new"},{"line":151,"address":[2424072,2423942],"length":1,"stats":{"Line":12},"fn_name":null},{"line":152,"address":[2423974,2424079],"length":1,"stats":{"Line":10},"fn_name":null},{"line":153,"address":[2424000],"length":1,"stats":{"Line":5},"fn_name":null},{"line":156,"address":[2424169],"length":1,"stats":{"Line":7},"fn_name":null},{"line":162,"address":[2424384],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":163,"address":[2424396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[2424448],"length":1,"stats":{"Line":0},"fn_name":"is_match"},{"line":174,"address":[2424476,2424510],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[2424484,2424528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[2424506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[2424560],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":184,"address":[2424673,2424573,2424656],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":190,"address":[2424752],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":191,"address":[2424764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[3908752,3909039],"length":1,"stats":{"Line":2},"fn_name":"with_openapi<(borrow_bag::handle::Handle<gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, borrow_bag::handle::Take>, ()),(gotham::pipeline::Pipeline<(gotham_restful::auth::AuthMiddleware<openapi_specification::AuthData, gotham_restful::auth::StaticAuthHandler>, ())>, ()),closure-0>"},{"line":207,"address":[3908886,3908772],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[3908788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":210,"address":[3908797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[3908921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[1983168],"length":1,"stats":{"Line":5},"fn_name":"resource<(),(),custom_request_body::FooResource>"},{"line":222,"address":[1983275,1983192],"length":1,"stats":{"Line":8},"fn_name":null},{"line":223,"address":[1983227,1983286],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[1983301],"length":1,"stats":{"Line":5},"fn_name":null},{"line":234,"address":[1986624,1987517],"length":1,"stats":{"Line":30},"fn_name":"endpoint<(),(),custom_request_body::create___gotham_restful_endpoint>"},{"line":235,"address":[1986647,1987487],"length":1,"stats":{"Line":30},"fn_name":null},{"line":236,"address":[1987003,1987129],"length":1,"stats":{"Line":60},"fn_name":null},{"line":237,"address":[1987390],"length":1,"stats":{"Line":60},"fn_name":null},{"line":238,"address":[2562855,2562724,2562926,2562973],"length":1,"stats":{"Line":120},"fn_name":null},{"line":239,"address":[2562876,2562750,2563312],"length":1,"stats":{"Line":60},"fn_name":null},{"line":240,"address":[2562892,2562965,2563285],"length":1,"stats":{"Line":60},"fn_name":null},{"line":246,"address":[2563022,2563219,2563115,2563229],"length":1,"stats":{"Line":60},"fn_name":null},{"line":247,"address":[2563206,2563159,2563092],"length":1,"stats":{"Line":45},"fn_name":null},{"line":249,"address":[2563198,2563258,2563125],"length":1,"stats":{"Line":30},"fn_name":null}],"covered":58,"coverable":81},{"path":["/","home","runner","work","gotham_restful","gotham_restful","src","types.rs"],"content":"use gotham::hyper::body::Bytes;\nuse mime::{Mime, APPLICATION_JSON};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::error::Error;\n\n#[cfg(not(feature = \"openapi\"))]\npub trait ResourceType {}\n\n#[cfg(not(feature = \"openapi\"))]\nimpl<T> ResourceType for T {}\n\n#[cfg(feature = \"openapi\")]\npub trait ResourceType: OpenapiType {}\n\n#[cfg(feature = \"openapi\")]\nimpl<T: OpenapiType> ResourceType for T {}\n\n/// A type that can be used inside a response body. Implemented for every type that is\n/// serializable with serde. If the `openapi` feature is used, it must also be of type\n/// [OpenapiType].\n///\n///  [OpenapiType]: trait.OpenapiType.html\npub trait ResponseBody: ResourceType + Serialize {}\n\nimpl<T: ResourceType + Serialize> ResponseBody for T {}\n\n/**\nThis trait should be implemented for every type that can be built from an HTTP request body\nplus its media type.\n\nFor most use cases it is sufficient to derive this trait, you usually don't need to manually\nimplement this. Therefore, make sure that the first variable of your struct can be built from\n[Bytes], and the second one can be build from [Mime]. If you have any additional variables, they\nneed to be [Default]. This is an example of such a struct:\n\n```rust\n# #[macro_use] extern crate gotham_restful;\n# use gotham_restful::*;\n#[derive(FromBody, RequestBody)]\n#[supported_types(mime::IMAGE_GIF, mime::IMAGE_JPEG, mime::IMAGE_PNG)]\nstruct RawImage {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n```\n*/\npub trait FromBody: Sized {\n\t/// The error type returned by the conversion if it was unsuccessfull. When using the derive\n\t/// macro, there is no way to trigger an error, so [std::convert::Infallible] is used here.\n\t/// However, this might change in the future.\n\ttype Err: Error;\n\n\t/// Perform the conversion.\n\tfn from_body(body: Bytes, content_type: Mime) -> Result<Self, Self::Err>;\n}\n\nimpl<T: DeserializeOwned> FromBody for T {\n\ttype Err = serde_json::Error;\n\n\tfn from_body(body: Bytes, _content_type: Mime) -> Result<Self, Self::Err> {\n\t\tserde_json::from_slice(&body)\n\t}\n}\n\n/**\nA type that can be used inside a request body. Implemented for every type that is deserializable\nwith serde. If the `openapi` feature is used, it must also be of type [OpenapiType].\n\nIf you want a non-deserializable type to be used as a request body, e.g. because you'd like to\nget the raw data, you can derive it for your own type. All you need is to have a type implementing\n[FromBody] and optionally a list of supported media types:\n\n```rust\n# #[macro_use] extern crate gotham_restful;\n# use gotham_restful::*;\n#[derive(FromBody, RequestBody)]\n#[supported_types(mime::IMAGE_GIF, mime::IMAGE_JPEG, mime::IMAGE_PNG)]\nstruct RawImage {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n```\n\n [OpenapiType]: trait.OpenapiType.html\n*/\npub trait RequestBody: ResourceType + FromBody {\n\t/// Return all types that are supported as content types. Use `None` if all types are supported.\n\tfn supported_types() -> Option<Vec<Mime>> {\n\t\tNone\n\t}\n}\n\nimpl<T: ResourceType + DeserializeOwned> RequestBody for T {\n\tfn supported_types() -> Option<Vec<Mime>> {\n\t\tSome(vec![APPLICATION_JSON])\n\t}\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","async_methods.rs"],"content":"#[macro_use]\nextern crate gotham_derive;\n\nuse gotham::{\n\thyper::{HeaderMap, Method},\n\trouter::builder::*,\n\tstate::State,\n\ttest::TestServer\n};\nuse gotham_restful::*;\nuse mime::{APPLICATION_JSON, TEXT_PLAIN};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse serde::Deserialize;\nuse tokio::time::{sleep, Duration};\n\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::{test_delete_response, test_get_response, test_post_response, test_put_response};\n\n#[derive(Resource)]\n#[resource(read_all, read, search, create, update_all, update, delete_all, delete, state_test)]\nstruct FooResource;\n\n#[derive(Deserialize)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooBody {\n\tdata: String\n}\n\n#[derive(Clone, Deserialize, StateData, StaticResponseExtender)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooSearch {\n\tquery: String\n}\n\nconst READ_ALL_RESPONSE: &[u8] = b\"1ARwwSPVyOKpJKrYwqGgECPVWDl1BqajAAj7g7WJ3e\";\n#[read_all]\nasync fn read_all() -> Raw<&'static [u8]> {\n\tRaw::new(READ_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst READ_RESPONSE: &[u8] = b\"FEReHoeBKU17X2bBpVAd1iUvktFL43CDu0cFYHdaP9\";\n#[read]\nasync fn read(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(READ_RESPONSE, TEXT_PLAIN)\n}\n\nconst SEARCH_RESPONSE: &[u8] = b\"AWqcQUdBRHXKh3at4u79mdupOAfEbnTcx71ogCVF0E\";\n#[search]\nasync fn search(_body: FooSearch) -> Raw<&'static [u8]> {\n\tRaw::new(SEARCH_RESPONSE, TEXT_PLAIN)\n}\n\nconst CREATE_RESPONSE: &[u8] = b\"y6POY7wOMAB0jBRBw0FJT7DOpUNbhmT8KdpQPLkI83\";\n#[create]\nasync fn create(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(CREATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_ALL_RESPONSE: &[u8] = b\"QlbYg8gHE9OQvvk3yKjXJLTSXlIrg9mcqhfMXJmQkv\";\n#[update_all]\nasync fn update_all(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_RESPONSE: &[u8] = b\"qGod55RUXkT1lgPO8h0uVM6l368O2S0GrwENZFFuRu\";\n#[update]\nasync fn update(_id: u64, _body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_ALL_RESPONSE: &[u8] = b\"Y36kZ749MRk2Nem4BedJABOZiZWPLOtiwLfJlGTwm5\";\n#[delete_all]\nasync fn delete_all() -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_RESPONSE: &[u8] = b\"CwRzBrKErsVZ1N7yeNfjZuUn1MacvgBqk4uPOFfDDq\";\n#[delete]\nasync fn delete(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_RESPONSE, TEXT_PLAIN)\n}\n\nconst STATE_TEST_RESPONSE: &[u8] = b\"xxJbxOuwioqR5DfzPuVqvaqRSfpdNQGluIvHU4n1LM\";\n#[endpoint(method = \"Method::GET\", uri = \"state_test\")]\nasync fn state_test(state: &mut State) -> Raw<&'static [u8]> {\n\tsleep(Duration::from_nanos(1)).await;\n\tstate.borrow::<HeaderMap>();\n\tsleep(Duration::from_nanos(1)).await;\n\tRaw::new(STATE_TEST_RESPONSE, TEXT_PLAIN)\n}\n\n#[test]\nfn async_methods() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.resource::<FooResource>(\"foo\");\n\t}))\n\t.unwrap();\n\n\ttest_get_response(&server, \"http://localhost/foo\", READ_ALL_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/1\", READ_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/search?query=hello+world\", SEARCH_RESPONSE);\n\ttest_post_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tCREATE_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_ALL_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo/1\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_RESPONSE\n\t);\n\ttest_delete_response(&server, \"http://localhost/foo\", DELETE_ALL_RESPONSE);\n\ttest_delete_response(&server, \"http://localhost/foo/1\", DELETE_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/state_test\", STATE_TEST_RESPONSE);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","cors_handling.rs"],"content":"#![cfg(feature = \"cors\")]\nuse gotham::{\n\thyper::{body::Body, client::connect::Connect, header::*, StatusCode},\n\tpipeline::{new_pipeline, single::single_pipeline},\n\trouter::builder::*,\n\ttest::{Server, TestRequest, TestServer}\n};\nuse gotham_restful::{\n\tcors::{Headers, Origin},\n\tread_all, update_all, CorsConfig, DrawResources, Raw, Resource\n};\nuse mime::TEXT_PLAIN;\n\n#[derive(Resource)]\n#[resource(read_all, update_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() {}\n\n#[update_all]\nfn update_all(_body: Raw<Vec<u8>>) {}\n\nfn test_server(cfg: CorsConfig) -> TestServer {\n\tlet (chain, pipeline) = single_pipeline(new_pipeline().add(cfg).build());\n\tTestServer::new(build_router(chain, pipeline, |router| router.resource::<FooResource>(\"/foo\"))).unwrap()\n}\n\nfn test_response<TS, C>(req: TestRequest<TS, C>, origin: Option<&str>, vary: Option<&str>, credentials: bool)\nwhere\n\tTS: Server + 'static,\n\tC: Connect + Clone + Send + Sync + 'static\n{\n\tlet res = req\n\t\t.with_header(ORIGIN, \"http://example.org\".parse().unwrap())\n\t\t.perform()\n\t\t.unwrap();\n\tassert_eq!(res.status(), StatusCode::NO_CONTENT);\n\tlet headers = res.headers();\n\tprintln!(\"{}\", headers.keys().map(|name| name.as_str()).collect::<Vec<_>>().join(\",\"));\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_ORIGIN)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\torigin\n\t);\n\tassert_eq!(headers.get(VARY).and_then(|value| value.to_str().ok()).as_deref(), vary);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.map(|value| value == \"true\")\n\t\t\t.unwrap_or(false),\n\t\tcredentials\n\t);\n\tassert!(headers.get(ACCESS_CONTROL_MAX_AGE).is_none());\n}\n\nfn test_preflight(server: &TestServer, method: &str, origin: Option<&str>, vary: &str, credentials: bool, max_age: u64) {\n\tlet res = server\n\t\t.client()\n\t\t.options(\"http://example.org/foo\")\n\t\t.with_header(ACCESS_CONTROL_REQUEST_METHOD, method.parse().unwrap())\n\t\t.with_header(ORIGIN, \"http://example.org\".parse().unwrap())\n\t\t.perform()\n\t\t.unwrap();\n\tassert_eq!(res.status(), StatusCode::NO_CONTENT);\n\tlet headers = res.headers();\n\tprintln!(\"{}\", headers.keys().map(|name| name.as_str()).collect::<Vec<_>>().join(\",\"));\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_METHODS)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\tSome(method)\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_ORIGIN)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.as_deref(),\n\t\torigin\n\t);\n\tassert_eq!(headers.get(VARY).and_then(|value| value.to_str().ok()).as_deref(), Some(vary));\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.map(|value| value == \"true\")\n\t\t\t.unwrap_or(false),\n\t\tcredentials\n\t);\n\tassert_eq!(\n\t\theaders\n\t\t\t.get(ACCESS_CONTROL_MAX_AGE)\n\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t.and_then(|value| value.parse().ok()),\n\t\tSome(max_age)\n\t);\n}\n\nfn test_preflight_headers(\n\tserver: &TestServer,\n\tmethod: &str,\n\trequest_headers: Option<&str>,\n\tallowed_headers: Option<&str>,\n\tvary: &str\n) {\n\tlet client = server.client();\n\tlet mut res = client\n\t\t.options(\"http://example.org/foo\")\n\t\t.with_header(ACCESS_CONTROL_REQUEST_METHOD, method.parse().unwrap())\n\t\t.with_header(ORIGIN, \"http://example.org\".parse().unwrap());\n\tif let Some(hdr) = request_headers {\n\t\tres = res.with_header(ACCESS_CONTROL_REQUEST_HEADERS, hdr.parse().unwrap());\n\t}\n\tlet res = res.perform().unwrap();\n\tassert_eq!(res.status(), StatusCode::NO_CONTENT);\n\tlet headers = res.headers();\n\tprintln!(\"{}\", headers.keys().map(|name| name.as_str()).collect::<Vec<_>>().join(\",\"));\n\tif let Some(hdr) = allowed_headers {\n\t\tassert_eq!(\n\t\t\theaders\n\t\t\t\t.get(ACCESS_CONTROL_ALLOW_HEADERS)\n\t\t\t\t.and_then(|value| value.to_str().ok())\n\t\t\t\t.as_deref(),\n\t\t\tSome(hdr)\n\t\t)\n\t} else {\n\t\tassert!(!headers.contains_key(ACCESS_CONTROL_ALLOW_HEADERS));\n\t}\n\tassert_eq!(headers.get(VARY).and_then(|value| value.to_str().ok()).as_deref(), Some(vary));\n}\n\n#[test]\nfn cors_origin_none() {\n\tlet cfg = Default::default();\n\tlet server = test_server(cfg);\n\n\ttest_preflight(&server, \"PUT\", None, \"access-control-request-method\", false, 0);\n\n\ttest_response(server.client().get(\"http://example.org/foo\"), None, None, false);\n\ttest_response(\n\t\tserver.client().put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tNone,\n\t\tNone,\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_origin_star() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::Star,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(&server, \"PUT\", Some(\"*\"), \"access-control-request-method\", false, 0);\n\n\ttest_response(server.client().get(\"http://example.org/foo\"), Some(\"*\"), None, false);\n\ttest_response(\n\t\tserver.client().put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tSome(\"*\"),\n\t\tNone,\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_origin_single() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::Single(\"https://foo.com\".to_owned()),\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"https://foo.com\"),\n\t\t\"access-control-request-method\",\n\t\tfalse,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tSome(\"https://foo.com\"),\n\t\tNone,\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver.client().put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tSome(\"https://foo.com\"),\n\t\tNone,\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_origin_copy() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::Copy,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"http://example.org\"),\n\t\t\"access-control-request-method,origin\",\n\t\tfalse,\n\t\t0\n\t);\n\n\ttest_response(\n\t\tserver.client().get(\"http://example.org/foo\"),\n\t\tSome(\"http://example.org\"),\n\t\tSome(\"origin\"),\n\t\tfalse\n\t);\n\ttest_response(\n\t\tserver.client().put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tSome(\"http://example.org\"),\n\t\tSome(\"origin\"),\n\t\tfalse\n\t);\n}\n\n#[test]\nfn cors_headers_none() {\n\tlet cfg = Default::default();\n\tlet server = test_server(cfg);\n\n\ttest_preflight_headers(&server, \"PUT\", None, None, \"access-control-request-method\");\n\ttest_preflight_headers(&server, \"PUT\", Some(\"Content-Type\"), None, \"access-control-request-method\");\n}\n\n#[test]\nfn cors_headers_list() {\n\tlet cfg = CorsConfig {\n\t\theaders: Headers::List(vec![CONTENT_TYPE]),\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight_headers(&server, \"PUT\", None, Some(\"content-type\"), \"access-control-request-method\");\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"content-type\"),\n\t\tSome(\"content-type\"),\n\t\t\"access-control-request-method\"\n\t);\n}\n\n#[test]\nfn cors_headers_copy() {\n\tlet cfg = CorsConfig {\n\t\theaders: Headers::Copy,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tNone,\n\t\tNone,\n\t\t\"access-control-request-method,access-control-request-headers\"\n\t);\n\ttest_preflight_headers(\n\t\t&server,\n\t\t\"PUT\",\n\t\tSome(\"content-type\"),\n\t\tSome(\"content-type\"),\n\t\t\"access-control-request-method,access-control-request-headers\"\n\t);\n}\n\n#[test]\nfn cors_credentials() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::None,\n\t\tcredentials: true,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(&server, \"PUT\", None, \"access-control-request-method\", true, 0);\n\n\ttest_response(server.client().get(\"http://example.org/foo\"), None, None, true);\n\ttest_response(\n\t\tserver.client().put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tNone,\n\t\tNone,\n\t\ttrue\n\t);\n}\n\n#[test]\nfn cors_max_age() {\n\tlet cfg = CorsConfig {\n\t\torigin: Origin::None,\n\t\tmax_age: 31536000,\n\t\t..Default::default()\n\t};\n\tlet server = test_server(cfg);\n\n\ttest_preflight(&server, \"PUT\", None, \"access-control-request-method\", false, 31536000);\n\n\ttest_response(server.client().get(\"http://example.org/foo\"), None, None, false);\n\ttest_response(\n\t\tserver.client().put(\"http://example.org/foo\", Body::empty(), TEXT_PLAIN),\n\t\tNone,\n\t\tNone,\n\t\tfalse\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","custom_request_body.rs"],"content":"use gotham::{hyper::header::CONTENT_TYPE, router::builder::*, test::TestServer};\nuse gotham_restful::*;\nuse mime::TEXT_PLAIN;\n\nconst RESPONSE: &[u8] = b\"This is the only valid response.\";\n\n#[derive(Resource)]\n#[resource(create)]\nstruct FooResource;\n\n#[derive(FromBody, RequestBody)]\n#[supported_types(TEXT_PLAIN)]\nstruct Foo {\n\tcontent: Vec<u8>,\n\tcontent_type: Mime\n}\n\n#[create]\nfn create(body: Foo) -> Raw<Vec<u8>> {\n\tRaw::new(body.content, body.content_type)\n}\n\n#[test]\nfn custom_request_body() {\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.resource::<FooResource>(\"foo\");\n\t}))\n\t.unwrap();\n\n\tlet res = server\n\t\t.client()\n\t\t.post(\"http://localhost/foo\", RESPONSE, TEXT_PLAIN)\n\t\t.perform()\n\t\t.unwrap();\n\tassert_eq!(res.headers().get(CONTENT_TYPE).unwrap().to_str().unwrap(), \"text/plain\");\n\tlet res = res.read_body().unwrap();\n\tlet body: &[u8] = res.as_ref();\n\tassert_eq!(body, RESPONSE);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","openapi_specification.rs"],"content":"#![cfg(all(feature = \"auth\", feature = \"openapi\"))]\n\n#[macro_use]\nextern crate gotham_derive;\n#[macro_use]\nextern crate pretty_assertions;\n\nuse gotham::{\n\thyper::Method,\n\tpipeline::{new_pipeline, single::single_pipeline},\n\trouter::builder::*,\n\ttest::TestServer\n};\nuse gotham_restful::*;\nuse mime::IMAGE_PNG;\nuse openapi_type::OpenapiType;\nuse serde::{Deserialize, Serialize};\n\n#[allow(dead_code)]\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::test_openapi_response;\n\nconst IMAGE_RESPONSE : &[u8] = b\"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUA/wA0XsCoAAAAAXRSTlN/gFy0ywAAAApJREFUeJxjYgAAAAYAAzY3fKgAAAAASUVORK5CYII=\";\n\n#[derive(Resource)]\n#[resource(get_image, set_image)]\nstruct ImageResource;\n\n#[derive(FromBody, RequestBody)]\n#[supported_types(IMAGE_PNG)]\nstruct Image(Vec<u8>);\n\n#[read(operation_id = \"getImage\")]\nfn get_image(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(IMAGE_RESPONSE, \"image/png;base64\".parse().unwrap())\n}\n\n#[update(operation_id = \"setImage\")]\nfn set_image(_id: u64, _image: Image) {}\n\n#[derive(Resource)]\n#[resource(read_secret, search_secret)]\nstruct SecretResource;\n\n#[derive(Deserialize, Clone)]\nstruct AuthData {\n\tsub: String,\n\tiat: u64,\n\texp: u64\n}\n\ntype AuthStatus = gotham_restful::AuthStatus<AuthData>;\n\n#[derive(OpenapiType, Serialize)]\nstruct Secret {\n\tcode: f32\n}\n\n#[derive(OpenapiType, Serialize)]\nstruct Secrets {\n\tsecrets: Vec<Secret>\n}\n\n#[derive(Clone, Deserialize, OpenapiType, StateData, StaticResponseExtender)]\nstruct SecretQuery {\n\tdate: String,\n\thour: Option<u16>,\n\tminute: Option<u16>\n}\n\n/// This endpoint gives access to the secret.\n///\n/// You need to be authenticated to call this endpoint.\n#[read]\nfn read_secret(auth: AuthStatus, _id: String) -> AuthSuccess<Secret> {\n\tauth.ok()?;\n\tOk(Secret { code: 4.2 })\n}\n\n#[search]\nfn search_secret(auth: AuthStatus, _query: SecretQuery) -> AuthSuccess<Secrets> {\n\tauth.ok()?;\n\tOk(Secrets {\n\t\tsecrets: vec![Secret { code: 4.2 }, Secret { code: 3.14 }]\n\t})\n}\n\n#[derive(Resource)]\n#[resource(custom_read_with, custom_patch)]\nstruct CustomResource;\n\n#[derive(Clone, Deserialize, OpenapiType, StateData, StaticResponseExtender)]\nstruct ReadWithPath {\n\tfrom: String,\n\tid: u64\n}\n\n#[endpoint(method = \"Method::GET\", uri = \"read/:from/with/:id\")]\nfn custom_read_with(_path: ReadWithPath) {}\n\n#[endpoint(method = \"Method::PATCH\", uri = \"\", body = true)]\nfn custom_patch(_body: String) {}\n\n#[test]\nfn openapi_specification() {\n\tlet info = OpenapiInfo {\n\t\ttitle: \"This is just a test\".to_owned(),\n\t\tversion: \"1.2.3\".to_owned(),\n\t\turls: vec![\"http://localhost:12345/api/v1\".to_owned()]\n\t};\n\tlet auth: AuthMiddleware<AuthData, _> = AuthMiddleware::new(\n\t\tAuthSource::AuthorizationHeader,\n\t\tAuthValidation::default(),\n\t\tStaticAuthHandler::from_array(b\"zlBsA2QXnkmpe0QTh8uCvtAEa4j33YAc\")\n\t);\n\tlet (chain, pipelines) = single_pipeline(new_pipeline().add(auth).build());\n\tlet server = TestServer::new(build_router(chain, pipelines, |router| {\n\t\trouter.with_openapi(info, |mut router| {\n\t\t\t// the leading slash tests that the spec doesn't contain '//img' nonsense\n\t\t\trouter.resource::<ImageResource>(\"/img\");\n\t\t\trouter.resource::<SecretResource>(\"secret\");\n\t\t\trouter.resource::<CustomResource>(\"custom\");\n\t\t\trouter.openapi_spec(\"openapi\");\n\t\t});\n\t}))\n\t.unwrap();\n\n\ttest_openapi_response(&server, \"http://localhost/openapi\", \"tests/openapi_specification.json\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","openapi_supports_scope.rs"],"content":"#![cfg(feature = \"openapi\")]\n\n#[macro_use]\nextern crate pretty_assertions;\n\nuse gotham::{router::builder::*, test::TestServer};\nuse gotham_restful::*;\nuse mime::TEXT_PLAIN;\n\n#[allow(dead_code)]\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::{test_get_response, test_openapi_response};\n\nconst RESPONSE: &[u8] = b\"This is the only valid response.\";\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() -> Raw<&'static [u8]> {\n\tRaw::new(RESPONSE, TEXT_PLAIN)\n}\n\n#[test]\nfn openapi_supports_scope() {\n\tlet info = OpenapiInfo {\n\t\ttitle: \"Test\".to_owned(),\n\t\tversion: \"1.2.3\".to_owned(),\n\t\turls: Vec::new()\n\t};\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.with_openapi(info, |mut router| {\n\t\t\trouter.openapi_spec(\"openapi\");\n\t\t\trouter.resource::<FooResource>(\"foo1\");\n\t\t\trouter.scope(\"/bar\", |router| {\n\t\t\t\trouter.resource::<FooResource>(\"foo2\");\n\t\t\t\trouter.scope(\"/baz\", |router| {\n\t\t\t\t\trouter.resource::<FooResource>(\"foo3\");\n\t\t\t\t})\n\t\t\t});\n\t\t\trouter.resource::<FooResource>(\"foo4\");\n\t\t});\n\t}))\n\t.unwrap();\n\n\ttest_get_response(&server, \"http://localhost/foo1\", RESPONSE);\n\ttest_get_response(&server, \"http://localhost/bar/foo2\", RESPONSE);\n\ttest_get_response(&server, \"http://localhost/bar/baz/foo3\", RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo4\", RESPONSE);\n\ttest_openapi_response(&server, \"http://localhost/openapi\", \"tests/openapi_supports_scope.json\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","resource_error.rs"],"content":"use gotham_restful::ResourceError;\n\n#[derive(ResourceError)]\nenum Error {\n\t#[display(\"I/O Error: {0}\")]\n\tIoError(#[from] std::io::Error),\n\n\t#[status(INTERNAL_SERVER_ERROR)]\n\t#[display(\"Internal Server Error: {0}\")]\n\tInternalServerError(String)\n}\n\n#[allow(deprecated)]\nmod resource_error {\n\tuse super::Error;\n\tuse gotham::hyper::StatusCode;\n\tuse gotham_restful::IntoResponseError;\n\tuse mime::APPLICATION_JSON;\n\n\t#[test]\n\tfn io_error() {\n\t\tlet err = Error::IoError(std::io::Error::last_os_error());\n\t\tlet res = err.into_response_error().unwrap();\n\t\tassert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n\t\tassert_eq!(res.mime(), Some(&APPLICATION_JSON));\n\t}\n\n\t#[test]\n\tfn internal_server_error() {\n\t\tlet err = Error::InternalServerError(\"Brocken\".to_owned());\n\t\tassert_eq!(&format!(\"{}\", err), \"Internal Server Error: Brocken\");\n\n\t\tlet res = err.into_response_error().unwrap();\n\t\tassert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n\t\tassert_eq!(res.mime(), None); // TODO shouldn't this be a json error message?\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","sync_methods.rs"],"content":"#[macro_use]\nextern crate gotham_derive;\n\nuse gotham::{router::builder::*, test::TestServer};\nuse gotham_restful::*;\nuse mime::{APPLICATION_JSON, TEXT_PLAIN};\n#[cfg(feature = \"openapi\")]\nuse openapi_type::OpenapiType;\nuse serde::Deserialize;\n\nmod util {\n\tinclude!(\"util/mod.rs\");\n}\nuse util::{test_delete_response, test_get_response, test_post_response, test_put_response};\n\n#[derive(Resource)]\n#[resource(read_all, read, search, create, update_all, update, delete_all, delete)]\nstruct FooResource;\n\n#[derive(Deserialize)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooBody {\n\tdata: String\n}\n\n#[derive(Clone, Deserialize, StateData, StaticResponseExtender)]\n#[cfg_attr(feature = \"openapi\", derive(OpenapiType))]\n#[allow(dead_code)]\nstruct FooSearch {\n\tquery: String\n}\n\nconst READ_ALL_RESPONSE: &[u8] = b\"1ARwwSPVyOKpJKrYwqGgECPVWDl1BqajAAj7g7WJ3e\";\n#[read_all]\nfn read_all() -> Raw<&'static [u8]> {\n\tRaw::new(READ_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst READ_RESPONSE: &[u8] = b\"FEReHoeBKU17X2bBpVAd1iUvktFL43CDu0cFYHdaP9\";\n#[read]\nfn read(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(READ_RESPONSE, TEXT_PLAIN)\n}\n\nconst SEARCH_RESPONSE: &[u8] = b\"AWqcQUdBRHXKh3at4u79mdupOAfEbnTcx71ogCVF0E\";\n#[search]\nfn search(_body: FooSearch) -> Raw<&'static [u8]> {\n\tRaw::new(SEARCH_RESPONSE, TEXT_PLAIN)\n}\n\nconst CREATE_RESPONSE: &[u8] = b\"y6POY7wOMAB0jBRBw0FJT7DOpUNbhmT8KdpQPLkI83\";\n#[create]\nfn create(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(CREATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_ALL_RESPONSE: &[u8] = b\"QlbYg8gHE9OQvvk3yKjXJLTSXlIrg9mcqhfMXJmQkv\";\n#[update_all]\nfn update_all(_body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst UPDATE_RESPONSE: &[u8] = b\"qGod55RUXkT1lgPO8h0uVM6l368O2S0GrwENZFFuRu\";\n#[update]\nfn update(_id: u64, _body: FooBody) -> Raw<&'static [u8]> {\n\tRaw::new(UPDATE_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_ALL_RESPONSE: &[u8] = b\"Y36kZ749MRk2Nem4BedJABOZiZWPLOtiwLfJlGTwm5\";\n#[delete_all]\nfn delete_all() -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_ALL_RESPONSE, TEXT_PLAIN)\n}\n\nconst DELETE_RESPONSE: &[u8] = b\"CwRzBrKErsVZ1N7yeNfjZuUn1MacvgBqk4uPOFfDDq\";\n#[delete]\nfn delete(_id: u64) -> Raw<&'static [u8]> {\n\tRaw::new(DELETE_RESPONSE, TEXT_PLAIN)\n}\n\n#[test]\nfn sync_methods() {\n\tlet _ = pretty_env_logger::try_init_timed();\n\n\tlet server = TestServer::new(build_simple_router(|router| {\n\t\trouter.resource::<FooResource>(\"foo\");\n\t}))\n\t.unwrap();\n\n\ttest_get_response(&server, \"http://localhost/foo\", READ_ALL_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/1\", READ_RESPONSE);\n\ttest_get_response(&server, \"http://localhost/foo/search?query=hello+world\", SEARCH_RESPONSE);\n\ttest_post_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tCREATE_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_ALL_RESPONSE\n\t);\n\ttest_put_response(\n\t\t&server,\n\t\t\"http://localhost/foo/1\",\n\t\tr#\"{\"data\":\"hello world\"}\"#,\n\t\tAPPLICATION_JSON,\n\t\tUPDATE_RESPONSE\n\t);\n\ttest_delete_response(&server, \"http://localhost/foo\", DELETE_ALL_RESPONSE);\n\ttest_delete_response(&server, \"http://localhost/foo/1\", DELETE_RESPONSE);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","trybuild_ui.rs"],"content":"use trybuild::TestCases;\n\n#[test]\n#[ignore]\nfn trybuild_ui() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/ui/endpoint/*.rs\");\n\tt.compile_fail(\"tests/ui/from_body/*.rs\");\n\tt.compile_fail(\"tests/ui/resource/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","async_state.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham::state::State;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nasync fn read_all(state: &State) {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","auth_data_non_clone.rs"],"content":"use gotham_restful::*;\nuse serde::Deserialize;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[derive(Deserialize)]\nstruct AuthData {\n\tiat: u64,\n\texp: u64\n}\n\n#[read_all]\nasync fn read_all(auth: AuthStatus<AuthData>) -> Result<NoContent, AuthError> {\n\tauth.ok()?;\n\tOk(NoContent::default())\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_method_invalid_expr.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(method = \"I like pizza\", uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_method_invalid_type.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(method = \"String::new()\", uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_method_missing.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","custom_uri_missing.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[endpoint(method = \"gotham_restful::gotham::hyper::Method::GET\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(FooResource)]\nfn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_body_ty.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\n#[derive(Debug)]\nstruct FooBody {\n\tfoo: String\n}\n\n#[endpoint(method = \"Method::GET\", uri = \"\", body = true)]\nfn endpoint(_: FooBody) {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_params_ty.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\n#[derive(Debug)]\nstruct FooParams {\n\tfoo: String\n}\n\n#[endpoint(method = \"Method::GET\", uri = \"\", params = true)]\nfn endpoint(_: FooParams) {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_placeholders_ty.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\n#[derive(Debug)]\nstruct FooPlaceholders {\n\tfoo: String\n}\n\n#[endpoint(method = \"Method::GET\", uri = \":foo\")]\nfn endpoint(_: FooPlaceholders) {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","invalid_return_type.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\nuse gotham_restful::gotham::hyper::Method;\n\n#[derive(Resource)]\n#[resource(endpoint)]\nstruct FooResource;\n\nstruct FooResponse;\n\n#[endpoint(method = \"Method::GET\", uri = \"\")]\nfn endpoint() -> FooResponse {\n\tunimplemented!()\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_body_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(body = false)]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_method_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(method = \"gotham_restful::gotham::hyper::Method::GET\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_params_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(params = true)]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","non_custom_uri_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(uri = \"custom_read\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","self.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all(self) {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","too_few_args.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read)]\nstruct FooResource;\n\n#[read]\nfn read() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","too_many_args.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nfn read_all(_id: u64) {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","unknown_attribute.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(pineapple = \"on pizza\")]\nfn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","unsafe.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all]\nunsafe fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","endpoint","wants_auth_non_bool.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_all)]\nstruct FooResource;\n\n#[read_all(wants_auth = \"yes, please\")]\nasync fn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","from_body","enum.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(FromBody)]\nenum FromBodyEnum {\n\tSomeVariant(Vec<u8>),\n\tOtherVariant(String)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","ui","resource","unknown_method.rs"],"content":"#[macro_use]\nextern crate gotham_restful;\n\n#[derive(Resource)]\n#[resource(read_any)]\nstruct FooResource;\n\n#[read_all]\nfn read_all() {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","gotham_restful","gotham_restful","tests","util","mod.rs"],"content":"use gotham::{\n\thyper::Body,\n\ttest::TestServer\n};\nuse log::info;\nuse mime::Mime;\n#[allow(unused_imports)]\nuse std::{fs::File, io::{Read, Write}, str};\n\npub fn test_get_response(server : &TestServer, path : &str, expected : &[u8])\n{\n\tinfo!(\"GET {}\", path);\n\tlet res = server.client().get(path).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\npub fn test_post_response<B>(server : &TestServer, path : &str, body : B, mime : Mime, expected : &[u8])\nwhere\n\tB : Into<Body>\n{\n\tinfo!(\"POST {}\", path);\n\tlet res = server.client().post(path, body, mime).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\npub fn test_put_response<B>(server : &TestServer, path : &str, body : B, mime : Mime, expected : &[u8])\nwhere\n\tB : Into<Body>\n{\n\tinfo!(\"PUT {}\", path);\n\tlet res = server.client().put(path, body, mime).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\npub fn test_delete_response(server : &TestServer, path : &str, expected : &[u8])\n{\n\tinfo!(\"DELETE {}\", path);\n\tlet res = server.client().delete(path).perform().unwrap().read_body().unwrap();\n\tlet body : &[u8] = res.as_ref();\n\tassert_eq!(body, expected);\n}\n\n#[cfg(feature = \"openapi\")]\npub fn test_openapi_response(server : &TestServer, path : &str, output_file : &str)\n{\n\tinfo!(\"GET {}\", path);\n\tlet res = server.client().get(path).perform().unwrap().read_body().unwrap();\n\tlet body: serde_json::Value = serde_json::from_slice(&res).unwrap();\n\n\tlet mut file = File::open(output_file).unwrap();\n\tlet expected: serde_json::Value = serde_json::from_reader(&mut file).unwrap();\n\n\t//eprintln!(\"{}\", body);\n\tassert_eq!(body, expected);\n}\n","traces":[],"covered":0,"coverable":0}]}